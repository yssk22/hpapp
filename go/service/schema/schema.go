/*
Package schema provides the ent schema service for the hpapp services.

hpapp uses the relational database as a primary database and `github.com/yssk22/hpapp/go/system/database` package provides only
database connection and actual SQL queries are implemented at `github.com/yssk22/hpapp/go/service/ent` on top of entgo framework where
`github.com/yssk22/hpapp/go/service/ent` package is automatically generated by this schema package.

# Data access using Ent framework

The implementation of the service uses the ent framework to access the database. For example, to get all artist information, you can do the following.

	func DoSomething(ctx context.Context) {
		entclient := entutil.NewClient(ctx)
		artists, err := entclient.HPArtist.Query().All(ctx)
		if err != ni {
			panic(err)
		}
	    // do something on artits
	}

`entutil.NewClient(ctx)` can be called at any time. Database connections are managed by \*sql.DB and connection pooling.

# Publish ent to GraphQL

The data defined in ent needs to be considered how to pulish it to GraphQL.

# Access control at the table level

You can control the exposure of the table to GraphQL by using `Annotation()`. In the following format, MyEnt defines how all fields are defined in the GraphQL schema and exposed.

	func (MyEnt) Annotations() []schema.Annotation {
		return []schema.Annotation{}
	}

To stop publishing ent schema itself, specify `entgql.Skip()`.

	func (MyEnt) Annotations() []schema.Annotation {
		return []schema.Annotation{
			entgql.Skip(entgql.SkipAll),
		}
	}

# Access control at the field level

Like access control at the table level, you can also control access at the field level. For example, the following example does not expose the expire_at field in GraphQL.

	field.Time("expire_at").Optional().Comment("token expire").Annotations(
		entgql.Skip(entgql.SkipAll),
	),

# Access control at the query level

The published ent is generally in a state where anyone can access it as long as the ID is known. This is because GraphQL conforms to the Relay specification and can be accessed
in the form of `Query.node(id: ID!)`. Therefore, always consider the access control policy for the Ent exposed by GraphQL.

For example, ent.User holds the application access token. Therefore, access should not be allowed for records other than your own.
To implement this in the Ent Privacy Rule, make sure that the `id = "{currentUserID}"` Where clause is always included for the User query. This is implemented using `privacy.FilterFunc`.

	func (User) Policy() ent.Policy {
		return privacy.Policy{
			Query: privacy.QueryPolicy{
				auth.AlloIfAdmin(),
				privacy.FilterFunc(func(ctx context.Context, f privacy.Filter) error {
					uid, err := strconv.Atoi(auth.CurrentUser(ctx).ID())
					if err != nil {
						return privacy.Denyf("invalid uid")
					}
					af, ok := f.(*myent.UserFilter)
					if !ok {
						return errors.Wrap(ctx, fmt.Errorf("invalid filter applied: %#v", f))
					}
					af.WhereID(entql.IntEQ(uid))
					return privacy.Skip
				}),
			},
		}
	}

Also, for example, ent.Auth is a record that holds the external authentication information owned by ent.User, but access should not be allowed for records other than your own.
Similarly, when querying Auth, make sure that the `owner_user_id = "{currentUserID}"` Where clause is always included.

	func (Auth) Policy() ent.Policy {
		return privacy.Policy{
			Query: privacy.QueryPolicy{
				auth.AlloIfAdmin(),
				auth.CanSeeOnlyMine(),
			},
		}
	}
*/
package schema
