// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/yssk22/hpapp/go/service/ent/auth"
	"github.com/yssk22/hpapp/go/service/ent/hpameblopost"
	"github.com/yssk22/hpapp/go/service/ent/hpartist"
	"github.com/yssk22/hpapp/go/service/ent/hpasset"
	"github.com/yssk22/hpapp/go/service/ent/hpblob"
	"github.com/yssk22/hpapp/go/service/ent/hpelineupmallitem"
	"github.com/yssk22/hpapp/go/service/ent/hpelineupmallitempurchasehistory"
	"github.com/yssk22/hpapp/go/service/ent/hpevent"
	"github.com/yssk22/hpapp/go/service/ent/hpfceventticket"
	"github.com/yssk22/hpapp/go/service/ent/hpfeeditem"
	"github.com/yssk22/hpapp/go/service/ent/hpfollow"
	"github.com/yssk22/hpapp/go/service/ent/hpigpost"
	"github.com/yssk22/hpapp/go/service/ent/hpmember"
	"github.com/yssk22/hpapp/go/service/ent/hpsorthistory"
	"github.com/yssk22/hpapp/go/service/ent/hpviewhistory"
	"github.com/yssk22/hpapp/go/service/ent/metric"
	"github.com/yssk22/hpapp/go/service/ent/metricdryrun"
	"github.com/yssk22/hpapp/go/service/ent/predicate"
	"github.com/yssk22/hpapp/go/service/ent/testent"
	"github.com/yssk22/hpapp/go/service/ent/user"
	"github.com/yssk22/hpapp/go/service/ent/usernotificationlog"
	"github.com/yssk22/hpapp/go/service/ent/usernotificationsetting"
	"github.com/yssk22/hpapp/go/service/schema/enums"
	"github.com/yssk22/hpapp/go/service/schema/jsonfields"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuth                             = "Auth"
	TypeHPAmebloPost                     = "HPAmebloPost"
	TypeHPArtist                         = "HPArtist"
	TypeHPAsset                          = "HPAsset"
	TypeHPBlob                           = "HPBlob"
	TypeHPElineupMallItem                = "HPElineupMallItem"
	TypeHPElineupMallItemPurchaseHistory = "HPElineupMallItemPurchaseHistory"
	TypeHPEvent                          = "HPEvent"
	TypeHPFCEventTicket                  = "HPFCEventTicket"
	TypeHPFeedItem                       = "HPFeedItem"
	TypeHPFollow                         = "HPFollow"
	TypeHPIgPost                         = "HPIgPost"
	TypeHPMember                         = "HPMember"
	TypeHPSortHistory                    = "HPSortHistory"
	TypeHPViewHistory                    = "HPViewHistory"
	TypeMetric                           = "Metric"
	TypeMetricDryRun                     = "MetricDryRun"
	TypeTestEnt                          = "TestEnt"
	TypeUser                             = "User"
	TypeUserNotificationLog              = "UserNotificationLog"
	TypeUserNotificationSetting          = "UserNotificationSetting"
)

// AuthMutation represents an operation that mutates the Auth nodes in the graph.
type AuthMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	provider_name    *string
	provider_user_id *string
	access_token     *string
	refresh_token    *string
	expire_at        *time.Time
	scope            *[]string
	appendscope      []string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Auth, error)
	predicates       []predicate.Auth
}

var _ ent.Mutation = (*AuthMutation)(nil)

// authOption allows management of the mutation configuration using functional options.
type authOption func(*AuthMutation)

// newAuthMutation creates new mutation for the Auth entity.
func newAuthMutation(c config, op Op, opts ...authOption) *AuthMutation {
	m := &AuthMutation{
		config:        c,
		op:            op,
		typ:           TypeAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthID sets the ID field of the mutation.
func withAuthID(id int) authOption {
	return func(m *AuthMutation) {
		var (
			err   error
			once  sync.Once
			value *Auth
		)
		m.oldValue = func(ctx context.Context) (*Auth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuth sets the old Auth of the mutation.
func withAuth(node *Auth) authOption {
	return func(m *AuthMutation) {
		m.oldValue = func(context.Context) (*Auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Auth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AuthMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[auth.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AuthMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[auth.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, auth.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AuthMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[auth.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AuthMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[auth.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, auth.FieldUpdatedAt)
}

// SetProviderName sets the "provider_name" field.
func (m *AuthMutation) SetProviderName(s string) {
	m.provider_name = &s
}

// ProviderName returns the value of the "provider_name" field in the mutation.
func (m *AuthMutation) ProviderName() (r string, exists bool) {
	v := m.provider_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderName returns the old "provider_name" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldProviderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderName: %w", err)
	}
	return oldValue.ProviderName, nil
}

// ResetProviderName resets all changes to the "provider_name" field.
func (m *AuthMutation) ResetProviderName() {
	m.provider_name = nil
}

// SetProviderUserID sets the "provider_user_id" field.
func (m *AuthMutation) SetProviderUserID(s string) {
	m.provider_user_id = &s
}

// ProviderUserID returns the value of the "provider_user_id" field in the mutation.
func (m *AuthMutation) ProviderUserID() (r string, exists bool) {
	v := m.provider_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderUserID returns the old "provider_user_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldProviderUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderUserID: %w", err)
	}
	return oldValue.ProviderUserID, nil
}

// ResetProviderUserID resets all changes to the "provider_user_id" field.
func (m *AuthMutation) ResetProviderUserID() {
	m.provider_user_id = nil
}

// SetAccessToken sets the "access_token" field.
func (m *AuthMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *AuthMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *AuthMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *AuthMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *AuthMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *AuthMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[auth.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *AuthMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[auth.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *AuthMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, auth.FieldRefreshToken)
}

// SetExpireAt sets the "expire_at" field.
func (m *AuthMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *AuthMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ClearExpireAt clears the value of the "expire_at" field.
func (m *AuthMutation) ClearExpireAt() {
	m.expire_at = nil
	m.clearedFields[auth.FieldExpireAt] = struct{}{}
}

// ExpireAtCleared returns if the "expire_at" field was cleared in this mutation.
func (m *AuthMutation) ExpireAtCleared() bool {
	_, ok := m.clearedFields[auth.FieldExpireAt]
	return ok
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *AuthMutation) ResetExpireAt() {
	m.expire_at = nil
	delete(m.clearedFields, auth.FieldExpireAt)
}

// SetScope sets the "scope" field.
func (m *AuthMutation) SetScope(s []string) {
	m.scope = &s
	m.appendscope = nil
}

// Scope returns the value of the "scope" field in the mutation.
func (m *AuthMutation) Scope() (r []string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldScope(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// AppendScope adds s to the "scope" field.
func (m *AuthMutation) AppendScope(s []string) {
	m.appendscope = append(m.appendscope, s...)
}

// AppendedScope returns the list of values that were appended to the "scope" field in this mutation.
func (m *AuthMutation) AppendedScope() ([]string, bool) {
	if len(m.appendscope) == 0 {
		return nil, false
	}
	return m.appendscope, true
}

// ClearScope clears the value of the "scope" field.
func (m *AuthMutation) ClearScope() {
	m.scope = nil
	m.appendscope = nil
	m.clearedFields[auth.FieldScope] = struct{}{}
}

// ScopeCleared returns if the "scope" field was cleared in this mutation.
func (m *AuthMutation) ScopeCleared() bool {
	_, ok := m.clearedFields[auth.FieldScope]
	return ok
}

// ResetScope resets all changes to the "scope" field.
func (m *AuthMutation) ResetScope() {
	m.scope = nil
	m.appendscope = nil
	delete(m.clearedFields, auth.FieldScope)
}

// SetOwnerUserID sets the "owner_user_id" field.
func (m *AuthMutation) SetOwnerUserID(i int) {
	m.user = &i
}

// OwnerUserID returns the value of the "owner_user_id" field in the mutation.
func (m *AuthMutation) OwnerUserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerUserID returns the old "owner_user_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldOwnerUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerUserID: %w", err)
	}
	return oldValue.OwnerUserID, nil
}

// ClearOwnerUserID clears the value of the "owner_user_id" field.
func (m *AuthMutation) ClearOwnerUserID() {
	m.user = nil
	m.clearedFields[auth.FieldOwnerUserID] = struct{}{}
}

// OwnerUserIDCleared returns if the "owner_user_id" field was cleared in this mutation.
func (m *AuthMutation) OwnerUserIDCleared() bool {
	_, ok := m.clearedFields[auth.FieldOwnerUserID]
	return ok
}

// ResetOwnerUserID resets all changes to the "owner_user_id" field.
func (m *AuthMutation) ResetOwnerUserID() {
	m.user = nil
	delete(m.clearedFields, auth.FieldOwnerUserID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AuthMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuthMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuthMutation) UserCleared() bool {
	return m.OwnerUserIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AuthMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuthMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuthMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AuthMutation builder.
func (m *AuthMutation) Where(ps ...predicate.Auth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Auth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Auth).
func (m *AuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, auth.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, auth.FieldUpdatedAt)
	}
	if m.provider_name != nil {
		fields = append(fields, auth.FieldProviderName)
	}
	if m.provider_user_id != nil {
		fields = append(fields, auth.FieldProviderUserID)
	}
	if m.access_token != nil {
		fields = append(fields, auth.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, auth.FieldRefreshToken)
	}
	if m.expire_at != nil {
		fields = append(fields, auth.FieldExpireAt)
	}
	if m.scope != nil {
		fields = append(fields, auth.FieldScope)
	}
	if m.user != nil {
		fields = append(fields, auth.FieldOwnerUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldCreatedAt:
		return m.CreatedAt()
	case auth.FieldUpdatedAt:
		return m.UpdatedAt()
	case auth.FieldProviderName:
		return m.ProviderName()
	case auth.FieldProviderUserID:
		return m.ProviderUserID()
	case auth.FieldAccessToken:
		return m.AccessToken()
	case auth.FieldRefreshToken:
		return m.RefreshToken()
	case auth.FieldExpireAt:
		return m.ExpireAt()
	case auth.FieldScope:
		return m.Scope()
	case auth.FieldOwnerUserID:
		return m.OwnerUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auth.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case auth.FieldProviderName:
		return m.OldProviderName(ctx)
	case auth.FieldProviderUserID:
		return m.OldProviderUserID(ctx)
	case auth.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case auth.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case auth.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case auth.FieldScope:
		return m.OldScope(ctx)
	case auth.FieldOwnerUserID:
		return m.OldOwnerUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auth.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auth.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case auth.FieldProviderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderName(v)
		return nil
	case auth.FieldProviderUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderUserID(v)
		return nil
	case auth.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case auth.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case auth.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case auth.FieldScope:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case auth.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auth.FieldCreatedAt) {
		fields = append(fields, auth.FieldCreatedAt)
	}
	if m.FieldCleared(auth.FieldUpdatedAt) {
		fields = append(fields, auth.FieldUpdatedAt)
	}
	if m.FieldCleared(auth.FieldRefreshToken) {
		fields = append(fields, auth.FieldRefreshToken)
	}
	if m.FieldCleared(auth.FieldExpireAt) {
		fields = append(fields, auth.FieldExpireAt)
	}
	if m.FieldCleared(auth.FieldScope) {
		fields = append(fields, auth.FieldScope)
	}
	if m.FieldCleared(auth.FieldOwnerUserID) {
		fields = append(fields, auth.FieldOwnerUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMutation) ClearField(name string) error {
	switch name {
	case auth.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case auth.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case auth.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case auth.FieldExpireAt:
		m.ClearExpireAt()
		return nil
	case auth.FieldScope:
		m.ClearScope()
		return nil
	case auth.FieldOwnerUserID:
		m.ClearOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown Auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMutation) ResetField(name string) error {
	switch name {
	case auth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auth.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case auth.FieldProviderName:
		m.ResetProviderName()
		return nil
	case auth.FieldProviderUserID:
		m.ResetProviderUserID()
		return nil
	case auth.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case auth.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case auth.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case auth.FieldScope:
		m.ResetScope()
		return nil
	case auth.FieldOwnerUserID:
		m.ResetOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, auth.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auth.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, auth.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMutation) EdgeCleared(name string) bool {
	switch name {
	case auth.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMutation) ClearEdge(name string) error {
	switch name {
	case auth.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMutation) ResetEdge(name string) error {
	switch name {
	case auth.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Auth edge %s", name)
}

// HPAmebloPostMutation represents an operation that mutates the HPAmebloPost nodes in the graph.
type HPAmebloPostMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	crawled_at            *time.Time
	error_count           *int
	adderror_count        *int
	manually_modified     **jsonfields.ManuallyModified
	last_error_message    *string
	recrawl_required      *bool
	created_at            *time.Time
	updated_at            *time.Time
	_path                 *string
	next_path             *string
	prev_path             *string
	artist_key            *string
	member_key            *string
	title                 *string
	description           *string
	theme                 *string
	post_at               *time.Time
	source                *hpameblopost.Source
	images                *[]jsonfields.Media
	appendimages          []jsonfields.Media
	likes                 *int
	addlikes              *int
	comments              *int
	addcomments           *int
	reblogs               *int
	addreblogs            *int
	clearedFields         map[string]struct{}
	owner_artist          *int
	clearedowner_artist   bool
	owner_member          *int
	clearedowner_member   bool
	tagged_artists        map[int]struct{}
	removedtagged_artists map[int]struct{}
	clearedtagged_artists bool
	tagged_members        map[int]struct{}
	removedtagged_members map[int]struct{}
	clearedtagged_members bool
	asset                 *int
	clearedasset          bool
	blobs                 map[int]struct{}
	removedblobs          map[int]struct{}
	clearedblobs          bool
	done                  bool
	oldValue              func(context.Context) (*HPAmebloPost, error)
	predicates            []predicate.HPAmebloPost
}

var _ ent.Mutation = (*HPAmebloPostMutation)(nil)

// hpameblopostOption allows management of the mutation configuration using functional options.
type hpameblopostOption func(*HPAmebloPostMutation)

// newHPAmebloPostMutation creates new mutation for the HPAmebloPost entity.
func newHPAmebloPostMutation(c config, op Op, opts ...hpameblopostOption) *HPAmebloPostMutation {
	m := &HPAmebloPostMutation{
		config:        c,
		op:            op,
		typ:           TypeHPAmebloPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPAmebloPostID sets the ID field of the mutation.
func withHPAmebloPostID(id int) hpameblopostOption {
	return func(m *HPAmebloPostMutation) {
		var (
			err   error
			once  sync.Once
			value *HPAmebloPost
		)
		m.oldValue = func(ctx context.Context) (*HPAmebloPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPAmebloPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPAmebloPost sets the old HPAmebloPost of the mutation.
func withHPAmebloPost(node *HPAmebloPost) hpameblopostOption {
	return func(m *HPAmebloPostMutation) {
		m.oldValue = func(context.Context) (*HPAmebloPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPAmebloPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPAmebloPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPAmebloPostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPAmebloPostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPAmebloPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCrawledAt sets the "crawled_at" field.
func (m *HPAmebloPostMutation) SetCrawledAt(t time.Time) {
	m.crawled_at = &t
}

// CrawledAt returns the value of the "crawled_at" field in the mutation.
func (m *HPAmebloPostMutation) CrawledAt() (r time.Time, exists bool) {
	v := m.crawled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCrawledAt returns the old "crawled_at" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldCrawledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrawledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrawledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrawledAt: %w", err)
	}
	return oldValue.CrawledAt, nil
}

// ClearCrawledAt clears the value of the "crawled_at" field.
func (m *HPAmebloPostMutation) ClearCrawledAt() {
	m.crawled_at = nil
	m.clearedFields[hpameblopost.FieldCrawledAt] = struct{}{}
}

// CrawledAtCleared returns if the "crawled_at" field was cleared in this mutation.
func (m *HPAmebloPostMutation) CrawledAtCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldCrawledAt]
	return ok
}

// ResetCrawledAt resets all changes to the "crawled_at" field.
func (m *HPAmebloPostMutation) ResetCrawledAt() {
	m.crawled_at = nil
	delete(m.clearedFields, hpameblopost.FieldCrawledAt)
}

// SetErrorCount sets the "error_count" field.
func (m *HPAmebloPostMutation) SetErrorCount(i int) {
	m.error_count = &i
	m.adderror_count = nil
}

// ErrorCount returns the value of the "error_count" field in the mutation.
func (m *HPAmebloPostMutation) ErrorCount() (r int, exists bool) {
	v := m.error_count
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCount returns the old "error_count" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldErrorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCount: %w", err)
	}
	return oldValue.ErrorCount, nil
}

// AddErrorCount adds i to the "error_count" field.
func (m *HPAmebloPostMutation) AddErrorCount(i int) {
	if m.adderror_count != nil {
		*m.adderror_count += i
	} else {
		m.adderror_count = &i
	}
}

// AddedErrorCount returns the value that was added to the "error_count" field in this mutation.
func (m *HPAmebloPostMutation) AddedErrorCount() (r int, exists bool) {
	v := m.adderror_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrorCount resets all changes to the "error_count" field.
func (m *HPAmebloPostMutation) ResetErrorCount() {
	m.error_count = nil
	m.adderror_count = nil
}

// SetManuallyModified sets the "manually_modified" field.
func (m *HPAmebloPostMutation) SetManuallyModified(jm *jsonfields.ManuallyModified) {
	m.manually_modified = &jm
}

// ManuallyModified returns the value of the "manually_modified" field in the mutation.
func (m *HPAmebloPostMutation) ManuallyModified() (r *jsonfields.ManuallyModified, exists bool) {
	v := m.manually_modified
	if v == nil {
		return
	}
	return *v, true
}

// OldManuallyModified returns the old "manually_modified" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldManuallyModified(ctx context.Context) (v *jsonfields.ManuallyModified, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManuallyModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManuallyModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManuallyModified: %w", err)
	}
	return oldValue.ManuallyModified, nil
}

// ClearManuallyModified clears the value of the "manually_modified" field.
func (m *HPAmebloPostMutation) ClearManuallyModified() {
	m.manually_modified = nil
	m.clearedFields[hpameblopost.FieldManuallyModified] = struct{}{}
}

// ManuallyModifiedCleared returns if the "manually_modified" field was cleared in this mutation.
func (m *HPAmebloPostMutation) ManuallyModifiedCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldManuallyModified]
	return ok
}

// ResetManuallyModified resets all changes to the "manually_modified" field.
func (m *HPAmebloPostMutation) ResetManuallyModified() {
	m.manually_modified = nil
	delete(m.clearedFields, hpameblopost.FieldManuallyModified)
}

// SetLastErrorMessage sets the "last_error_message" field.
func (m *HPAmebloPostMutation) SetLastErrorMessage(s string) {
	m.last_error_message = &s
}

// LastErrorMessage returns the value of the "last_error_message" field in the mutation.
func (m *HPAmebloPostMutation) LastErrorMessage() (r string, exists bool) {
	v := m.last_error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLastErrorMessage returns the old "last_error_message" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldLastErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastErrorMessage: %w", err)
	}
	return oldValue.LastErrorMessage, nil
}

// ClearLastErrorMessage clears the value of the "last_error_message" field.
func (m *HPAmebloPostMutation) ClearLastErrorMessage() {
	m.last_error_message = nil
	m.clearedFields[hpameblopost.FieldLastErrorMessage] = struct{}{}
}

// LastErrorMessageCleared returns if the "last_error_message" field was cleared in this mutation.
func (m *HPAmebloPostMutation) LastErrorMessageCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldLastErrorMessage]
	return ok
}

// ResetLastErrorMessage resets all changes to the "last_error_message" field.
func (m *HPAmebloPostMutation) ResetLastErrorMessage() {
	m.last_error_message = nil
	delete(m.clearedFields, hpameblopost.FieldLastErrorMessage)
}

// SetRecrawlRequired sets the "recrawl_required" field.
func (m *HPAmebloPostMutation) SetRecrawlRequired(b bool) {
	m.recrawl_required = &b
}

// RecrawlRequired returns the value of the "recrawl_required" field in the mutation.
func (m *HPAmebloPostMutation) RecrawlRequired() (r bool, exists bool) {
	v := m.recrawl_required
	if v == nil {
		return
	}
	return *v, true
}

// OldRecrawlRequired returns the old "recrawl_required" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldRecrawlRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecrawlRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecrawlRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecrawlRequired: %w", err)
	}
	return oldValue.RecrawlRequired, nil
}

// ClearRecrawlRequired clears the value of the "recrawl_required" field.
func (m *HPAmebloPostMutation) ClearRecrawlRequired() {
	m.recrawl_required = nil
	m.clearedFields[hpameblopost.FieldRecrawlRequired] = struct{}{}
}

// RecrawlRequiredCleared returns if the "recrawl_required" field was cleared in this mutation.
func (m *HPAmebloPostMutation) RecrawlRequiredCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldRecrawlRequired]
	return ok
}

// ResetRecrawlRequired resets all changes to the "recrawl_required" field.
func (m *HPAmebloPostMutation) ResetRecrawlRequired() {
	m.recrawl_required = nil
	delete(m.clearedFields, hpameblopost.FieldRecrawlRequired)
}

// SetCreatedAt sets the "created_at" field.
func (m *HPAmebloPostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPAmebloPostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPAmebloPostMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpameblopost.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPAmebloPostMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPAmebloPostMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpameblopost.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPAmebloPostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPAmebloPostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPAmebloPostMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpameblopost.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPAmebloPostMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPAmebloPostMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpameblopost.FieldUpdatedAt)
}

// SetPath sets the "path" field.
func (m *HPAmebloPostMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *HPAmebloPostMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *HPAmebloPostMutation) ResetPath() {
	m._path = nil
}

// SetNextPath sets the "next_path" field.
func (m *HPAmebloPostMutation) SetNextPath(s string) {
	m.next_path = &s
}

// NextPath returns the value of the "next_path" field in the mutation.
func (m *HPAmebloPostMutation) NextPath() (r string, exists bool) {
	v := m.next_path
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPath returns the old "next_path" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldNextPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPath: %w", err)
	}
	return oldValue.NextPath, nil
}

// ClearNextPath clears the value of the "next_path" field.
func (m *HPAmebloPostMutation) ClearNextPath() {
	m.next_path = nil
	m.clearedFields[hpameblopost.FieldNextPath] = struct{}{}
}

// NextPathCleared returns if the "next_path" field was cleared in this mutation.
func (m *HPAmebloPostMutation) NextPathCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldNextPath]
	return ok
}

// ResetNextPath resets all changes to the "next_path" field.
func (m *HPAmebloPostMutation) ResetNextPath() {
	m.next_path = nil
	delete(m.clearedFields, hpameblopost.FieldNextPath)
}

// SetPrevPath sets the "prev_path" field.
func (m *HPAmebloPostMutation) SetPrevPath(s string) {
	m.prev_path = &s
}

// PrevPath returns the value of the "prev_path" field in the mutation.
func (m *HPAmebloPostMutation) PrevPath() (r string, exists bool) {
	v := m.prev_path
	if v == nil {
		return
	}
	return *v, true
}

// OldPrevPath returns the old "prev_path" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldPrevPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrevPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrevPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrevPath: %w", err)
	}
	return oldValue.PrevPath, nil
}

// ClearPrevPath clears the value of the "prev_path" field.
func (m *HPAmebloPostMutation) ClearPrevPath() {
	m.prev_path = nil
	m.clearedFields[hpameblopost.FieldPrevPath] = struct{}{}
}

// PrevPathCleared returns if the "prev_path" field was cleared in this mutation.
func (m *HPAmebloPostMutation) PrevPathCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldPrevPath]
	return ok
}

// ResetPrevPath resets all changes to the "prev_path" field.
func (m *HPAmebloPostMutation) ResetPrevPath() {
	m.prev_path = nil
	delete(m.clearedFields, hpameblopost.FieldPrevPath)
}

// SetArtistKey sets the "artist_key" field.
func (m *HPAmebloPostMutation) SetArtistKey(s string) {
	m.artist_key = &s
}

// ArtistKey returns the value of the "artist_key" field in the mutation.
func (m *HPAmebloPostMutation) ArtistKey() (r string, exists bool) {
	v := m.artist_key
	if v == nil {
		return
	}
	return *v, true
}

// OldArtistKey returns the old "artist_key" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldArtistKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtistKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtistKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtistKey: %w", err)
	}
	return oldValue.ArtistKey, nil
}

// ClearArtistKey clears the value of the "artist_key" field.
func (m *HPAmebloPostMutation) ClearArtistKey() {
	m.artist_key = nil
	m.clearedFields[hpameblopost.FieldArtistKey] = struct{}{}
}

// ArtistKeyCleared returns if the "artist_key" field was cleared in this mutation.
func (m *HPAmebloPostMutation) ArtistKeyCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldArtistKey]
	return ok
}

// ResetArtistKey resets all changes to the "artist_key" field.
func (m *HPAmebloPostMutation) ResetArtistKey() {
	m.artist_key = nil
	delete(m.clearedFields, hpameblopost.FieldArtistKey)
}

// SetMemberKey sets the "member_key" field.
func (m *HPAmebloPostMutation) SetMemberKey(s string) {
	m.member_key = &s
}

// MemberKey returns the value of the "member_key" field in the mutation.
func (m *HPAmebloPostMutation) MemberKey() (r string, exists bool) {
	v := m.member_key
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberKey returns the old "member_key" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldMemberKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberKey: %w", err)
	}
	return oldValue.MemberKey, nil
}

// ClearMemberKey clears the value of the "member_key" field.
func (m *HPAmebloPostMutation) ClearMemberKey() {
	m.member_key = nil
	m.clearedFields[hpameblopost.FieldMemberKey] = struct{}{}
}

// MemberKeyCleared returns if the "member_key" field was cleared in this mutation.
func (m *HPAmebloPostMutation) MemberKeyCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldMemberKey]
	return ok
}

// ResetMemberKey resets all changes to the "member_key" field.
func (m *HPAmebloPostMutation) ResetMemberKey() {
	m.member_key = nil
	delete(m.clearedFields, hpameblopost.FieldMemberKey)
}

// SetTitle sets the "title" field.
func (m *HPAmebloPostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *HPAmebloPostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *HPAmebloPostMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *HPAmebloPostMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HPAmebloPostMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HPAmebloPostMutation) ResetDescription() {
	m.description = nil
}

// SetTheme sets the "theme" field.
func (m *HPAmebloPostMutation) SetTheme(s string) {
	m.theme = &s
}

// Theme returns the value of the "theme" field in the mutation.
func (m *HPAmebloPostMutation) Theme() (r string, exists bool) {
	v := m.theme
	if v == nil {
		return
	}
	return *v, true
}

// OldTheme returns the old "theme" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldTheme(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTheme: %w", err)
	}
	return oldValue.Theme, nil
}

// ClearTheme clears the value of the "theme" field.
func (m *HPAmebloPostMutation) ClearTheme() {
	m.theme = nil
	m.clearedFields[hpameblopost.FieldTheme] = struct{}{}
}

// ThemeCleared returns if the "theme" field was cleared in this mutation.
func (m *HPAmebloPostMutation) ThemeCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldTheme]
	return ok
}

// ResetTheme resets all changes to the "theme" field.
func (m *HPAmebloPostMutation) ResetTheme() {
	m.theme = nil
	delete(m.clearedFields, hpameblopost.FieldTheme)
}

// SetPostAt sets the "post_at" field.
func (m *HPAmebloPostMutation) SetPostAt(t time.Time) {
	m.post_at = &t
}

// PostAt returns the value of the "post_at" field in the mutation.
func (m *HPAmebloPostMutation) PostAt() (r time.Time, exists bool) {
	v := m.post_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPostAt returns the old "post_at" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldPostAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostAt: %w", err)
	}
	return oldValue.PostAt, nil
}

// ResetPostAt resets all changes to the "post_at" field.
func (m *HPAmebloPostMutation) ResetPostAt() {
	m.post_at = nil
}

// SetSource sets the "source" field.
func (m *HPAmebloPostMutation) SetSource(h hpameblopost.Source) {
	m.source = &h
}

// Source returns the value of the "source" field in the mutation.
func (m *HPAmebloPostMutation) Source() (r hpameblopost.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldSource(ctx context.Context) (v hpameblopost.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *HPAmebloPostMutation) ResetSource() {
	m.source = nil
}

// SetImages sets the "images" field.
func (m *HPAmebloPostMutation) SetImages(j []jsonfields.Media) {
	m.images = &j
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *HPAmebloPostMutation) Images() (r []jsonfields.Media, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldImages(ctx context.Context) (v []jsonfields.Media, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds j to the "images" field.
func (m *HPAmebloPostMutation) AppendImages(j []jsonfields.Media) {
	m.appendimages = append(m.appendimages, j...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *HPAmebloPostMutation) AppendedImages() ([]jsonfields.Media, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *HPAmebloPostMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[hpameblopost.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *HPAmebloPostMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *HPAmebloPostMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, hpameblopost.FieldImages)
}

// SetLikes sets the "likes" field.
func (m *HPAmebloPostMutation) SetLikes(i int) {
	m.likes = &i
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *HPAmebloPostMutation) Likes() (r int, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldLikes(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds i to the "likes" field.
func (m *HPAmebloPostMutation) AddLikes(i int) {
	if m.addlikes != nil {
		*m.addlikes += i
	} else {
		m.addlikes = &i
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *HPAmebloPostMutation) AddedLikes() (r int, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ClearLikes clears the value of the "likes" field.
func (m *HPAmebloPostMutation) ClearLikes() {
	m.likes = nil
	m.addlikes = nil
	m.clearedFields[hpameblopost.FieldLikes] = struct{}{}
}

// LikesCleared returns if the "likes" field was cleared in this mutation.
func (m *HPAmebloPostMutation) LikesCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldLikes]
	return ok
}

// ResetLikes resets all changes to the "likes" field.
func (m *HPAmebloPostMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
	delete(m.clearedFields, hpameblopost.FieldLikes)
}

// SetComments sets the "comments" field.
func (m *HPAmebloPostMutation) SetComments(i int) {
	m.comments = &i
	m.addcomments = nil
}

// Comments returns the value of the "comments" field in the mutation.
func (m *HPAmebloPostMutation) Comments() (r int, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldComments(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// AddComments adds i to the "comments" field.
func (m *HPAmebloPostMutation) AddComments(i int) {
	if m.addcomments != nil {
		*m.addcomments += i
	} else {
		m.addcomments = &i
	}
}

// AddedComments returns the value that was added to the "comments" field in this mutation.
func (m *HPAmebloPostMutation) AddedComments() (r int, exists bool) {
	v := m.addcomments
	if v == nil {
		return
	}
	return *v, true
}

// ClearComments clears the value of the "comments" field.
func (m *HPAmebloPostMutation) ClearComments() {
	m.comments = nil
	m.addcomments = nil
	m.clearedFields[hpameblopost.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *HPAmebloPostMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *HPAmebloPostMutation) ResetComments() {
	m.comments = nil
	m.addcomments = nil
	delete(m.clearedFields, hpameblopost.FieldComments)
}

// SetReblogs sets the "reblogs" field.
func (m *HPAmebloPostMutation) SetReblogs(i int) {
	m.reblogs = &i
	m.addreblogs = nil
}

// Reblogs returns the value of the "reblogs" field in the mutation.
func (m *HPAmebloPostMutation) Reblogs() (r int, exists bool) {
	v := m.reblogs
	if v == nil {
		return
	}
	return *v, true
}

// OldReblogs returns the old "reblogs" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldReblogs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReblogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReblogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReblogs: %w", err)
	}
	return oldValue.Reblogs, nil
}

// AddReblogs adds i to the "reblogs" field.
func (m *HPAmebloPostMutation) AddReblogs(i int) {
	if m.addreblogs != nil {
		*m.addreblogs += i
	} else {
		m.addreblogs = &i
	}
}

// AddedReblogs returns the value that was added to the "reblogs" field in this mutation.
func (m *HPAmebloPostMutation) AddedReblogs() (r int, exists bool) {
	v := m.addreblogs
	if v == nil {
		return
	}
	return *v, true
}

// ClearReblogs clears the value of the "reblogs" field.
func (m *HPAmebloPostMutation) ClearReblogs() {
	m.reblogs = nil
	m.addreblogs = nil
	m.clearedFields[hpameblopost.FieldReblogs] = struct{}{}
}

// ReblogsCleared returns if the "reblogs" field was cleared in this mutation.
func (m *HPAmebloPostMutation) ReblogsCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldReblogs]
	return ok
}

// ResetReblogs resets all changes to the "reblogs" field.
func (m *HPAmebloPostMutation) ResetReblogs() {
	m.reblogs = nil
	m.addreblogs = nil
	delete(m.clearedFields, hpameblopost.FieldReblogs)
}

// SetOwnerArtistID sets the "owner_artist_id" field.
func (m *HPAmebloPostMutation) SetOwnerArtistID(i int) {
	m.owner_artist = &i
}

// OwnerArtistID returns the value of the "owner_artist_id" field in the mutation.
func (m *HPAmebloPostMutation) OwnerArtistID() (r int, exists bool) {
	v := m.owner_artist
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerArtistID returns the old "owner_artist_id" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldOwnerArtistID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerArtistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerArtistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerArtistID: %w", err)
	}
	return oldValue.OwnerArtistID, nil
}

// ClearOwnerArtistID clears the value of the "owner_artist_id" field.
func (m *HPAmebloPostMutation) ClearOwnerArtistID() {
	m.owner_artist = nil
	m.clearedFields[hpameblopost.FieldOwnerArtistID] = struct{}{}
}

// OwnerArtistIDCleared returns if the "owner_artist_id" field was cleared in this mutation.
func (m *HPAmebloPostMutation) OwnerArtistIDCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldOwnerArtistID]
	return ok
}

// ResetOwnerArtistID resets all changes to the "owner_artist_id" field.
func (m *HPAmebloPostMutation) ResetOwnerArtistID() {
	m.owner_artist = nil
	delete(m.clearedFields, hpameblopost.FieldOwnerArtistID)
}

// SetOwnerMemberID sets the "owner_member_id" field.
func (m *HPAmebloPostMutation) SetOwnerMemberID(i int) {
	m.owner_member = &i
}

// OwnerMemberID returns the value of the "owner_member_id" field in the mutation.
func (m *HPAmebloPostMutation) OwnerMemberID() (r int, exists bool) {
	v := m.owner_member
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerMemberID returns the old "owner_member_id" field's value of the HPAmebloPost entity.
// If the HPAmebloPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAmebloPostMutation) OldOwnerMemberID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerMemberID: %w", err)
	}
	return oldValue.OwnerMemberID, nil
}

// ClearOwnerMemberID clears the value of the "owner_member_id" field.
func (m *HPAmebloPostMutation) ClearOwnerMemberID() {
	m.owner_member = nil
	m.clearedFields[hpameblopost.FieldOwnerMemberID] = struct{}{}
}

// OwnerMemberIDCleared returns if the "owner_member_id" field was cleared in this mutation.
func (m *HPAmebloPostMutation) OwnerMemberIDCleared() bool {
	_, ok := m.clearedFields[hpameblopost.FieldOwnerMemberID]
	return ok
}

// ResetOwnerMemberID resets all changes to the "owner_member_id" field.
func (m *HPAmebloPostMutation) ResetOwnerMemberID() {
	m.owner_member = nil
	delete(m.clearedFields, hpameblopost.FieldOwnerMemberID)
}

// ClearOwnerArtist clears the "owner_artist" edge to the HPArtist entity.
func (m *HPAmebloPostMutation) ClearOwnerArtist() {
	m.clearedowner_artist = true
}

// OwnerArtistCleared reports if the "owner_artist" edge to the HPArtist entity was cleared.
func (m *HPAmebloPostMutation) OwnerArtistCleared() bool {
	return m.OwnerArtistIDCleared() || m.clearedowner_artist
}

// OwnerArtistIDs returns the "owner_artist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerArtistID instead. It exists only for internal usage by the builders.
func (m *HPAmebloPostMutation) OwnerArtistIDs() (ids []int) {
	if id := m.owner_artist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerArtist resets all changes to the "owner_artist" edge.
func (m *HPAmebloPostMutation) ResetOwnerArtist() {
	m.owner_artist = nil
	m.clearedowner_artist = false
}

// ClearOwnerMember clears the "owner_member" edge to the HPMember entity.
func (m *HPAmebloPostMutation) ClearOwnerMember() {
	m.clearedowner_member = true
}

// OwnerMemberCleared reports if the "owner_member" edge to the HPMember entity was cleared.
func (m *HPAmebloPostMutation) OwnerMemberCleared() bool {
	return m.OwnerMemberIDCleared() || m.clearedowner_member
}

// OwnerMemberIDs returns the "owner_member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerMemberID instead. It exists only for internal usage by the builders.
func (m *HPAmebloPostMutation) OwnerMemberIDs() (ids []int) {
	if id := m.owner_member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerMember resets all changes to the "owner_member" edge.
func (m *HPAmebloPostMutation) ResetOwnerMember() {
	m.owner_member = nil
	m.clearedowner_member = false
}

// AddTaggedArtistIDs adds the "tagged_artists" edge to the HPArtist entity by ids.
func (m *HPAmebloPostMutation) AddTaggedArtistIDs(ids ...int) {
	if m.tagged_artists == nil {
		m.tagged_artists = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_artists[ids[i]] = struct{}{}
	}
}

// ClearTaggedArtists clears the "tagged_artists" edge to the HPArtist entity.
func (m *HPAmebloPostMutation) ClearTaggedArtists() {
	m.clearedtagged_artists = true
}

// TaggedArtistsCleared reports if the "tagged_artists" edge to the HPArtist entity was cleared.
func (m *HPAmebloPostMutation) TaggedArtistsCleared() bool {
	return m.clearedtagged_artists
}

// RemoveTaggedArtistIDs removes the "tagged_artists" edge to the HPArtist entity by IDs.
func (m *HPAmebloPostMutation) RemoveTaggedArtistIDs(ids ...int) {
	if m.removedtagged_artists == nil {
		m.removedtagged_artists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_artists, ids[i])
		m.removedtagged_artists[ids[i]] = struct{}{}
	}
}

// RemovedTaggedArtists returns the removed IDs of the "tagged_artists" edge to the HPArtist entity.
func (m *HPAmebloPostMutation) RemovedTaggedArtistsIDs() (ids []int) {
	for id := range m.removedtagged_artists {
		ids = append(ids, id)
	}
	return
}

// TaggedArtistsIDs returns the "tagged_artists" edge IDs in the mutation.
func (m *HPAmebloPostMutation) TaggedArtistsIDs() (ids []int) {
	for id := range m.tagged_artists {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedArtists resets all changes to the "tagged_artists" edge.
func (m *HPAmebloPostMutation) ResetTaggedArtists() {
	m.tagged_artists = nil
	m.clearedtagged_artists = false
	m.removedtagged_artists = nil
}

// AddTaggedMemberIDs adds the "tagged_members" edge to the HPMember entity by ids.
func (m *HPAmebloPostMutation) AddTaggedMemberIDs(ids ...int) {
	if m.tagged_members == nil {
		m.tagged_members = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_members[ids[i]] = struct{}{}
	}
}

// ClearTaggedMembers clears the "tagged_members" edge to the HPMember entity.
func (m *HPAmebloPostMutation) ClearTaggedMembers() {
	m.clearedtagged_members = true
}

// TaggedMembersCleared reports if the "tagged_members" edge to the HPMember entity was cleared.
func (m *HPAmebloPostMutation) TaggedMembersCleared() bool {
	return m.clearedtagged_members
}

// RemoveTaggedMemberIDs removes the "tagged_members" edge to the HPMember entity by IDs.
func (m *HPAmebloPostMutation) RemoveTaggedMemberIDs(ids ...int) {
	if m.removedtagged_members == nil {
		m.removedtagged_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_members, ids[i])
		m.removedtagged_members[ids[i]] = struct{}{}
	}
}

// RemovedTaggedMembers returns the removed IDs of the "tagged_members" edge to the HPMember entity.
func (m *HPAmebloPostMutation) RemovedTaggedMembersIDs() (ids []int) {
	for id := range m.removedtagged_members {
		ids = append(ids, id)
	}
	return
}

// TaggedMembersIDs returns the "tagged_members" edge IDs in the mutation.
func (m *HPAmebloPostMutation) TaggedMembersIDs() (ids []int) {
	for id := range m.tagged_members {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedMembers resets all changes to the "tagged_members" edge.
func (m *HPAmebloPostMutation) ResetTaggedMembers() {
	m.tagged_members = nil
	m.clearedtagged_members = false
	m.removedtagged_members = nil
}

// SetAssetID sets the "asset" edge to the HPAsset entity by id.
func (m *HPAmebloPostMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the HPAsset entity.
func (m *HPAmebloPostMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the HPAsset entity was cleared.
func (m *HPAmebloPostMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *HPAmebloPostMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *HPAmebloPostMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *HPAmebloPostMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddBlobIDs adds the "blobs" edge to the HPBlob entity by ids.
func (m *HPAmebloPostMutation) AddBlobIDs(ids ...int) {
	if m.blobs == nil {
		m.blobs = make(map[int]struct{})
	}
	for i := range ids {
		m.blobs[ids[i]] = struct{}{}
	}
}

// ClearBlobs clears the "blobs" edge to the HPBlob entity.
func (m *HPAmebloPostMutation) ClearBlobs() {
	m.clearedblobs = true
}

// BlobsCleared reports if the "blobs" edge to the HPBlob entity was cleared.
func (m *HPAmebloPostMutation) BlobsCleared() bool {
	return m.clearedblobs
}

// RemoveBlobIDs removes the "blobs" edge to the HPBlob entity by IDs.
func (m *HPAmebloPostMutation) RemoveBlobIDs(ids ...int) {
	if m.removedblobs == nil {
		m.removedblobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blobs, ids[i])
		m.removedblobs[ids[i]] = struct{}{}
	}
}

// RemovedBlobs returns the removed IDs of the "blobs" edge to the HPBlob entity.
func (m *HPAmebloPostMutation) RemovedBlobsIDs() (ids []int) {
	for id := range m.removedblobs {
		ids = append(ids, id)
	}
	return
}

// BlobsIDs returns the "blobs" edge IDs in the mutation.
func (m *HPAmebloPostMutation) BlobsIDs() (ids []int) {
	for id := range m.blobs {
		ids = append(ids, id)
	}
	return
}

// ResetBlobs resets all changes to the "blobs" edge.
func (m *HPAmebloPostMutation) ResetBlobs() {
	m.blobs = nil
	m.clearedblobs = false
	m.removedblobs = nil
}

// Where appends a list predicates to the HPAmebloPostMutation builder.
func (m *HPAmebloPostMutation) Where(ps ...predicate.HPAmebloPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPAmebloPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPAmebloPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPAmebloPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPAmebloPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPAmebloPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPAmebloPost).
func (m *HPAmebloPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPAmebloPostMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.crawled_at != nil {
		fields = append(fields, hpameblopost.FieldCrawledAt)
	}
	if m.error_count != nil {
		fields = append(fields, hpameblopost.FieldErrorCount)
	}
	if m.manually_modified != nil {
		fields = append(fields, hpameblopost.FieldManuallyModified)
	}
	if m.last_error_message != nil {
		fields = append(fields, hpameblopost.FieldLastErrorMessage)
	}
	if m.recrawl_required != nil {
		fields = append(fields, hpameblopost.FieldRecrawlRequired)
	}
	if m.created_at != nil {
		fields = append(fields, hpameblopost.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpameblopost.FieldUpdatedAt)
	}
	if m._path != nil {
		fields = append(fields, hpameblopost.FieldPath)
	}
	if m.next_path != nil {
		fields = append(fields, hpameblopost.FieldNextPath)
	}
	if m.prev_path != nil {
		fields = append(fields, hpameblopost.FieldPrevPath)
	}
	if m.artist_key != nil {
		fields = append(fields, hpameblopost.FieldArtistKey)
	}
	if m.member_key != nil {
		fields = append(fields, hpameblopost.FieldMemberKey)
	}
	if m.title != nil {
		fields = append(fields, hpameblopost.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, hpameblopost.FieldDescription)
	}
	if m.theme != nil {
		fields = append(fields, hpameblopost.FieldTheme)
	}
	if m.post_at != nil {
		fields = append(fields, hpameblopost.FieldPostAt)
	}
	if m.source != nil {
		fields = append(fields, hpameblopost.FieldSource)
	}
	if m.images != nil {
		fields = append(fields, hpameblopost.FieldImages)
	}
	if m.likes != nil {
		fields = append(fields, hpameblopost.FieldLikes)
	}
	if m.comments != nil {
		fields = append(fields, hpameblopost.FieldComments)
	}
	if m.reblogs != nil {
		fields = append(fields, hpameblopost.FieldReblogs)
	}
	if m.owner_artist != nil {
		fields = append(fields, hpameblopost.FieldOwnerArtistID)
	}
	if m.owner_member != nil {
		fields = append(fields, hpameblopost.FieldOwnerMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPAmebloPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpameblopost.FieldCrawledAt:
		return m.CrawledAt()
	case hpameblopost.FieldErrorCount:
		return m.ErrorCount()
	case hpameblopost.FieldManuallyModified:
		return m.ManuallyModified()
	case hpameblopost.FieldLastErrorMessage:
		return m.LastErrorMessage()
	case hpameblopost.FieldRecrawlRequired:
		return m.RecrawlRequired()
	case hpameblopost.FieldCreatedAt:
		return m.CreatedAt()
	case hpameblopost.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpameblopost.FieldPath:
		return m.Path()
	case hpameblopost.FieldNextPath:
		return m.NextPath()
	case hpameblopost.FieldPrevPath:
		return m.PrevPath()
	case hpameblopost.FieldArtistKey:
		return m.ArtistKey()
	case hpameblopost.FieldMemberKey:
		return m.MemberKey()
	case hpameblopost.FieldTitle:
		return m.Title()
	case hpameblopost.FieldDescription:
		return m.Description()
	case hpameblopost.FieldTheme:
		return m.Theme()
	case hpameblopost.FieldPostAt:
		return m.PostAt()
	case hpameblopost.FieldSource:
		return m.Source()
	case hpameblopost.FieldImages:
		return m.Images()
	case hpameblopost.FieldLikes:
		return m.Likes()
	case hpameblopost.FieldComments:
		return m.Comments()
	case hpameblopost.FieldReblogs:
		return m.Reblogs()
	case hpameblopost.FieldOwnerArtistID:
		return m.OwnerArtistID()
	case hpameblopost.FieldOwnerMemberID:
		return m.OwnerMemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPAmebloPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpameblopost.FieldCrawledAt:
		return m.OldCrawledAt(ctx)
	case hpameblopost.FieldErrorCount:
		return m.OldErrorCount(ctx)
	case hpameblopost.FieldManuallyModified:
		return m.OldManuallyModified(ctx)
	case hpameblopost.FieldLastErrorMessage:
		return m.OldLastErrorMessage(ctx)
	case hpameblopost.FieldRecrawlRequired:
		return m.OldRecrawlRequired(ctx)
	case hpameblopost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpameblopost.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpameblopost.FieldPath:
		return m.OldPath(ctx)
	case hpameblopost.FieldNextPath:
		return m.OldNextPath(ctx)
	case hpameblopost.FieldPrevPath:
		return m.OldPrevPath(ctx)
	case hpameblopost.FieldArtistKey:
		return m.OldArtistKey(ctx)
	case hpameblopost.FieldMemberKey:
		return m.OldMemberKey(ctx)
	case hpameblopost.FieldTitle:
		return m.OldTitle(ctx)
	case hpameblopost.FieldDescription:
		return m.OldDescription(ctx)
	case hpameblopost.FieldTheme:
		return m.OldTheme(ctx)
	case hpameblopost.FieldPostAt:
		return m.OldPostAt(ctx)
	case hpameblopost.FieldSource:
		return m.OldSource(ctx)
	case hpameblopost.FieldImages:
		return m.OldImages(ctx)
	case hpameblopost.FieldLikes:
		return m.OldLikes(ctx)
	case hpameblopost.FieldComments:
		return m.OldComments(ctx)
	case hpameblopost.FieldReblogs:
		return m.OldReblogs(ctx)
	case hpameblopost.FieldOwnerArtistID:
		return m.OldOwnerArtistID(ctx)
	case hpameblopost.FieldOwnerMemberID:
		return m.OldOwnerMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown HPAmebloPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPAmebloPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpameblopost.FieldCrawledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrawledAt(v)
		return nil
	case hpameblopost.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCount(v)
		return nil
	case hpameblopost.FieldManuallyModified:
		v, ok := value.(*jsonfields.ManuallyModified)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManuallyModified(v)
		return nil
	case hpameblopost.FieldLastErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastErrorMessage(v)
		return nil
	case hpameblopost.FieldRecrawlRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecrawlRequired(v)
		return nil
	case hpameblopost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpameblopost.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpameblopost.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case hpameblopost.FieldNextPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPath(v)
		return nil
	case hpameblopost.FieldPrevPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrevPath(v)
		return nil
	case hpameblopost.FieldArtistKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtistKey(v)
		return nil
	case hpameblopost.FieldMemberKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberKey(v)
		return nil
	case hpameblopost.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case hpameblopost.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hpameblopost.FieldTheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTheme(v)
		return nil
	case hpameblopost.FieldPostAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostAt(v)
		return nil
	case hpameblopost.FieldSource:
		v, ok := value.(hpameblopost.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case hpameblopost.FieldImages:
		v, ok := value.([]jsonfields.Media)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case hpameblopost.FieldLikes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case hpameblopost.FieldComments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case hpameblopost.FieldReblogs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReblogs(v)
		return nil
	case hpameblopost.FieldOwnerArtistID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerArtistID(v)
		return nil
	case hpameblopost.FieldOwnerMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown HPAmebloPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPAmebloPostMutation) AddedFields() []string {
	var fields []string
	if m.adderror_count != nil {
		fields = append(fields, hpameblopost.FieldErrorCount)
	}
	if m.addlikes != nil {
		fields = append(fields, hpameblopost.FieldLikes)
	}
	if m.addcomments != nil {
		fields = append(fields, hpameblopost.FieldComments)
	}
	if m.addreblogs != nil {
		fields = append(fields, hpameblopost.FieldReblogs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPAmebloPostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpameblopost.FieldErrorCount:
		return m.AddedErrorCount()
	case hpameblopost.FieldLikes:
		return m.AddedLikes()
	case hpameblopost.FieldComments:
		return m.AddedComments()
	case hpameblopost.FieldReblogs:
		return m.AddedReblogs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPAmebloPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpameblopost.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCount(v)
		return nil
	case hpameblopost.FieldLikes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	case hpameblopost.FieldComments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddComments(v)
		return nil
	case hpameblopost.FieldReblogs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReblogs(v)
		return nil
	}
	return fmt.Errorf("unknown HPAmebloPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPAmebloPostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpameblopost.FieldCrawledAt) {
		fields = append(fields, hpameblopost.FieldCrawledAt)
	}
	if m.FieldCleared(hpameblopost.FieldManuallyModified) {
		fields = append(fields, hpameblopost.FieldManuallyModified)
	}
	if m.FieldCleared(hpameblopost.FieldLastErrorMessage) {
		fields = append(fields, hpameblopost.FieldLastErrorMessage)
	}
	if m.FieldCleared(hpameblopost.FieldRecrawlRequired) {
		fields = append(fields, hpameblopost.FieldRecrawlRequired)
	}
	if m.FieldCleared(hpameblopost.FieldCreatedAt) {
		fields = append(fields, hpameblopost.FieldCreatedAt)
	}
	if m.FieldCleared(hpameblopost.FieldUpdatedAt) {
		fields = append(fields, hpameblopost.FieldUpdatedAt)
	}
	if m.FieldCleared(hpameblopost.FieldNextPath) {
		fields = append(fields, hpameblopost.FieldNextPath)
	}
	if m.FieldCleared(hpameblopost.FieldPrevPath) {
		fields = append(fields, hpameblopost.FieldPrevPath)
	}
	if m.FieldCleared(hpameblopost.FieldArtistKey) {
		fields = append(fields, hpameblopost.FieldArtistKey)
	}
	if m.FieldCleared(hpameblopost.FieldMemberKey) {
		fields = append(fields, hpameblopost.FieldMemberKey)
	}
	if m.FieldCleared(hpameblopost.FieldTheme) {
		fields = append(fields, hpameblopost.FieldTheme)
	}
	if m.FieldCleared(hpameblopost.FieldImages) {
		fields = append(fields, hpameblopost.FieldImages)
	}
	if m.FieldCleared(hpameblopost.FieldLikes) {
		fields = append(fields, hpameblopost.FieldLikes)
	}
	if m.FieldCleared(hpameblopost.FieldComments) {
		fields = append(fields, hpameblopost.FieldComments)
	}
	if m.FieldCleared(hpameblopost.FieldReblogs) {
		fields = append(fields, hpameblopost.FieldReblogs)
	}
	if m.FieldCleared(hpameblopost.FieldOwnerArtistID) {
		fields = append(fields, hpameblopost.FieldOwnerArtistID)
	}
	if m.FieldCleared(hpameblopost.FieldOwnerMemberID) {
		fields = append(fields, hpameblopost.FieldOwnerMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPAmebloPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPAmebloPostMutation) ClearField(name string) error {
	switch name {
	case hpameblopost.FieldCrawledAt:
		m.ClearCrawledAt()
		return nil
	case hpameblopost.FieldManuallyModified:
		m.ClearManuallyModified()
		return nil
	case hpameblopost.FieldLastErrorMessage:
		m.ClearLastErrorMessage()
		return nil
	case hpameblopost.FieldRecrawlRequired:
		m.ClearRecrawlRequired()
		return nil
	case hpameblopost.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpameblopost.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpameblopost.FieldNextPath:
		m.ClearNextPath()
		return nil
	case hpameblopost.FieldPrevPath:
		m.ClearPrevPath()
		return nil
	case hpameblopost.FieldArtistKey:
		m.ClearArtistKey()
		return nil
	case hpameblopost.FieldMemberKey:
		m.ClearMemberKey()
		return nil
	case hpameblopost.FieldTheme:
		m.ClearTheme()
		return nil
	case hpameblopost.FieldImages:
		m.ClearImages()
		return nil
	case hpameblopost.FieldLikes:
		m.ClearLikes()
		return nil
	case hpameblopost.FieldComments:
		m.ClearComments()
		return nil
	case hpameblopost.FieldReblogs:
		m.ClearReblogs()
		return nil
	case hpameblopost.FieldOwnerArtistID:
		m.ClearOwnerArtistID()
		return nil
	case hpameblopost.FieldOwnerMemberID:
		m.ClearOwnerMemberID()
		return nil
	}
	return fmt.Errorf("unknown HPAmebloPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPAmebloPostMutation) ResetField(name string) error {
	switch name {
	case hpameblopost.FieldCrawledAt:
		m.ResetCrawledAt()
		return nil
	case hpameblopost.FieldErrorCount:
		m.ResetErrorCount()
		return nil
	case hpameblopost.FieldManuallyModified:
		m.ResetManuallyModified()
		return nil
	case hpameblopost.FieldLastErrorMessage:
		m.ResetLastErrorMessage()
		return nil
	case hpameblopost.FieldRecrawlRequired:
		m.ResetRecrawlRequired()
		return nil
	case hpameblopost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpameblopost.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpameblopost.FieldPath:
		m.ResetPath()
		return nil
	case hpameblopost.FieldNextPath:
		m.ResetNextPath()
		return nil
	case hpameblopost.FieldPrevPath:
		m.ResetPrevPath()
		return nil
	case hpameblopost.FieldArtistKey:
		m.ResetArtistKey()
		return nil
	case hpameblopost.FieldMemberKey:
		m.ResetMemberKey()
		return nil
	case hpameblopost.FieldTitle:
		m.ResetTitle()
		return nil
	case hpameblopost.FieldDescription:
		m.ResetDescription()
		return nil
	case hpameblopost.FieldTheme:
		m.ResetTheme()
		return nil
	case hpameblopost.FieldPostAt:
		m.ResetPostAt()
		return nil
	case hpameblopost.FieldSource:
		m.ResetSource()
		return nil
	case hpameblopost.FieldImages:
		m.ResetImages()
		return nil
	case hpameblopost.FieldLikes:
		m.ResetLikes()
		return nil
	case hpameblopost.FieldComments:
		m.ResetComments()
		return nil
	case hpameblopost.FieldReblogs:
		m.ResetReblogs()
		return nil
	case hpameblopost.FieldOwnerArtistID:
		m.ResetOwnerArtistID()
		return nil
	case hpameblopost.FieldOwnerMemberID:
		m.ResetOwnerMemberID()
		return nil
	}
	return fmt.Errorf("unknown HPAmebloPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPAmebloPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.owner_artist != nil {
		edges = append(edges, hpameblopost.EdgeOwnerArtist)
	}
	if m.owner_member != nil {
		edges = append(edges, hpameblopost.EdgeOwnerMember)
	}
	if m.tagged_artists != nil {
		edges = append(edges, hpameblopost.EdgeTaggedArtists)
	}
	if m.tagged_members != nil {
		edges = append(edges, hpameblopost.EdgeTaggedMembers)
	}
	if m.asset != nil {
		edges = append(edges, hpameblopost.EdgeAsset)
	}
	if m.blobs != nil {
		edges = append(edges, hpameblopost.EdgeBlobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPAmebloPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpameblopost.EdgeOwnerArtist:
		if id := m.owner_artist; id != nil {
			return []ent.Value{*id}
		}
	case hpameblopost.EdgeOwnerMember:
		if id := m.owner_member; id != nil {
			return []ent.Value{*id}
		}
	case hpameblopost.EdgeTaggedArtists:
		ids := make([]ent.Value, 0, len(m.tagged_artists))
		for id := range m.tagged_artists {
			ids = append(ids, id)
		}
		return ids
	case hpameblopost.EdgeTaggedMembers:
		ids := make([]ent.Value, 0, len(m.tagged_members))
		for id := range m.tagged_members {
			ids = append(ids, id)
		}
		return ids
	case hpameblopost.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case hpameblopost.EdgeBlobs:
		ids := make([]ent.Value, 0, len(m.blobs))
		for id := range m.blobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPAmebloPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtagged_artists != nil {
		edges = append(edges, hpameblopost.EdgeTaggedArtists)
	}
	if m.removedtagged_members != nil {
		edges = append(edges, hpameblopost.EdgeTaggedMembers)
	}
	if m.removedblobs != nil {
		edges = append(edges, hpameblopost.EdgeBlobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPAmebloPostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpameblopost.EdgeTaggedArtists:
		ids := make([]ent.Value, 0, len(m.removedtagged_artists))
		for id := range m.removedtagged_artists {
			ids = append(ids, id)
		}
		return ids
	case hpameblopost.EdgeTaggedMembers:
		ids := make([]ent.Value, 0, len(m.removedtagged_members))
		for id := range m.removedtagged_members {
			ids = append(ids, id)
		}
		return ids
	case hpameblopost.EdgeBlobs:
		ids := make([]ent.Value, 0, len(m.removedblobs))
		for id := range m.removedblobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPAmebloPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedowner_artist {
		edges = append(edges, hpameblopost.EdgeOwnerArtist)
	}
	if m.clearedowner_member {
		edges = append(edges, hpameblopost.EdgeOwnerMember)
	}
	if m.clearedtagged_artists {
		edges = append(edges, hpameblopost.EdgeTaggedArtists)
	}
	if m.clearedtagged_members {
		edges = append(edges, hpameblopost.EdgeTaggedMembers)
	}
	if m.clearedasset {
		edges = append(edges, hpameblopost.EdgeAsset)
	}
	if m.clearedblobs {
		edges = append(edges, hpameblopost.EdgeBlobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPAmebloPostMutation) EdgeCleared(name string) bool {
	switch name {
	case hpameblopost.EdgeOwnerArtist:
		return m.clearedowner_artist
	case hpameblopost.EdgeOwnerMember:
		return m.clearedowner_member
	case hpameblopost.EdgeTaggedArtists:
		return m.clearedtagged_artists
	case hpameblopost.EdgeTaggedMembers:
		return m.clearedtagged_members
	case hpameblopost.EdgeAsset:
		return m.clearedasset
	case hpameblopost.EdgeBlobs:
		return m.clearedblobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPAmebloPostMutation) ClearEdge(name string) error {
	switch name {
	case hpameblopost.EdgeOwnerArtist:
		m.ClearOwnerArtist()
		return nil
	case hpameblopost.EdgeOwnerMember:
		m.ClearOwnerMember()
		return nil
	case hpameblopost.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown HPAmebloPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPAmebloPostMutation) ResetEdge(name string) error {
	switch name {
	case hpameblopost.EdgeOwnerArtist:
		m.ResetOwnerArtist()
		return nil
	case hpameblopost.EdgeOwnerMember:
		m.ResetOwnerMember()
		return nil
	case hpameblopost.EdgeTaggedArtists:
		m.ResetTaggedArtists()
		return nil
	case hpameblopost.EdgeTaggedMembers:
		m.ResetTaggedMembers()
		return nil
	case hpameblopost.EdgeAsset:
		m.ResetAsset()
		return nil
	case hpameblopost.EdgeBlobs:
		m.ResetBlobs()
		return nil
	}
	return fmt.Errorf("unknown HPAmebloPost edge %s", name)
}

// HPArtistMutation represents an operation that mutates the HPArtist nodes in the graph.
type HPArtistMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	crawled_at                       *time.Time
	error_count                      *int
	adderror_count                   *int
	manually_modified                **jsonfields.ManuallyModified
	last_error_message               *string
	recrawl_required                 *bool
	created_at                       *time.Time
	updated_at                       *time.Time
	key                              *string
	name                             *string
	thumbnail_url                    *string
	index                            *int
	addindex                         *int
	clearedFields                    map[string]struct{}
	members                          map[int]struct{}
	removedmembers                   map[int]struct{}
	clearedmembers                   bool
	assets                           map[int]struct{}
	removedassets                    map[int]struct{}
	clearedassets                    bool
	owning_feed                      map[int]struct{}
	removedowning_feed               map[int]struct{}
	clearedowning_feed               bool
	tagged_feed                      map[int]struct{}
	removedtagged_feed               map[int]struct{}
	clearedtagged_feed               bool
	owning_ig_posts                  map[int]struct{}
	removedowning_ig_posts           map[int]struct{}
	clearedowning_ig_posts           bool
	tagged_ig_posts                  map[int]struct{}
	removedtagged_ig_posts           map[int]struct{}
	clearedtagged_ig_posts           bool
	owning_ameblo_posts              map[int]struct{}
	removedowning_ameblo_posts       map[int]struct{}
	clearedowning_ameblo_posts       bool
	tagged_ameblo_posts              map[int]struct{}
	removedtagged_ameblo_posts       map[int]struct{}
	clearedtagged_ameblo_posts       bool
	tagged_elineup_mall_items        map[int]struct{}
	removedtagged_elineup_mall_items map[int]struct{}
	clearedtagged_elineup_mall_items bool
	followed_by                      map[int]struct{}
	removedfollowed_by               map[int]struct{}
	clearedfollowed_by               bool
	done                             bool
	oldValue                         func(context.Context) (*HPArtist, error)
	predicates                       []predicate.HPArtist
}

var _ ent.Mutation = (*HPArtistMutation)(nil)

// hpartistOption allows management of the mutation configuration using functional options.
type hpartistOption func(*HPArtistMutation)

// newHPArtistMutation creates new mutation for the HPArtist entity.
func newHPArtistMutation(c config, op Op, opts ...hpartistOption) *HPArtistMutation {
	m := &HPArtistMutation{
		config:        c,
		op:            op,
		typ:           TypeHPArtist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPArtistID sets the ID field of the mutation.
func withHPArtistID(id int) hpartistOption {
	return func(m *HPArtistMutation) {
		var (
			err   error
			once  sync.Once
			value *HPArtist
		)
		m.oldValue = func(ctx context.Context) (*HPArtist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPArtist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPArtist sets the old HPArtist of the mutation.
func withHPArtist(node *HPArtist) hpartistOption {
	return func(m *HPArtistMutation) {
		m.oldValue = func(context.Context) (*HPArtist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPArtistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPArtistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPArtistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPArtistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPArtist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCrawledAt sets the "crawled_at" field.
func (m *HPArtistMutation) SetCrawledAt(t time.Time) {
	m.crawled_at = &t
}

// CrawledAt returns the value of the "crawled_at" field in the mutation.
func (m *HPArtistMutation) CrawledAt() (r time.Time, exists bool) {
	v := m.crawled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCrawledAt returns the old "crawled_at" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldCrawledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrawledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrawledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrawledAt: %w", err)
	}
	return oldValue.CrawledAt, nil
}

// ClearCrawledAt clears the value of the "crawled_at" field.
func (m *HPArtistMutation) ClearCrawledAt() {
	m.crawled_at = nil
	m.clearedFields[hpartist.FieldCrawledAt] = struct{}{}
}

// CrawledAtCleared returns if the "crawled_at" field was cleared in this mutation.
func (m *HPArtistMutation) CrawledAtCleared() bool {
	_, ok := m.clearedFields[hpartist.FieldCrawledAt]
	return ok
}

// ResetCrawledAt resets all changes to the "crawled_at" field.
func (m *HPArtistMutation) ResetCrawledAt() {
	m.crawled_at = nil
	delete(m.clearedFields, hpartist.FieldCrawledAt)
}

// SetErrorCount sets the "error_count" field.
func (m *HPArtistMutation) SetErrorCount(i int) {
	m.error_count = &i
	m.adderror_count = nil
}

// ErrorCount returns the value of the "error_count" field in the mutation.
func (m *HPArtistMutation) ErrorCount() (r int, exists bool) {
	v := m.error_count
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCount returns the old "error_count" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldErrorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCount: %w", err)
	}
	return oldValue.ErrorCount, nil
}

// AddErrorCount adds i to the "error_count" field.
func (m *HPArtistMutation) AddErrorCount(i int) {
	if m.adderror_count != nil {
		*m.adderror_count += i
	} else {
		m.adderror_count = &i
	}
}

// AddedErrorCount returns the value that was added to the "error_count" field in this mutation.
func (m *HPArtistMutation) AddedErrorCount() (r int, exists bool) {
	v := m.adderror_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrorCount resets all changes to the "error_count" field.
func (m *HPArtistMutation) ResetErrorCount() {
	m.error_count = nil
	m.adderror_count = nil
}

// SetManuallyModified sets the "manually_modified" field.
func (m *HPArtistMutation) SetManuallyModified(jm *jsonfields.ManuallyModified) {
	m.manually_modified = &jm
}

// ManuallyModified returns the value of the "manually_modified" field in the mutation.
func (m *HPArtistMutation) ManuallyModified() (r *jsonfields.ManuallyModified, exists bool) {
	v := m.manually_modified
	if v == nil {
		return
	}
	return *v, true
}

// OldManuallyModified returns the old "manually_modified" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldManuallyModified(ctx context.Context) (v *jsonfields.ManuallyModified, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManuallyModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManuallyModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManuallyModified: %w", err)
	}
	return oldValue.ManuallyModified, nil
}

// ClearManuallyModified clears the value of the "manually_modified" field.
func (m *HPArtistMutation) ClearManuallyModified() {
	m.manually_modified = nil
	m.clearedFields[hpartist.FieldManuallyModified] = struct{}{}
}

// ManuallyModifiedCleared returns if the "manually_modified" field was cleared in this mutation.
func (m *HPArtistMutation) ManuallyModifiedCleared() bool {
	_, ok := m.clearedFields[hpartist.FieldManuallyModified]
	return ok
}

// ResetManuallyModified resets all changes to the "manually_modified" field.
func (m *HPArtistMutation) ResetManuallyModified() {
	m.manually_modified = nil
	delete(m.clearedFields, hpartist.FieldManuallyModified)
}

// SetLastErrorMessage sets the "last_error_message" field.
func (m *HPArtistMutation) SetLastErrorMessage(s string) {
	m.last_error_message = &s
}

// LastErrorMessage returns the value of the "last_error_message" field in the mutation.
func (m *HPArtistMutation) LastErrorMessage() (r string, exists bool) {
	v := m.last_error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLastErrorMessage returns the old "last_error_message" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldLastErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastErrorMessage: %w", err)
	}
	return oldValue.LastErrorMessage, nil
}

// ClearLastErrorMessage clears the value of the "last_error_message" field.
func (m *HPArtistMutation) ClearLastErrorMessage() {
	m.last_error_message = nil
	m.clearedFields[hpartist.FieldLastErrorMessage] = struct{}{}
}

// LastErrorMessageCleared returns if the "last_error_message" field was cleared in this mutation.
func (m *HPArtistMutation) LastErrorMessageCleared() bool {
	_, ok := m.clearedFields[hpartist.FieldLastErrorMessage]
	return ok
}

// ResetLastErrorMessage resets all changes to the "last_error_message" field.
func (m *HPArtistMutation) ResetLastErrorMessage() {
	m.last_error_message = nil
	delete(m.clearedFields, hpartist.FieldLastErrorMessage)
}

// SetRecrawlRequired sets the "recrawl_required" field.
func (m *HPArtistMutation) SetRecrawlRequired(b bool) {
	m.recrawl_required = &b
}

// RecrawlRequired returns the value of the "recrawl_required" field in the mutation.
func (m *HPArtistMutation) RecrawlRequired() (r bool, exists bool) {
	v := m.recrawl_required
	if v == nil {
		return
	}
	return *v, true
}

// OldRecrawlRequired returns the old "recrawl_required" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldRecrawlRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecrawlRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecrawlRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecrawlRequired: %w", err)
	}
	return oldValue.RecrawlRequired, nil
}

// ClearRecrawlRequired clears the value of the "recrawl_required" field.
func (m *HPArtistMutation) ClearRecrawlRequired() {
	m.recrawl_required = nil
	m.clearedFields[hpartist.FieldRecrawlRequired] = struct{}{}
}

// RecrawlRequiredCleared returns if the "recrawl_required" field was cleared in this mutation.
func (m *HPArtistMutation) RecrawlRequiredCleared() bool {
	_, ok := m.clearedFields[hpartist.FieldRecrawlRequired]
	return ok
}

// ResetRecrawlRequired resets all changes to the "recrawl_required" field.
func (m *HPArtistMutation) ResetRecrawlRequired() {
	m.recrawl_required = nil
	delete(m.clearedFields, hpartist.FieldRecrawlRequired)
}

// SetCreatedAt sets the "created_at" field.
func (m *HPArtistMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPArtistMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPArtistMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpartist.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPArtistMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpartist.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPArtistMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpartist.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPArtistMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPArtistMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPArtistMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpartist.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPArtistMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpartist.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPArtistMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpartist.FieldUpdatedAt)
}

// SetKey sets the "key" field.
func (m *HPArtistMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *HPArtistMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *HPArtistMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *HPArtistMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HPArtistMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HPArtistMutation) ResetName() {
	m.name = nil
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *HPArtistMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *HPArtistMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *HPArtistMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
}

// SetIndex sets the "index" field.
func (m *HPArtistMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *HPArtistMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the HPArtist entity.
// If the HPArtist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPArtistMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *HPArtistMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *HPArtistMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *HPArtistMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// AddMemberIDs adds the "members" edge to the HPMember entity by ids.
func (m *HPArtistMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the HPMember entity.
func (m *HPArtistMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the HPMember entity was cleared.
func (m *HPArtistMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the HPMember entity by IDs.
func (m *HPArtistMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the HPMember entity.
func (m *HPArtistMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *HPArtistMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *HPArtistMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddAssetIDs adds the "assets" edge to the HPAsset entity by ids.
func (m *HPArtistMutation) AddAssetIDs(ids ...int) {
	if m.assets == nil {
		m.assets = make(map[int]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the HPAsset entity.
func (m *HPArtistMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the HPAsset entity was cleared.
func (m *HPArtistMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the HPAsset entity by IDs.
func (m *HPArtistMutation) RemoveAssetIDs(ids ...int) {
	if m.removedassets == nil {
		m.removedassets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the HPAsset entity.
func (m *HPArtistMutation) RemovedAssetsIDs() (ids []int) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *HPArtistMutation) AssetsIDs() (ids []int) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *HPArtistMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddOwningFeedIDs adds the "owning_feed" edge to the HPFeedItem entity by ids.
func (m *HPArtistMutation) AddOwningFeedIDs(ids ...int) {
	if m.owning_feed == nil {
		m.owning_feed = make(map[int]struct{})
	}
	for i := range ids {
		m.owning_feed[ids[i]] = struct{}{}
	}
}

// ClearOwningFeed clears the "owning_feed" edge to the HPFeedItem entity.
func (m *HPArtistMutation) ClearOwningFeed() {
	m.clearedowning_feed = true
}

// OwningFeedCleared reports if the "owning_feed" edge to the HPFeedItem entity was cleared.
func (m *HPArtistMutation) OwningFeedCleared() bool {
	return m.clearedowning_feed
}

// RemoveOwningFeedIDs removes the "owning_feed" edge to the HPFeedItem entity by IDs.
func (m *HPArtistMutation) RemoveOwningFeedIDs(ids ...int) {
	if m.removedowning_feed == nil {
		m.removedowning_feed = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owning_feed, ids[i])
		m.removedowning_feed[ids[i]] = struct{}{}
	}
}

// RemovedOwningFeed returns the removed IDs of the "owning_feed" edge to the HPFeedItem entity.
func (m *HPArtistMutation) RemovedOwningFeedIDs() (ids []int) {
	for id := range m.removedowning_feed {
		ids = append(ids, id)
	}
	return
}

// OwningFeedIDs returns the "owning_feed" edge IDs in the mutation.
func (m *HPArtistMutation) OwningFeedIDs() (ids []int) {
	for id := range m.owning_feed {
		ids = append(ids, id)
	}
	return
}

// ResetOwningFeed resets all changes to the "owning_feed" edge.
func (m *HPArtistMutation) ResetOwningFeed() {
	m.owning_feed = nil
	m.clearedowning_feed = false
	m.removedowning_feed = nil
}

// AddTaggedFeedIDs adds the "tagged_feed" edge to the HPFeedItem entity by ids.
func (m *HPArtistMutation) AddTaggedFeedIDs(ids ...int) {
	if m.tagged_feed == nil {
		m.tagged_feed = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_feed[ids[i]] = struct{}{}
	}
}

// ClearTaggedFeed clears the "tagged_feed" edge to the HPFeedItem entity.
func (m *HPArtistMutation) ClearTaggedFeed() {
	m.clearedtagged_feed = true
}

// TaggedFeedCleared reports if the "tagged_feed" edge to the HPFeedItem entity was cleared.
func (m *HPArtistMutation) TaggedFeedCleared() bool {
	return m.clearedtagged_feed
}

// RemoveTaggedFeedIDs removes the "tagged_feed" edge to the HPFeedItem entity by IDs.
func (m *HPArtistMutation) RemoveTaggedFeedIDs(ids ...int) {
	if m.removedtagged_feed == nil {
		m.removedtagged_feed = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_feed, ids[i])
		m.removedtagged_feed[ids[i]] = struct{}{}
	}
}

// RemovedTaggedFeed returns the removed IDs of the "tagged_feed" edge to the HPFeedItem entity.
func (m *HPArtistMutation) RemovedTaggedFeedIDs() (ids []int) {
	for id := range m.removedtagged_feed {
		ids = append(ids, id)
	}
	return
}

// TaggedFeedIDs returns the "tagged_feed" edge IDs in the mutation.
func (m *HPArtistMutation) TaggedFeedIDs() (ids []int) {
	for id := range m.tagged_feed {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedFeed resets all changes to the "tagged_feed" edge.
func (m *HPArtistMutation) ResetTaggedFeed() {
	m.tagged_feed = nil
	m.clearedtagged_feed = false
	m.removedtagged_feed = nil
}

// AddOwningIgPostIDs adds the "owning_ig_posts" edge to the HPIgPost entity by ids.
func (m *HPArtistMutation) AddOwningIgPostIDs(ids ...int) {
	if m.owning_ig_posts == nil {
		m.owning_ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.owning_ig_posts[ids[i]] = struct{}{}
	}
}

// ClearOwningIgPosts clears the "owning_ig_posts" edge to the HPIgPost entity.
func (m *HPArtistMutation) ClearOwningIgPosts() {
	m.clearedowning_ig_posts = true
}

// OwningIgPostsCleared reports if the "owning_ig_posts" edge to the HPIgPost entity was cleared.
func (m *HPArtistMutation) OwningIgPostsCleared() bool {
	return m.clearedowning_ig_posts
}

// RemoveOwningIgPostIDs removes the "owning_ig_posts" edge to the HPIgPost entity by IDs.
func (m *HPArtistMutation) RemoveOwningIgPostIDs(ids ...int) {
	if m.removedowning_ig_posts == nil {
		m.removedowning_ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owning_ig_posts, ids[i])
		m.removedowning_ig_posts[ids[i]] = struct{}{}
	}
}

// RemovedOwningIgPosts returns the removed IDs of the "owning_ig_posts" edge to the HPIgPost entity.
func (m *HPArtistMutation) RemovedOwningIgPostsIDs() (ids []int) {
	for id := range m.removedowning_ig_posts {
		ids = append(ids, id)
	}
	return
}

// OwningIgPostsIDs returns the "owning_ig_posts" edge IDs in the mutation.
func (m *HPArtistMutation) OwningIgPostsIDs() (ids []int) {
	for id := range m.owning_ig_posts {
		ids = append(ids, id)
	}
	return
}

// ResetOwningIgPosts resets all changes to the "owning_ig_posts" edge.
func (m *HPArtistMutation) ResetOwningIgPosts() {
	m.owning_ig_posts = nil
	m.clearedowning_ig_posts = false
	m.removedowning_ig_posts = nil
}

// AddTaggedIgPostIDs adds the "tagged_ig_posts" edge to the HPIgPost entity by ids.
func (m *HPArtistMutation) AddTaggedIgPostIDs(ids ...int) {
	if m.tagged_ig_posts == nil {
		m.tagged_ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_ig_posts[ids[i]] = struct{}{}
	}
}

// ClearTaggedIgPosts clears the "tagged_ig_posts" edge to the HPIgPost entity.
func (m *HPArtistMutation) ClearTaggedIgPosts() {
	m.clearedtagged_ig_posts = true
}

// TaggedIgPostsCleared reports if the "tagged_ig_posts" edge to the HPIgPost entity was cleared.
func (m *HPArtistMutation) TaggedIgPostsCleared() bool {
	return m.clearedtagged_ig_posts
}

// RemoveTaggedIgPostIDs removes the "tagged_ig_posts" edge to the HPIgPost entity by IDs.
func (m *HPArtistMutation) RemoveTaggedIgPostIDs(ids ...int) {
	if m.removedtagged_ig_posts == nil {
		m.removedtagged_ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_ig_posts, ids[i])
		m.removedtagged_ig_posts[ids[i]] = struct{}{}
	}
}

// RemovedTaggedIgPosts returns the removed IDs of the "tagged_ig_posts" edge to the HPIgPost entity.
func (m *HPArtistMutation) RemovedTaggedIgPostsIDs() (ids []int) {
	for id := range m.removedtagged_ig_posts {
		ids = append(ids, id)
	}
	return
}

// TaggedIgPostsIDs returns the "tagged_ig_posts" edge IDs in the mutation.
func (m *HPArtistMutation) TaggedIgPostsIDs() (ids []int) {
	for id := range m.tagged_ig_posts {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedIgPosts resets all changes to the "tagged_ig_posts" edge.
func (m *HPArtistMutation) ResetTaggedIgPosts() {
	m.tagged_ig_posts = nil
	m.clearedtagged_ig_posts = false
	m.removedtagged_ig_posts = nil
}

// AddOwningAmebloPostIDs adds the "owning_ameblo_posts" edge to the HPAmebloPost entity by ids.
func (m *HPArtistMutation) AddOwningAmebloPostIDs(ids ...int) {
	if m.owning_ameblo_posts == nil {
		m.owning_ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.owning_ameblo_posts[ids[i]] = struct{}{}
	}
}

// ClearOwningAmebloPosts clears the "owning_ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPArtistMutation) ClearOwningAmebloPosts() {
	m.clearedowning_ameblo_posts = true
}

// OwningAmebloPostsCleared reports if the "owning_ameblo_posts" edge to the HPAmebloPost entity was cleared.
func (m *HPArtistMutation) OwningAmebloPostsCleared() bool {
	return m.clearedowning_ameblo_posts
}

// RemoveOwningAmebloPostIDs removes the "owning_ameblo_posts" edge to the HPAmebloPost entity by IDs.
func (m *HPArtistMutation) RemoveOwningAmebloPostIDs(ids ...int) {
	if m.removedowning_ameblo_posts == nil {
		m.removedowning_ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owning_ameblo_posts, ids[i])
		m.removedowning_ameblo_posts[ids[i]] = struct{}{}
	}
}

// RemovedOwningAmebloPosts returns the removed IDs of the "owning_ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPArtistMutation) RemovedOwningAmebloPostsIDs() (ids []int) {
	for id := range m.removedowning_ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// OwningAmebloPostsIDs returns the "owning_ameblo_posts" edge IDs in the mutation.
func (m *HPArtistMutation) OwningAmebloPostsIDs() (ids []int) {
	for id := range m.owning_ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// ResetOwningAmebloPosts resets all changes to the "owning_ameblo_posts" edge.
func (m *HPArtistMutation) ResetOwningAmebloPosts() {
	m.owning_ameblo_posts = nil
	m.clearedowning_ameblo_posts = false
	m.removedowning_ameblo_posts = nil
}

// AddTaggedAmebloPostIDs adds the "tagged_ameblo_posts" edge to the HPAmebloPost entity by ids.
func (m *HPArtistMutation) AddTaggedAmebloPostIDs(ids ...int) {
	if m.tagged_ameblo_posts == nil {
		m.tagged_ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_ameblo_posts[ids[i]] = struct{}{}
	}
}

// ClearTaggedAmebloPosts clears the "tagged_ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPArtistMutation) ClearTaggedAmebloPosts() {
	m.clearedtagged_ameblo_posts = true
}

// TaggedAmebloPostsCleared reports if the "tagged_ameblo_posts" edge to the HPAmebloPost entity was cleared.
func (m *HPArtistMutation) TaggedAmebloPostsCleared() bool {
	return m.clearedtagged_ameblo_posts
}

// RemoveTaggedAmebloPostIDs removes the "tagged_ameblo_posts" edge to the HPAmebloPost entity by IDs.
func (m *HPArtistMutation) RemoveTaggedAmebloPostIDs(ids ...int) {
	if m.removedtagged_ameblo_posts == nil {
		m.removedtagged_ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_ameblo_posts, ids[i])
		m.removedtagged_ameblo_posts[ids[i]] = struct{}{}
	}
}

// RemovedTaggedAmebloPosts returns the removed IDs of the "tagged_ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPArtistMutation) RemovedTaggedAmebloPostsIDs() (ids []int) {
	for id := range m.removedtagged_ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// TaggedAmebloPostsIDs returns the "tagged_ameblo_posts" edge IDs in the mutation.
func (m *HPArtistMutation) TaggedAmebloPostsIDs() (ids []int) {
	for id := range m.tagged_ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedAmebloPosts resets all changes to the "tagged_ameblo_posts" edge.
func (m *HPArtistMutation) ResetTaggedAmebloPosts() {
	m.tagged_ameblo_posts = nil
	m.clearedtagged_ameblo_posts = false
	m.removedtagged_ameblo_posts = nil
}

// AddTaggedElineupMallItemIDs adds the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity by ids.
func (m *HPArtistMutation) AddTaggedElineupMallItemIDs(ids ...int) {
	if m.tagged_elineup_mall_items == nil {
		m.tagged_elineup_mall_items = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_elineup_mall_items[ids[i]] = struct{}{}
	}
}

// ClearTaggedElineupMallItems clears the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity.
func (m *HPArtistMutation) ClearTaggedElineupMallItems() {
	m.clearedtagged_elineup_mall_items = true
}

// TaggedElineupMallItemsCleared reports if the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity was cleared.
func (m *HPArtistMutation) TaggedElineupMallItemsCleared() bool {
	return m.clearedtagged_elineup_mall_items
}

// RemoveTaggedElineupMallItemIDs removes the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity by IDs.
func (m *HPArtistMutation) RemoveTaggedElineupMallItemIDs(ids ...int) {
	if m.removedtagged_elineup_mall_items == nil {
		m.removedtagged_elineup_mall_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_elineup_mall_items, ids[i])
		m.removedtagged_elineup_mall_items[ids[i]] = struct{}{}
	}
}

// RemovedTaggedElineupMallItems returns the removed IDs of the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity.
func (m *HPArtistMutation) RemovedTaggedElineupMallItemsIDs() (ids []int) {
	for id := range m.removedtagged_elineup_mall_items {
		ids = append(ids, id)
	}
	return
}

// TaggedElineupMallItemsIDs returns the "tagged_elineup_mall_items" edge IDs in the mutation.
func (m *HPArtistMutation) TaggedElineupMallItemsIDs() (ids []int) {
	for id := range m.tagged_elineup_mall_items {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedElineupMallItems resets all changes to the "tagged_elineup_mall_items" edge.
func (m *HPArtistMutation) ResetTaggedElineupMallItems() {
	m.tagged_elineup_mall_items = nil
	m.clearedtagged_elineup_mall_items = false
	m.removedtagged_elineup_mall_items = nil
}

// AddFollowedByIDs adds the "followed_by" edge to the HPFollow entity by ids.
func (m *HPArtistMutation) AddFollowedByIDs(ids ...int) {
	if m.followed_by == nil {
		m.followed_by = make(map[int]struct{})
	}
	for i := range ids {
		m.followed_by[ids[i]] = struct{}{}
	}
}

// ClearFollowedBy clears the "followed_by" edge to the HPFollow entity.
func (m *HPArtistMutation) ClearFollowedBy() {
	m.clearedfollowed_by = true
}

// FollowedByCleared reports if the "followed_by" edge to the HPFollow entity was cleared.
func (m *HPArtistMutation) FollowedByCleared() bool {
	return m.clearedfollowed_by
}

// RemoveFollowedByIDs removes the "followed_by" edge to the HPFollow entity by IDs.
func (m *HPArtistMutation) RemoveFollowedByIDs(ids ...int) {
	if m.removedfollowed_by == nil {
		m.removedfollowed_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.followed_by, ids[i])
		m.removedfollowed_by[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBy returns the removed IDs of the "followed_by" edge to the HPFollow entity.
func (m *HPArtistMutation) RemovedFollowedByIDs() (ids []int) {
	for id := range m.removedfollowed_by {
		ids = append(ids, id)
	}
	return
}

// FollowedByIDs returns the "followed_by" edge IDs in the mutation.
func (m *HPArtistMutation) FollowedByIDs() (ids []int) {
	for id := range m.followed_by {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBy resets all changes to the "followed_by" edge.
func (m *HPArtistMutation) ResetFollowedBy() {
	m.followed_by = nil
	m.clearedfollowed_by = false
	m.removedfollowed_by = nil
}

// Where appends a list predicates to the HPArtistMutation builder.
func (m *HPArtistMutation) Where(ps ...predicate.HPArtist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPArtistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPArtistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPArtist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPArtistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPArtistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPArtist).
func (m *HPArtistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPArtistMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.crawled_at != nil {
		fields = append(fields, hpartist.FieldCrawledAt)
	}
	if m.error_count != nil {
		fields = append(fields, hpartist.FieldErrorCount)
	}
	if m.manually_modified != nil {
		fields = append(fields, hpartist.FieldManuallyModified)
	}
	if m.last_error_message != nil {
		fields = append(fields, hpartist.FieldLastErrorMessage)
	}
	if m.recrawl_required != nil {
		fields = append(fields, hpartist.FieldRecrawlRequired)
	}
	if m.created_at != nil {
		fields = append(fields, hpartist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpartist.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, hpartist.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, hpartist.FieldName)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, hpartist.FieldThumbnailURL)
	}
	if m.index != nil {
		fields = append(fields, hpartist.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPArtistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpartist.FieldCrawledAt:
		return m.CrawledAt()
	case hpartist.FieldErrorCount:
		return m.ErrorCount()
	case hpartist.FieldManuallyModified:
		return m.ManuallyModified()
	case hpartist.FieldLastErrorMessage:
		return m.LastErrorMessage()
	case hpartist.FieldRecrawlRequired:
		return m.RecrawlRequired()
	case hpartist.FieldCreatedAt:
		return m.CreatedAt()
	case hpartist.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpartist.FieldKey:
		return m.Key()
	case hpartist.FieldName:
		return m.Name()
	case hpartist.FieldThumbnailURL:
		return m.ThumbnailURL()
	case hpartist.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPArtistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpartist.FieldCrawledAt:
		return m.OldCrawledAt(ctx)
	case hpartist.FieldErrorCount:
		return m.OldErrorCount(ctx)
	case hpartist.FieldManuallyModified:
		return m.OldManuallyModified(ctx)
	case hpartist.FieldLastErrorMessage:
		return m.OldLastErrorMessage(ctx)
	case hpartist.FieldRecrawlRequired:
		return m.OldRecrawlRequired(ctx)
	case hpartist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpartist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpartist.FieldKey:
		return m.OldKey(ctx)
	case hpartist.FieldName:
		return m.OldName(ctx)
	case hpartist.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case hpartist.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown HPArtist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPArtistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpartist.FieldCrawledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrawledAt(v)
		return nil
	case hpartist.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCount(v)
		return nil
	case hpartist.FieldManuallyModified:
		v, ok := value.(*jsonfields.ManuallyModified)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManuallyModified(v)
		return nil
	case hpartist.FieldLastErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastErrorMessage(v)
		return nil
	case hpartist.FieldRecrawlRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecrawlRequired(v)
		return nil
	case hpartist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpartist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpartist.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case hpartist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hpartist.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case hpartist.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown HPArtist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPArtistMutation) AddedFields() []string {
	var fields []string
	if m.adderror_count != nil {
		fields = append(fields, hpartist.FieldErrorCount)
	}
	if m.addindex != nil {
		fields = append(fields, hpartist.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPArtistMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpartist.FieldErrorCount:
		return m.AddedErrorCount()
	case hpartist.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPArtistMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpartist.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCount(v)
		return nil
	case hpartist.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown HPArtist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPArtistMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpartist.FieldCrawledAt) {
		fields = append(fields, hpartist.FieldCrawledAt)
	}
	if m.FieldCleared(hpartist.FieldManuallyModified) {
		fields = append(fields, hpartist.FieldManuallyModified)
	}
	if m.FieldCleared(hpartist.FieldLastErrorMessage) {
		fields = append(fields, hpartist.FieldLastErrorMessage)
	}
	if m.FieldCleared(hpartist.FieldRecrawlRequired) {
		fields = append(fields, hpartist.FieldRecrawlRequired)
	}
	if m.FieldCleared(hpartist.FieldCreatedAt) {
		fields = append(fields, hpartist.FieldCreatedAt)
	}
	if m.FieldCleared(hpartist.FieldUpdatedAt) {
		fields = append(fields, hpartist.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPArtistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPArtistMutation) ClearField(name string) error {
	switch name {
	case hpartist.FieldCrawledAt:
		m.ClearCrawledAt()
		return nil
	case hpartist.FieldManuallyModified:
		m.ClearManuallyModified()
		return nil
	case hpartist.FieldLastErrorMessage:
		m.ClearLastErrorMessage()
		return nil
	case hpartist.FieldRecrawlRequired:
		m.ClearRecrawlRequired()
		return nil
	case hpartist.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpartist.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown HPArtist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPArtistMutation) ResetField(name string) error {
	switch name {
	case hpartist.FieldCrawledAt:
		m.ResetCrawledAt()
		return nil
	case hpartist.FieldErrorCount:
		m.ResetErrorCount()
		return nil
	case hpartist.FieldManuallyModified:
		m.ResetManuallyModified()
		return nil
	case hpartist.FieldLastErrorMessage:
		m.ResetLastErrorMessage()
		return nil
	case hpartist.FieldRecrawlRequired:
		m.ResetRecrawlRequired()
		return nil
	case hpartist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpartist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpartist.FieldKey:
		m.ResetKey()
		return nil
	case hpartist.FieldName:
		m.ResetName()
		return nil
	case hpartist.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case hpartist.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown HPArtist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPArtistMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.members != nil {
		edges = append(edges, hpartist.EdgeMembers)
	}
	if m.assets != nil {
		edges = append(edges, hpartist.EdgeAssets)
	}
	if m.owning_feed != nil {
		edges = append(edges, hpartist.EdgeOwningFeed)
	}
	if m.tagged_feed != nil {
		edges = append(edges, hpartist.EdgeTaggedFeed)
	}
	if m.owning_ig_posts != nil {
		edges = append(edges, hpartist.EdgeOwningIgPosts)
	}
	if m.tagged_ig_posts != nil {
		edges = append(edges, hpartist.EdgeTaggedIgPosts)
	}
	if m.owning_ameblo_posts != nil {
		edges = append(edges, hpartist.EdgeOwningAmebloPosts)
	}
	if m.tagged_ameblo_posts != nil {
		edges = append(edges, hpartist.EdgeTaggedAmebloPosts)
	}
	if m.tagged_elineup_mall_items != nil {
		edges = append(edges, hpartist.EdgeTaggedElineupMallItems)
	}
	if m.followed_by != nil {
		edges = append(edges, hpartist.EdgeFollowedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPArtistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpartist.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeOwningFeed:
		ids := make([]ent.Value, 0, len(m.owning_feed))
		for id := range m.owning_feed {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeTaggedFeed:
		ids := make([]ent.Value, 0, len(m.tagged_feed))
		for id := range m.tagged_feed {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeOwningIgPosts:
		ids := make([]ent.Value, 0, len(m.owning_ig_posts))
		for id := range m.owning_ig_posts {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeTaggedIgPosts:
		ids := make([]ent.Value, 0, len(m.tagged_ig_posts))
		for id := range m.tagged_ig_posts {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeOwningAmebloPosts:
		ids := make([]ent.Value, 0, len(m.owning_ameblo_posts))
		for id := range m.owning_ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeTaggedAmebloPosts:
		ids := make([]ent.Value, 0, len(m.tagged_ameblo_posts))
		for id := range m.tagged_ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeTaggedElineupMallItems:
		ids := make([]ent.Value, 0, len(m.tagged_elineup_mall_items))
		for id := range m.tagged_elineup_mall_items {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.followed_by))
		for id := range m.followed_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPArtistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedmembers != nil {
		edges = append(edges, hpartist.EdgeMembers)
	}
	if m.removedassets != nil {
		edges = append(edges, hpartist.EdgeAssets)
	}
	if m.removedowning_feed != nil {
		edges = append(edges, hpartist.EdgeOwningFeed)
	}
	if m.removedtagged_feed != nil {
		edges = append(edges, hpartist.EdgeTaggedFeed)
	}
	if m.removedowning_ig_posts != nil {
		edges = append(edges, hpartist.EdgeOwningIgPosts)
	}
	if m.removedtagged_ig_posts != nil {
		edges = append(edges, hpartist.EdgeTaggedIgPosts)
	}
	if m.removedowning_ameblo_posts != nil {
		edges = append(edges, hpartist.EdgeOwningAmebloPosts)
	}
	if m.removedtagged_ameblo_posts != nil {
		edges = append(edges, hpartist.EdgeTaggedAmebloPosts)
	}
	if m.removedtagged_elineup_mall_items != nil {
		edges = append(edges, hpartist.EdgeTaggedElineupMallItems)
	}
	if m.removedfollowed_by != nil {
		edges = append(edges, hpartist.EdgeFollowedBy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPArtistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpartist.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeOwningFeed:
		ids := make([]ent.Value, 0, len(m.removedowning_feed))
		for id := range m.removedowning_feed {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeTaggedFeed:
		ids := make([]ent.Value, 0, len(m.removedtagged_feed))
		for id := range m.removedtagged_feed {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeOwningIgPosts:
		ids := make([]ent.Value, 0, len(m.removedowning_ig_posts))
		for id := range m.removedowning_ig_posts {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeTaggedIgPosts:
		ids := make([]ent.Value, 0, len(m.removedtagged_ig_posts))
		for id := range m.removedtagged_ig_posts {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeOwningAmebloPosts:
		ids := make([]ent.Value, 0, len(m.removedowning_ameblo_posts))
		for id := range m.removedowning_ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeTaggedAmebloPosts:
		ids := make([]ent.Value, 0, len(m.removedtagged_ameblo_posts))
		for id := range m.removedtagged_ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeTaggedElineupMallItems:
		ids := make([]ent.Value, 0, len(m.removedtagged_elineup_mall_items))
		for id := range m.removedtagged_elineup_mall_items {
			ids = append(ids, id)
		}
		return ids
	case hpartist.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.removedfollowed_by))
		for id := range m.removedfollowed_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPArtistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedmembers {
		edges = append(edges, hpartist.EdgeMembers)
	}
	if m.clearedassets {
		edges = append(edges, hpartist.EdgeAssets)
	}
	if m.clearedowning_feed {
		edges = append(edges, hpartist.EdgeOwningFeed)
	}
	if m.clearedtagged_feed {
		edges = append(edges, hpartist.EdgeTaggedFeed)
	}
	if m.clearedowning_ig_posts {
		edges = append(edges, hpartist.EdgeOwningIgPosts)
	}
	if m.clearedtagged_ig_posts {
		edges = append(edges, hpartist.EdgeTaggedIgPosts)
	}
	if m.clearedowning_ameblo_posts {
		edges = append(edges, hpartist.EdgeOwningAmebloPosts)
	}
	if m.clearedtagged_ameblo_posts {
		edges = append(edges, hpartist.EdgeTaggedAmebloPosts)
	}
	if m.clearedtagged_elineup_mall_items {
		edges = append(edges, hpartist.EdgeTaggedElineupMallItems)
	}
	if m.clearedfollowed_by {
		edges = append(edges, hpartist.EdgeFollowedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPArtistMutation) EdgeCleared(name string) bool {
	switch name {
	case hpartist.EdgeMembers:
		return m.clearedmembers
	case hpartist.EdgeAssets:
		return m.clearedassets
	case hpartist.EdgeOwningFeed:
		return m.clearedowning_feed
	case hpartist.EdgeTaggedFeed:
		return m.clearedtagged_feed
	case hpartist.EdgeOwningIgPosts:
		return m.clearedowning_ig_posts
	case hpartist.EdgeTaggedIgPosts:
		return m.clearedtagged_ig_posts
	case hpartist.EdgeOwningAmebloPosts:
		return m.clearedowning_ameblo_posts
	case hpartist.EdgeTaggedAmebloPosts:
		return m.clearedtagged_ameblo_posts
	case hpartist.EdgeTaggedElineupMallItems:
		return m.clearedtagged_elineup_mall_items
	case hpartist.EdgeFollowedBy:
		return m.clearedfollowed_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPArtistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HPArtist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPArtistMutation) ResetEdge(name string) error {
	switch name {
	case hpartist.EdgeMembers:
		m.ResetMembers()
		return nil
	case hpartist.EdgeAssets:
		m.ResetAssets()
		return nil
	case hpartist.EdgeOwningFeed:
		m.ResetOwningFeed()
		return nil
	case hpartist.EdgeTaggedFeed:
		m.ResetTaggedFeed()
		return nil
	case hpartist.EdgeOwningIgPosts:
		m.ResetOwningIgPosts()
		return nil
	case hpartist.EdgeTaggedIgPosts:
		m.ResetTaggedIgPosts()
		return nil
	case hpartist.EdgeOwningAmebloPosts:
		m.ResetOwningAmebloPosts()
		return nil
	case hpartist.EdgeTaggedAmebloPosts:
		m.ResetTaggedAmebloPosts()
		return nil
	case hpartist.EdgeTaggedElineupMallItems:
		m.ResetTaggedElineupMallItems()
		return nil
	case hpartist.EdgeFollowedBy:
		m.ResetFollowedBy()
		return nil
	}
	return fmt.Errorf("unknown HPArtist edge %s", name)
}

// HPAssetMutation represents an operation that mutates the HPAsset nodes in the graph.
type HPAssetMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	key                 *string
	asset_type          *enums.HPAssetType
	clearedFields       map[string]struct{}
	artist              *int
	clearedartist       bool
	members             map[int]struct{}
	removedmembers      map[int]struct{}
	clearedmembers      bool
	ameblo_posts        map[int]struct{}
	removedameblo_posts map[int]struct{}
	clearedameblo_posts bool
	ig_posts            map[int]struct{}
	removedig_posts     map[int]struct{}
	clearedig_posts     bool
	done                bool
	oldValue            func(context.Context) (*HPAsset, error)
	predicates          []predicate.HPAsset
}

var _ ent.Mutation = (*HPAssetMutation)(nil)

// hpassetOption allows management of the mutation configuration using functional options.
type hpassetOption func(*HPAssetMutation)

// newHPAssetMutation creates new mutation for the HPAsset entity.
func newHPAssetMutation(c config, op Op, opts ...hpassetOption) *HPAssetMutation {
	m := &HPAssetMutation{
		config:        c,
		op:            op,
		typ:           TypeHPAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPAssetID sets the ID field of the mutation.
func withHPAssetID(id int) hpassetOption {
	return func(m *HPAssetMutation) {
		var (
			err   error
			once  sync.Once
			value *HPAsset
		)
		m.oldValue = func(ctx context.Context) (*HPAsset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPAsset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPAsset sets the old HPAsset of the mutation.
func withHPAsset(node *HPAsset) hpassetOption {
	return func(m *HPAssetMutation) {
		m.oldValue = func(context.Context) (*HPAsset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPAssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPAssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPAssetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPAssetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPAsset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *HPAssetMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *HPAssetMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the HPAsset entity.
// If the HPAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAssetMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *HPAssetMutation) ResetKey() {
	m.key = nil
}

// SetAssetType sets the "asset_type" field.
func (m *HPAssetMutation) SetAssetType(eat enums.HPAssetType) {
	m.asset_type = &eat
}

// AssetType returns the value of the "asset_type" field in the mutation.
func (m *HPAssetMutation) AssetType() (r enums.HPAssetType, exists bool) {
	v := m.asset_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetType returns the old "asset_type" field's value of the HPAsset entity.
// If the HPAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPAssetMutation) OldAssetType(ctx context.Context) (v enums.HPAssetType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetType: %w", err)
	}
	return oldValue.AssetType, nil
}

// ResetAssetType resets all changes to the "asset_type" field.
func (m *HPAssetMutation) ResetAssetType() {
	m.asset_type = nil
}

// SetArtistID sets the "artist" edge to the HPArtist entity by id.
func (m *HPAssetMutation) SetArtistID(id int) {
	m.artist = &id
}

// ClearArtist clears the "artist" edge to the HPArtist entity.
func (m *HPAssetMutation) ClearArtist() {
	m.clearedartist = true
}

// ArtistCleared reports if the "artist" edge to the HPArtist entity was cleared.
func (m *HPAssetMutation) ArtistCleared() bool {
	return m.clearedartist
}

// ArtistID returns the "artist" edge ID in the mutation.
func (m *HPAssetMutation) ArtistID() (id int, exists bool) {
	if m.artist != nil {
		return *m.artist, true
	}
	return
}

// ArtistIDs returns the "artist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtistID instead. It exists only for internal usage by the builders.
func (m *HPAssetMutation) ArtistIDs() (ids []int) {
	if id := m.artist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtist resets all changes to the "artist" edge.
func (m *HPAssetMutation) ResetArtist() {
	m.artist = nil
	m.clearedartist = false
}

// AddMemberIDs adds the "members" edge to the HPMember entity by ids.
func (m *HPAssetMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the HPMember entity.
func (m *HPAssetMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the HPMember entity was cleared.
func (m *HPAssetMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the HPMember entity by IDs.
func (m *HPAssetMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the HPMember entity.
func (m *HPAssetMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *HPAssetMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *HPAssetMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddAmebloPostIDs adds the "ameblo_posts" edge to the HPAmebloPost entity by ids.
func (m *HPAssetMutation) AddAmebloPostIDs(ids ...int) {
	if m.ameblo_posts == nil {
		m.ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.ameblo_posts[ids[i]] = struct{}{}
	}
}

// ClearAmebloPosts clears the "ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPAssetMutation) ClearAmebloPosts() {
	m.clearedameblo_posts = true
}

// AmebloPostsCleared reports if the "ameblo_posts" edge to the HPAmebloPost entity was cleared.
func (m *HPAssetMutation) AmebloPostsCleared() bool {
	return m.clearedameblo_posts
}

// RemoveAmebloPostIDs removes the "ameblo_posts" edge to the HPAmebloPost entity by IDs.
func (m *HPAssetMutation) RemoveAmebloPostIDs(ids ...int) {
	if m.removedameblo_posts == nil {
		m.removedameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ameblo_posts, ids[i])
		m.removedameblo_posts[ids[i]] = struct{}{}
	}
}

// RemovedAmebloPosts returns the removed IDs of the "ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPAssetMutation) RemovedAmebloPostsIDs() (ids []int) {
	for id := range m.removedameblo_posts {
		ids = append(ids, id)
	}
	return
}

// AmebloPostsIDs returns the "ameblo_posts" edge IDs in the mutation.
func (m *HPAssetMutation) AmebloPostsIDs() (ids []int) {
	for id := range m.ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// ResetAmebloPosts resets all changes to the "ameblo_posts" edge.
func (m *HPAssetMutation) ResetAmebloPosts() {
	m.ameblo_posts = nil
	m.clearedameblo_posts = false
	m.removedameblo_posts = nil
}

// AddIgPostIDs adds the "ig_posts" edge to the HPIgPost entity by ids.
func (m *HPAssetMutation) AddIgPostIDs(ids ...int) {
	if m.ig_posts == nil {
		m.ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.ig_posts[ids[i]] = struct{}{}
	}
}

// ClearIgPosts clears the "ig_posts" edge to the HPIgPost entity.
func (m *HPAssetMutation) ClearIgPosts() {
	m.clearedig_posts = true
}

// IgPostsCleared reports if the "ig_posts" edge to the HPIgPost entity was cleared.
func (m *HPAssetMutation) IgPostsCleared() bool {
	return m.clearedig_posts
}

// RemoveIgPostIDs removes the "ig_posts" edge to the HPIgPost entity by IDs.
func (m *HPAssetMutation) RemoveIgPostIDs(ids ...int) {
	if m.removedig_posts == nil {
		m.removedig_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ig_posts, ids[i])
		m.removedig_posts[ids[i]] = struct{}{}
	}
}

// RemovedIgPosts returns the removed IDs of the "ig_posts" edge to the HPIgPost entity.
func (m *HPAssetMutation) RemovedIgPostsIDs() (ids []int) {
	for id := range m.removedig_posts {
		ids = append(ids, id)
	}
	return
}

// IgPostsIDs returns the "ig_posts" edge IDs in the mutation.
func (m *HPAssetMutation) IgPostsIDs() (ids []int) {
	for id := range m.ig_posts {
		ids = append(ids, id)
	}
	return
}

// ResetIgPosts resets all changes to the "ig_posts" edge.
func (m *HPAssetMutation) ResetIgPosts() {
	m.ig_posts = nil
	m.clearedig_posts = false
	m.removedig_posts = nil
}

// Where appends a list predicates to the HPAssetMutation builder.
func (m *HPAssetMutation) Where(ps ...predicate.HPAsset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPAssetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPAssetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPAsset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPAssetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPAssetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPAsset).
func (m *HPAssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPAssetMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.key != nil {
		fields = append(fields, hpasset.FieldKey)
	}
	if m.asset_type != nil {
		fields = append(fields, hpasset.FieldAssetType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPAssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpasset.FieldKey:
		return m.Key()
	case hpasset.FieldAssetType:
		return m.AssetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPAssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpasset.FieldKey:
		return m.OldKey(ctx)
	case hpasset.FieldAssetType:
		return m.OldAssetType(ctx)
	}
	return nil, fmt.Errorf("unknown HPAsset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPAssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpasset.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case hpasset.FieldAssetType:
		v, ok := value.(enums.HPAssetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetType(v)
		return nil
	}
	return fmt.Errorf("unknown HPAsset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPAssetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPAssetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPAssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HPAsset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPAssetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPAssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPAssetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HPAsset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPAssetMutation) ResetField(name string) error {
	switch name {
	case hpasset.FieldKey:
		m.ResetKey()
		return nil
	case hpasset.FieldAssetType:
		m.ResetAssetType()
		return nil
	}
	return fmt.Errorf("unknown HPAsset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPAssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.artist != nil {
		edges = append(edges, hpasset.EdgeArtist)
	}
	if m.members != nil {
		edges = append(edges, hpasset.EdgeMembers)
	}
	if m.ameblo_posts != nil {
		edges = append(edges, hpasset.EdgeAmebloPosts)
	}
	if m.ig_posts != nil {
		edges = append(edges, hpasset.EdgeIgPosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPAssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpasset.EdgeArtist:
		if id := m.artist; id != nil {
			return []ent.Value{*id}
		}
	case hpasset.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case hpasset.EdgeAmebloPosts:
		ids := make([]ent.Value, 0, len(m.ameblo_posts))
		for id := range m.ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpasset.EdgeIgPosts:
		ids := make([]ent.Value, 0, len(m.ig_posts))
		for id := range m.ig_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPAssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmembers != nil {
		edges = append(edges, hpasset.EdgeMembers)
	}
	if m.removedameblo_posts != nil {
		edges = append(edges, hpasset.EdgeAmebloPosts)
	}
	if m.removedig_posts != nil {
		edges = append(edges, hpasset.EdgeIgPosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPAssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpasset.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case hpasset.EdgeAmebloPosts:
		ids := make([]ent.Value, 0, len(m.removedameblo_posts))
		for id := range m.removedameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpasset.EdgeIgPosts:
		ids := make([]ent.Value, 0, len(m.removedig_posts))
		for id := range m.removedig_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPAssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedartist {
		edges = append(edges, hpasset.EdgeArtist)
	}
	if m.clearedmembers {
		edges = append(edges, hpasset.EdgeMembers)
	}
	if m.clearedameblo_posts {
		edges = append(edges, hpasset.EdgeAmebloPosts)
	}
	if m.clearedig_posts {
		edges = append(edges, hpasset.EdgeIgPosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPAssetMutation) EdgeCleared(name string) bool {
	switch name {
	case hpasset.EdgeArtist:
		return m.clearedartist
	case hpasset.EdgeMembers:
		return m.clearedmembers
	case hpasset.EdgeAmebloPosts:
		return m.clearedameblo_posts
	case hpasset.EdgeIgPosts:
		return m.clearedig_posts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPAssetMutation) ClearEdge(name string) error {
	switch name {
	case hpasset.EdgeArtist:
		m.ClearArtist()
		return nil
	}
	return fmt.Errorf("unknown HPAsset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPAssetMutation) ResetEdge(name string) error {
	switch name {
	case hpasset.EdgeArtist:
		m.ResetArtist()
		return nil
	case hpasset.EdgeMembers:
		m.ResetMembers()
		return nil
	case hpasset.EdgeAmebloPosts:
		m.ResetAmebloPosts()
		return nil
	case hpasset.EdgeIgPosts:
		m.ResetIgPosts()
		return nil
	}
	return fmt.Errorf("unknown HPAsset edge %s", name)
}

// HPBlobMutation represents an operation that mutates the HPBlob nodes in the graph.
type HPBlobMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	storage_path            *string
	source_url              *string
	source_html_url         *string
	status                  *enums.HPBlobStatus
	status_message          *string
	status_error_count      *int
	addstatus_error_count   *int
	_type                   *enums.HPBlobType
	sub_type                *enums.HPBlobSubType
	width                   *int
	addwidth                *int
	height                  *int
	addheight               *int
	size                    *int64
	addsize                 *int64
	num_faces               *int
	addnum_faces            *int
	faces                   *jsonfields.HPBlobImageFace
	face_recognition_status *enums.HPBlobFaceRecognitionStatus
	thumbnail               **jsonfields.HPBlobThumbnail
	duration_seconds        *float64
	addduration_seconds     *float64
	clearedFields           map[string]struct{}
	owner_artist            *int
	clearedowner_artist     bool
	owner_member            *int
	clearedowner_member     bool
	ameblo_posts            map[int]struct{}
	removedameblo_posts     map[int]struct{}
	clearedameblo_posts     bool
	ig_posts                map[int]struct{}
	removedig_posts         map[int]struct{}
	clearedig_posts         bool
	done                    bool
	oldValue                func(context.Context) (*HPBlob, error)
	predicates              []predicate.HPBlob
}

var _ ent.Mutation = (*HPBlobMutation)(nil)

// hpblobOption allows management of the mutation configuration using functional options.
type hpblobOption func(*HPBlobMutation)

// newHPBlobMutation creates new mutation for the HPBlob entity.
func newHPBlobMutation(c config, op Op, opts ...hpblobOption) *HPBlobMutation {
	m := &HPBlobMutation{
		config:        c,
		op:            op,
		typ:           TypeHPBlob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPBlobID sets the ID field of the mutation.
func withHPBlobID(id int) hpblobOption {
	return func(m *HPBlobMutation) {
		var (
			err   error
			once  sync.Once
			value *HPBlob
		)
		m.oldValue = func(ctx context.Context) (*HPBlob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPBlob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPBlob sets the old HPBlob of the mutation.
func withHPBlob(node *HPBlob) hpblobOption {
	return func(m *HPBlobMutation) {
		m.oldValue = func(context.Context) (*HPBlob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPBlobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPBlobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPBlobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPBlobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPBlob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HPBlobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPBlobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPBlobMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpblob.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPBlobMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPBlobMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpblob.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPBlobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPBlobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPBlobMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpblob.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPBlobMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPBlobMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpblob.FieldUpdatedAt)
}

// SetStoragePath sets the "storage_path" field.
func (m *HPBlobMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *HPBlobMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *HPBlobMutation) ResetStoragePath() {
	m.storage_path = nil
}

// SetSourceURL sets the "source_url" field.
func (m *HPBlobMutation) SetSourceURL(s string) {
	m.source_url = &s
}

// SourceURL returns the value of the "source_url" field in the mutation.
func (m *HPBlobMutation) SourceURL() (r string, exists bool) {
	v := m.source_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceURL returns the old "source_url" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldSourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceURL: %w", err)
	}
	return oldValue.SourceURL, nil
}

// ResetSourceURL resets all changes to the "source_url" field.
func (m *HPBlobMutation) ResetSourceURL() {
	m.source_url = nil
}

// SetSourceHTMLURL sets the "source_html_url" field.
func (m *HPBlobMutation) SetSourceHTMLURL(s string) {
	m.source_html_url = &s
}

// SourceHTMLURL returns the value of the "source_html_url" field in the mutation.
func (m *HPBlobMutation) SourceHTMLURL() (r string, exists bool) {
	v := m.source_html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceHTMLURL returns the old "source_html_url" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldSourceHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceHTMLURL: %w", err)
	}
	return oldValue.SourceHTMLURL, nil
}

// ResetSourceHTMLURL resets all changes to the "source_html_url" field.
func (m *HPBlobMutation) ResetSourceHTMLURL() {
	m.source_html_url = nil
}

// SetStatus sets the "status" field.
func (m *HPBlobMutation) SetStatus(ebs enums.HPBlobStatus) {
	m.status = &ebs
}

// Status returns the value of the "status" field in the mutation.
func (m *HPBlobMutation) Status() (r enums.HPBlobStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldStatus(ctx context.Context) (v enums.HPBlobStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HPBlobMutation) ResetStatus() {
	m.status = nil
}

// SetStatusMessage sets the "status_message" field.
func (m *HPBlobMutation) SetStatusMessage(s string) {
	m.status_message = &s
}

// StatusMessage returns the value of the "status_message" field in the mutation.
func (m *HPBlobMutation) StatusMessage() (r string, exists bool) {
	v := m.status_message
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusMessage returns the old "status_message" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldStatusMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusMessage: %w", err)
	}
	return oldValue.StatusMessage, nil
}

// ClearStatusMessage clears the value of the "status_message" field.
func (m *HPBlobMutation) ClearStatusMessage() {
	m.status_message = nil
	m.clearedFields[hpblob.FieldStatusMessage] = struct{}{}
}

// StatusMessageCleared returns if the "status_message" field was cleared in this mutation.
func (m *HPBlobMutation) StatusMessageCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldStatusMessage]
	return ok
}

// ResetStatusMessage resets all changes to the "status_message" field.
func (m *HPBlobMutation) ResetStatusMessage() {
	m.status_message = nil
	delete(m.clearedFields, hpblob.FieldStatusMessage)
}

// SetStatusErrorCount sets the "status_error_count" field.
func (m *HPBlobMutation) SetStatusErrorCount(i int) {
	m.status_error_count = &i
	m.addstatus_error_count = nil
}

// StatusErrorCount returns the value of the "status_error_count" field in the mutation.
func (m *HPBlobMutation) StatusErrorCount() (r int, exists bool) {
	v := m.status_error_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusErrorCount returns the old "status_error_count" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldStatusErrorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusErrorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusErrorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusErrorCount: %w", err)
	}
	return oldValue.StatusErrorCount, nil
}

// AddStatusErrorCount adds i to the "status_error_count" field.
func (m *HPBlobMutation) AddStatusErrorCount(i int) {
	if m.addstatus_error_count != nil {
		*m.addstatus_error_count += i
	} else {
		m.addstatus_error_count = &i
	}
}

// AddedStatusErrorCount returns the value that was added to the "status_error_count" field in this mutation.
func (m *HPBlobMutation) AddedStatusErrorCount() (r int, exists bool) {
	v := m.addstatus_error_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusErrorCount clears the value of the "status_error_count" field.
func (m *HPBlobMutation) ClearStatusErrorCount() {
	m.status_error_count = nil
	m.addstatus_error_count = nil
	m.clearedFields[hpblob.FieldStatusErrorCount] = struct{}{}
}

// StatusErrorCountCleared returns if the "status_error_count" field was cleared in this mutation.
func (m *HPBlobMutation) StatusErrorCountCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldStatusErrorCount]
	return ok
}

// ResetStatusErrorCount resets all changes to the "status_error_count" field.
func (m *HPBlobMutation) ResetStatusErrorCount() {
	m.status_error_count = nil
	m.addstatus_error_count = nil
	delete(m.clearedFields, hpblob.FieldStatusErrorCount)
}

// SetType sets the "type" field.
func (m *HPBlobMutation) SetType(ebt enums.HPBlobType) {
	m._type = &ebt
}

// GetType returns the value of the "type" field in the mutation.
func (m *HPBlobMutation) GetType() (r enums.HPBlobType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldType(ctx context.Context) (v enums.HPBlobType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *HPBlobMutation) ResetType() {
	m._type = nil
}

// SetSubType sets the "sub_type" field.
func (m *HPBlobMutation) SetSubType(ebst enums.HPBlobSubType) {
	m.sub_type = &ebst
}

// SubType returns the value of the "sub_type" field in the mutation.
func (m *HPBlobMutation) SubType() (r enums.HPBlobSubType, exists bool) {
	v := m.sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubType returns the old "sub_type" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldSubType(ctx context.Context) (v enums.HPBlobSubType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubType: %w", err)
	}
	return oldValue.SubType, nil
}

// ResetSubType resets all changes to the "sub_type" field.
func (m *HPBlobMutation) ResetSubType() {
	m.sub_type = nil
}

// SetWidth sets the "width" field.
func (m *HPBlobMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *HPBlobMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *HPBlobMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *HPBlobMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *HPBlobMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[hpblob.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *HPBlobMutation) WidthCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *HPBlobMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, hpblob.FieldWidth)
}

// SetHeight sets the "height" field.
func (m *HPBlobMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *HPBlobMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *HPBlobMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *HPBlobMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *HPBlobMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[hpblob.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *HPBlobMutation) HeightCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *HPBlobMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, hpblob.FieldHeight)
}

// SetSize sets the "size" field.
func (m *HPBlobMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *HPBlobMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *HPBlobMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *HPBlobMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *HPBlobMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[hpblob.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *HPBlobMutation) SizeCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *HPBlobMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, hpblob.FieldSize)
}

// SetOwnerArtistID sets the "owner_artist_id" field.
func (m *HPBlobMutation) SetOwnerArtistID(i int) {
	m.owner_artist = &i
}

// OwnerArtistID returns the value of the "owner_artist_id" field in the mutation.
func (m *HPBlobMutation) OwnerArtistID() (r int, exists bool) {
	v := m.owner_artist
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerArtistID returns the old "owner_artist_id" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldOwnerArtistID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerArtistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerArtistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerArtistID: %w", err)
	}
	return oldValue.OwnerArtistID, nil
}

// ClearOwnerArtistID clears the value of the "owner_artist_id" field.
func (m *HPBlobMutation) ClearOwnerArtistID() {
	m.owner_artist = nil
	m.clearedFields[hpblob.FieldOwnerArtistID] = struct{}{}
}

// OwnerArtistIDCleared returns if the "owner_artist_id" field was cleared in this mutation.
func (m *HPBlobMutation) OwnerArtistIDCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldOwnerArtistID]
	return ok
}

// ResetOwnerArtistID resets all changes to the "owner_artist_id" field.
func (m *HPBlobMutation) ResetOwnerArtistID() {
	m.owner_artist = nil
	delete(m.clearedFields, hpblob.FieldOwnerArtistID)
}

// SetOwnerMemberID sets the "owner_member_id" field.
func (m *HPBlobMutation) SetOwnerMemberID(i int) {
	m.owner_member = &i
}

// OwnerMemberID returns the value of the "owner_member_id" field in the mutation.
func (m *HPBlobMutation) OwnerMemberID() (r int, exists bool) {
	v := m.owner_member
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerMemberID returns the old "owner_member_id" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldOwnerMemberID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerMemberID: %w", err)
	}
	return oldValue.OwnerMemberID, nil
}

// ClearOwnerMemberID clears the value of the "owner_member_id" field.
func (m *HPBlobMutation) ClearOwnerMemberID() {
	m.owner_member = nil
	m.clearedFields[hpblob.FieldOwnerMemberID] = struct{}{}
}

// OwnerMemberIDCleared returns if the "owner_member_id" field was cleared in this mutation.
func (m *HPBlobMutation) OwnerMemberIDCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldOwnerMemberID]
	return ok
}

// ResetOwnerMemberID resets all changes to the "owner_member_id" field.
func (m *HPBlobMutation) ResetOwnerMemberID() {
	m.owner_member = nil
	delete(m.clearedFields, hpblob.FieldOwnerMemberID)
}

// SetNumFaces sets the "num_faces" field.
func (m *HPBlobMutation) SetNumFaces(i int) {
	m.num_faces = &i
	m.addnum_faces = nil
}

// NumFaces returns the value of the "num_faces" field in the mutation.
func (m *HPBlobMutation) NumFaces() (r int, exists bool) {
	v := m.num_faces
	if v == nil {
		return
	}
	return *v, true
}

// OldNumFaces returns the old "num_faces" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldNumFaces(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumFaces is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumFaces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumFaces: %w", err)
	}
	return oldValue.NumFaces, nil
}

// AddNumFaces adds i to the "num_faces" field.
func (m *HPBlobMutation) AddNumFaces(i int) {
	if m.addnum_faces != nil {
		*m.addnum_faces += i
	} else {
		m.addnum_faces = &i
	}
}

// AddedNumFaces returns the value that was added to the "num_faces" field in this mutation.
func (m *HPBlobMutation) AddedNumFaces() (r int, exists bool) {
	v := m.addnum_faces
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumFaces clears the value of the "num_faces" field.
func (m *HPBlobMutation) ClearNumFaces() {
	m.num_faces = nil
	m.addnum_faces = nil
	m.clearedFields[hpblob.FieldNumFaces] = struct{}{}
}

// NumFacesCleared returns if the "num_faces" field was cleared in this mutation.
func (m *HPBlobMutation) NumFacesCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldNumFaces]
	return ok
}

// ResetNumFaces resets all changes to the "num_faces" field.
func (m *HPBlobMutation) ResetNumFaces() {
	m.num_faces = nil
	m.addnum_faces = nil
	delete(m.clearedFields, hpblob.FieldNumFaces)
}

// SetFaces sets the "faces" field.
func (m *HPBlobMutation) SetFaces(jbif jsonfields.HPBlobImageFace) {
	m.faces = &jbif
}

// Faces returns the value of the "faces" field in the mutation.
func (m *HPBlobMutation) Faces() (r jsonfields.HPBlobImageFace, exists bool) {
	v := m.faces
	if v == nil {
		return
	}
	return *v, true
}

// OldFaces returns the old "faces" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldFaces(ctx context.Context) (v jsonfields.HPBlobImageFace, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaces is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaces: %w", err)
	}
	return oldValue.Faces, nil
}

// ClearFaces clears the value of the "faces" field.
func (m *HPBlobMutation) ClearFaces() {
	m.faces = nil
	m.clearedFields[hpblob.FieldFaces] = struct{}{}
}

// FacesCleared returns if the "faces" field was cleared in this mutation.
func (m *HPBlobMutation) FacesCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldFaces]
	return ok
}

// ResetFaces resets all changes to the "faces" field.
func (m *HPBlobMutation) ResetFaces() {
	m.faces = nil
	delete(m.clearedFields, hpblob.FieldFaces)
}

// SetFaceRecognitionStatus sets the "face_recognition_status" field.
func (m *HPBlobMutation) SetFaceRecognitionStatus(ebfrs enums.HPBlobFaceRecognitionStatus) {
	m.face_recognition_status = &ebfrs
}

// FaceRecognitionStatus returns the value of the "face_recognition_status" field in the mutation.
func (m *HPBlobMutation) FaceRecognitionStatus() (r enums.HPBlobFaceRecognitionStatus, exists bool) {
	v := m.face_recognition_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceRecognitionStatus returns the old "face_recognition_status" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldFaceRecognitionStatus(ctx context.Context) (v enums.HPBlobFaceRecognitionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceRecognitionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceRecognitionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceRecognitionStatus: %w", err)
	}
	return oldValue.FaceRecognitionStatus, nil
}

// ClearFaceRecognitionStatus clears the value of the "face_recognition_status" field.
func (m *HPBlobMutation) ClearFaceRecognitionStatus() {
	m.face_recognition_status = nil
	m.clearedFields[hpblob.FieldFaceRecognitionStatus] = struct{}{}
}

// FaceRecognitionStatusCleared returns if the "face_recognition_status" field was cleared in this mutation.
func (m *HPBlobMutation) FaceRecognitionStatusCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldFaceRecognitionStatus]
	return ok
}

// ResetFaceRecognitionStatus resets all changes to the "face_recognition_status" field.
func (m *HPBlobMutation) ResetFaceRecognitionStatus() {
	m.face_recognition_status = nil
	delete(m.clearedFields, hpblob.FieldFaceRecognitionStatus)
}

// SetThumbnail sets the "thumbnail" field.
func (m *HPBlobMutation) SetThumbnail(jbt *jsonfields.HPBlobThumbnail) {
	m.thumbnail = &jbt
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *HPBlobMutation) Thumbnail() (r *jsonfields.HPBlobThumbnail, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldThumbnail(ctx context.Context) (v *jsonfields.HPBlobThumbnail, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ClearThumbnail clears the value of the "thumbnail" field.
func (m *HPBlobMutation) ClearThumbnail() {
	m.thumbnail = nil
	m.clearedFields[hpblob.FieldThumbnail] = struct{}{}
}

// ThumbnailCleared returns if the "thumbnail" field was cleared in this mutation.
func (m *HPBlobMutation) ThumbnailCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldThumbnail]
	return ok
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *HPBlobMutation) ResetThumbnail() {
	m.thumbnail = nil
	delete(m.clearedFields, hpblob.FieldThumbnail)
}

// SetDurationSeconds sets the "duration_seconds" field.
func (m *HPBlobMutation) SetDurationSeconds(f float64) {
	m.duration_seconds = &f
	m.addduration_seconds = nil
}

// DurationSeconds returns the value of the "duration_seconds" field in the mutation.
func (m *HPBlobMutation) DurationSeconds() (r float64, exists bool) {
	v := m.duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationSeconds returns the old "duration_seconds" field's value of the HPBlob entity.
// If the HPBlob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPBlobMutation) OldDurationSeconds(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationSeconds: %w", err)
	}
	return oldValue.DurationSeconds, nil
}

// AddDurationSeconds adds f to the "duration_seconds" field.
func (m *HPBlobMutation) AddDurationSeconds(f float64) {
	if m.addduration_seconds != nil {
		*m.addduration_seconds += f
	} else {
		m.addduration_seconds = &f
	}
}

// AddedDurationSeconds returns the value that was added to the "duration_seconds" field in this mutation.
func (m *HPBlobMutation) AddedDurationSeconds() (r float64, exists bool) {
	v := m.addduration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationSeconds clears the value of the "duration_seconds" field.
func (m *HPBlobMutation) ClearDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
	m.clearedFields[hpblob.FieldDurationSeconds] = struct{}{}
}

// DurationSecondsCleared returns if the "duration_seconds" field was cleared in this mutation.
func (m *HPBlobMutation) DurationSecondsCleared() bool {
	_, ok := m.clearedFields[hpblob.FieldDurationSeconds]
	return ok
}

// ResetDurationSeconds resets all changes to the "duration_seconds" field.
func (m *HPBlobMutation) ResetDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
	delete(m.clearedFields, hpblob.FieldDurationSeconds)
}

// ClearOwnerArtist clears the "owner_artist" edge to the HPArtist entity.
func (m *HPBlobMutation) ClearOwnerArtist() {
	m.clearedowner_artist = true
}

// OwnerArtistCleared reports if the "owner_artist" edge to the HPArtist entity was cleared.
func (m *HPBlobMutation) OwnerArtistCleared() bool {
	return m.OwnerArtistIDCleared() || m.clearedowner_artist
}

// OwnerArtistIDs returns the "owner_artist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerArtistID instead. It exists only for internal usage by the builders.
func (m *HPBlobMutation) OwnerArtistIDs() (ids []int) {
	if id := m.owner_artist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerArtist resets all changes to the "owner_artist" edge.
func (m *HPBlobMutation) ResetOwnerArtist() {
	m.owner_artist = nil
	m.clearedowner_artist = false
}

// ClearOwnerMember clears the "owner_member" edge to the HPMember entity.
func (m *HPBlobMutation) ClearOwnerMember() {
	m.clearedowner_member = true
}

// OwnerMemberCleared reports if the "owner_member" edge to the HPMember entity was cleared.
func (m *HPBlobMutation) OwnerMemberCleared() bool {
	return m.OwnerMemberIDCleared() || m.clearedowner_member
}

// OwnerMemberIDs returns the "owner_member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerMemberID instead. It exists only for internal usage by the builders.
func (m *HPBlobMutation) OwnerMemberIDs() (ids []int) {
	if id := m.owner_member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerMember resets all changes to the "owner_member" edge.
func (m *HPBlobMutation) ResetOwnerMember() {
	m.owner_member = nil
	m.clearedowner_member = false
}

// AddAmebloPostIDs adds the "ameblo_posts" edge to the HPAmebloPost entity by ids.
func (m *HPBlobMutation) AddAmebloPostIDs(ids ...int) {
	if m.ameblo_posts == nil {
		m.ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.ameblo_posts[ids[i]] = struct{}{}
	}
}

// ClearAmebloPosts clears the "ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPBlobMutation) ClearAmebloPosts() {
	m.clearedameblo_posts = true
}

// AmebloPostsCleared reports if the "ameblo_posts" edge to the HPAmebloPost entity was cleared.
func (m *HPBlobMutation) AmebloPostsCleared() bool {
	return m.clearedameblo_posts
}

// RemoveAmebloPostIDs removes the "ameblo_posts" edge to the HPAmebloPost entity by IDs.
func (m *HPBlobMutation) RemoveAmebloPostIDs(ids ...int) {
	if m.removedameblo_posts == nil {
		m.removedameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ameblo_posts, ids[i])
		m.removedameblo_posts[ids[i]] = struct{}{}
	}
}

// RemovedAmebloPosts returns the removed IDs of the "ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPBlobMutation) RemovedAmebloPostsIDs() (ids []int) {
	for id := range m.removedameblo_posts {
		ids = append(ids, id)
	}
	return
}

// AmebloPostsIDs returns the "ameblo_posts" edge IDs in the mutation.
func (m *HPBlobMutation) AmebloPostsIDs() (ids []int) {
	for id := range m.ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// ResetAmebloPosts resets all changes to the "ameblo_posts" edge.
func (m *HPBlobMutation) ResetAmebloPosts() {
	m.ameblo_posts = nil
	m.clearedameblo_posts = false
	m.removedameblo_posts = nil
}

// AddIgPostIDs adds the "ig_posts" edge to the HPIgPost entity by ids.
func (m *HPBlobMutation) AddIgPostIDs(ids ...int) {
	if m.ig_posts == nil {
		m.ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.ig_posts[ids[i]] = struct{}{}
	}
}

// ClearIgPosts clears the "ig_posts" edge to the HPIgPost entity.
func (m *HPBlobMutation) ClearIgPosts() {
	m.clearedig_posts = true
}

// IgPostsCleared reports if the "ig_posts" edge to the HPIgPost entity was cleared.
func (m *HPBlobMutation) IgPostsCleared() bool {
	return m.clearedig_posts
}

// RemoveIgPostIDs removes the "ig_posts" edge to the HPIgPost entity by IDs.
func (m *HPBlobMutation) RemoveIgPostIDs(ids ...int) {
	if m.removedig_posts == nil {
		m.removedig_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ig_posts, ids[i])
		m.removedig_posts[ids[i]] = struct{}{}
	}
}

// RemovedIgPosts returns the removed IDs of the "ig_posts" edge to the HPIgPost entity.
func (m *HPBlobMutation) RemovedIgPostsIDs() (ids []int) {
	for id := range m.removedig_posts {
		ids = append(ids, id)
	}
	return
}

// IgPostsIDs returns the "ig_posts" edge IDs in the mutation.
func (m *HPBlobMutation) IgPostsIDs() (ids []int) {
	for id := range m.ig_posts {
		ids = append(ids, id)
	}
	return
}

// ResetIgPosts resets all changes to the "ig_posts" edge.
func (m *HPBlobMutation) ResetIgPosts() {
	m.ig_posts = nil
	m.clearedig_posts = false
	m.removedig_posts = nil
}

// Where appends a list predicates to the HPBlobMutation builder.
func (m *HPBlobMutation) Where(ps ...predicate.HPBlob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPBlobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPBlobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPBlob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPBlobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPBlobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPBlob).
func (m *HPBlobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPBlobMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, hpblob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpblob.FieldUpdatedAt)
	}
	if m.storage_path != nil {
		fields = append(fields, hpblob.FieldStoragePath)
	}
	if m.source_url != nil {
		fields = append(fields, hpblob.FieldSourceURL)
	}
	if m.source_html_url != nil {
		fields = append(fields, hpblob.FieldSourceHTMLURL)
	}
	if m.status != nil {
		fields = append(fields, hpblob.FieldStatus)
	}
	if m.status_message != nil {
		fields = append(fields, hpblob.FieldStatusMessage)
	}
	if m.status_error_count != nil {
		fields = append(fields, hpblob.FieldStatusErrorCount)
	}
	if m._type != nil {
		fields = append(fields, hpblob.FieldType)
	}
	if m.sub_type != nil {
		fields = append(fields, hpblob.FieldSubType)
	}
	if m.width != nil {
		fields = append(fields, hpblob.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, hpblob.FieldHeight)
	}
	if m.size != nil {
		fields = append(fields, hpblob.FieldSize)
	}
	if m.owner_artist != nil {
		fields = append(fields, hpblob.FieldOwnerArtistID)
	}
	if m.owner_member != nil {
		fields = append(fields, hpblob.FieldOwnerMemberID)
	}
	if m.num_faces != nil {
		fields = append(fields, hpblob.FieldNumFaces)
	}
	if m.faces != nil {
		fields = append(fields, hpblob.FieldFaces)
	}
	if m.face_recognition_status != nil {
		fields = append(fields, hpblob.FieldFaceRecognitionStatus)
	}
	if m.thumbnail != nil {
		fields = append(fields, hpblob.FieldThumbnail)
	}
	if m.duration_seconds != nil {
		fields = append(fields, hpblob.FieldDurationSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPBlobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpblob.FieldCreatedAt:
		return m.CreatedAt()
	case hpblob.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpblob.FieldStoragePath:
		return m.StoragePath()
	case hpblob.FieldSourceURL:
		return m.SourceURL()
	case hpblob.FieldSourceHTMLURL:
		return m.SourceHTMLURL()
	case hpblob.FieldStatus:
		return m.Status()
	case hpblob.FieldStatusMessage:
		return m.StatusMessage()
	case hpblob.FieldStatusErrorCount:
		return m.StatusErrorCount()
	case hpblob.FieldType:
		return m.GetType()
	case hpblob.FieldSubType:
		return m.SubType()
	case hpblob.FieldWidth:
		return m.Width()
	case hpblob.FieldHeight:
		return m.Height()
	case hpblob.FieldSize:
		return m.Size()
	case hpblob.FieldOwnerArtistID:
		return m.OwnerArtistID()
	case hpblob.FieldOwnerMemberID:
		return m.OwnerMemberID()
	case hpblob.FieldNumFaces:
		return m.NumFaces()
	case hpblob.FieldFaces:
		return m.Faces()
	case hpblob.FieldFaceRecognitionStatus:
		return m.FaceRecognitionStatus()
	case hpblob.FieldThumbnail:
		return m.Thumbnail()
	case hpblob.FieldDurationSeconds:
		return m.DurationSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPBlobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpblob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpblob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpblob.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case hpblob.FieldSourceURL:
		return m.OldSourceURL(ctx)
	case hpblob.FieldSourceHTMLURL:
		return m.OldSourceHTMLURL(ctx)
	case hpblob.FieldStatus:
		return m.OldStatus(ctx)
	case hpblob.FieldStatusMessage:
		return m.OldStatusMessage(ctx)
	case hpblob.FieldStatusErrorCount:
		return m.OldStatusErrorCount(ctx)
	case hpblob.FieldType:
		return m.OldType(ctx)
	case hpblob.FieldSubType:
		return m.OldSubType(ctx)
	case hpblob.FieldWidth:
		return m.OldWidth(ctx)
	case hpblob.FieldHeight:
		return m.OldHeight(ctx)
	case hpblob.FieldSize:
		return m.OldSize(ctx)
	case hpblob.FieldOwnerArtistID:
		return m.OldOwnerArtistID(ctx)
	case hpblob.FieldOwnerMemberID:
		return m.OldOwnerMemberID(ctx)
	case hpblob.FieldNumFaces:
		return m.OldNumFaces(ctx)
	case hpblob.FieldFaces:
		return m.OldFaces(ctx)
	case hpblob.FieldFaceRecognitionStatus:
		return m.OldFaceRecognitionStatus(ctx)
	case hpblob.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case hpblob.FieldDurationSeconds:
		return m.OldDurationSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown HPBlob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPBlobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpblob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpblob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpblob.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case hpblob.FieldSourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceURL(v)
		return nil
	case hpblob.FieldSourceHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceHTMLURL(v)
		return nil
	case hpblob.FieldStatus:
		v, ok := value.(enums.HPBlobStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hpblob.FieldStatusMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusMessage(v)
		return nil
	case hpblob.FieldStatusErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusErrorCount(v)
		return nil
	case hpblob.FieldType:
		v, ok := value.(enums.HPBlobType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case hpblob.FieldSubType:
		v, ok := value.(enums.HPBlobSubType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubType(v)
		return nil
	case hpblob.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case hpblob.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case hpblob.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case hpblob.FieldOwnerArtistID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerArtistID(v)
		return nil
	case hpblob.FieldOwnerMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerMemberID(v)
		return nil
	case hpblob.FieldNumFaces:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumFaces(v)
		return nil
	case hpblob.FieldFaces:
		v, ok := value.(jsonfields.HPBlobImageFace)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaces(v)
		return nil
	case hpblob.FieldFaceRecognitionStatus:
		v, ok := value.(enums.HPBlobFaceRecognitionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceRecognitionStatus(v)
		return nil
	case hpblob.FieldThumbnail:
		v, ok := value.(*jsonfields.HPBlobThumbnail)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case hpblob.FieldDurationSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown HPBlob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPBlobMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_error_count != nil {
		fields = append(fields, hpblob.FieldStatusErrorCount)
	}
	if m.addwidth != nil {
		fields = append(fields, hpblob.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, hpblob.FieldHeight)
	}
	if m.addsize != nil {
		fields = append(fields, hpblob.FieldSize)
	}
	if m.addnum_faces != nil {
		fields = append(fields, hpblob.FieldNumFaces)
	}
	if m.addduration_seconds != nil {
		fields = append(fields, hpblob.FieldDurationSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPBlobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpblob.FieldStatusErrorCount:
		return m.AddedStatusErrorCount()
	case hpblob.FieldWidth:
		return m.AddedWidth()
	case hpblob.FieldHeight:
		return m.AddedHeight()
	case hpblob.FieldSize:
		return m.AddedSize()
	case hpblob.FieldNumFaces:
		return m.AddedNumFaces()
	case hpblob.FieldDurationSeconds:
		return m.AddedDurationSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPBlobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpblob.FieldStatusErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusErrorCount(v)
		return nil
	case hpblob.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case hpblob.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case hpblob.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case hpblob.FieldNumFaces:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumFaces(v)
		return nil
	case hpblob.FieldDurationSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown HPBlob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPBlobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpblob.FieldCreatedAt) {
		fields = append(fields, hpblob.FieldCreatedAt)
	}
	if m.FieldCleared(hpblob.FieldUpdatedAt) {
		fields = append(fields, hpblob.FieldUpdatedAt)
	}
	if m.FieldCleared(hpblob.FieldStatusMessage) {
		fields = append(fields, hpblob.FieldStatusMessage)
	}
	if m.FieldCleared(hpblob.FieldStatusErrorCount) {
		fields = append(fields, hpblob.FieldStatusErrorCount)
	}
	if m.FieldCleared(hpblob.FieldWidth) {
		fields = append(fields, hpblob.FieldWidth)
	}
	if m.FieldCleared(hpblob.FieldHeight) {
		fields = append(fields, hpblob.FieldHeight)
	}
	if m.FieldCleared(hpblob.FieldSize) {
		fields = append(fields, hpblob.FieldSize)
	}
	if m.FieldCleared(hpblob.FieldOwnerArtistID) {
		fields = append(fields, hpblob.FieldOwnerArtistID)
	}
	if m.FieldCleared(hpblob.FieldOwnerMemberID) {
		fields = append(fields, hpblob.FieldOwnerMemberID)
	}
	if m.FieldCleared(hpblob.FieldNumFaces) {
		fields = append(fields, hpblob.FieldNumFaces)
	}
	if m.FieldCleared(hpblob.FieldFaces) {
		fields = append(fields, hpblob.FieldFaces)
	}
	if m.FieldCleared(hpblob.FieldFaceRecognitionStatus) {
		fields = append(fields, hpblob.FieldFaceRecognitionStatus)
	}
	if m.FieldCleared(hpblob.FieldThumbnail) {
		fields = append(fields, hpblob.FieldThumbnail)
	}
	if m.FieldCleared(hpblob.FieldDurationSeconds) {
		fields = append(fields, hpblob.FieldDurationSeconds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPBlobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPBlobMutation) ClearField(name string) error {
	switch name {
	case hpblob.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpblob.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpblob.FieldStatusMessage:
		m.ClearStatusMessage()
		return nil
	case hpblob.FieldStatusErrorCount:
		m.ClearStatusErrorCount()
		return nil
	case hpblob.FieldWidth:
		m.ClearWidth()
		return nil
	case hpblob.FieldHeight:
		m.ClearHeight()
		return nil
	case hpblob.FieldSize:
		m.ClearSize()
		return nil
	case hpblob.FieldOwnerArtistID:
		m.ClearOwnerArtistID()
		return nil
	case hpblob.FieldOwnerMemberID:
		m.ClearOwnerMemberID()
		return nil
	case hpblob.FieldNumFaces:
		m.ClearNumFaces()
		return nil
	case hpblob.FieldFaces:
		m.ClearFaces()
		return nil
	case hpblob.FieldFaceRecognitionStatus:
		m.ClearFaceRecognitionStatus()
		return nil
	case hpblob.FieldThumbnail:
		m.ClearThumbnail()
		return nil
	case hpblob.FieldDurationSeconds:
		m.ClearDurationSeconds()
		return nil
	}
	return fmt.Errorf("unknown HPBlob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPBlobMutation) ResetField(name string) error {
	switch name {
	case hpblob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpblob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpblob.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case hpblob.FieldSourceURL:
		m.ResetSourceURL()
		return nil
	case hpblob.FieldSourceHTMLURL:
		m.ResetSourceHTMLURL()
		return nil
	case hpblob.FieldStatus:
		m.ResetStatus()
		return nil
	case hpblob.FieldStatusMessage:
		m.ResetStatusMessage()
		return nil
	case hpblob.FieldStatusErrorCount:
		m.ResetStatusErrorCount()
		return nil
	case hpblob.FieldType:
		m.ResetType()
		return nil
	case hpblob.FieldSubType:
		m.ResetSubType()
		return nil
	case hpblob.FieldWidth:
		m.ResetWidth()
		return nil
	case hpblob.FieldHeight:
		m.ResetHeight()
		return nil
	case hpblob.FieldSize:
		m.ResetSize()
		return nil
	case hpblob.FieldOwnerArtistID:
		m.ResetOwnerArtistID()
		return nil
	case hpblob.FieldOwnerMemberID:
		m.ResetOwnerMemberID()
		return nil
	case hpblob.FieldNumFaces:
		m.ResetNumFaces()
		return nil
	case hpblob.FieldFaces:
		m.ResetFaces()
		return nil
	case hpblob.FieldFaceRecognitionStatus:
		m.ResetFaceRecognitionStatus()
		return nil
	case hpblob.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case hpblob.FieldDurationSeconds:
		m.ResetDurationSeconds()
		return nil
	}
	return fmt.Errorf("unknown HPBlob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPBlobMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner_artist != nil {
		edges = append(edges, hpblob.EdgeOwnerArtist)
	}
	if m.owner_member != nil {
		edges = append(edges, hpblob.EdgeOwnerMember)
	}
	if m.ameblo_posts != nil {
		edges = append(edges, hpblob.EdgeAmebloPosts)
	}
	if m.ig_posts != nil {
		edges = append(edges, hpblob.EdgeIgPosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPBlobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpblob.EdgeOwnerArtist:
		if id := m.owner_artist; id != nil {
			return []ent.Value{*id}
		}
	case hpblob.EdgeOwnerMember:
		if id := m.owner_member; id != nil {
			return []ent.Value{*id}
		}
	case hpblob.EdgeAmebloPosts:
		ids := make([]ent.Value, 0, len(m.ameblo_posts))
		for id := range m.ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpblob.EdgeIgPosts:
		ids := make([]ent.Value, 0, len(m.ig_posts))
		for id := range m.ig_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPBlobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedameblo_posts != nil {
		edges = append(edges, hpblob.EdgeAmebloPosts)
	}
	if m.removedig_posts != nil {
		edges = append(edges, hpblob.EdgeIgPosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPBlobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpblob.EdgeAmebloPosts:
		ids := make([]ent.Value, 0, len(m.removedameblo_posts))
		for id := range m.removedameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpblob.EdgeIgPosts:
		ids := make([]ent.Value, 0, len(m.removedig_posts))
		for id := range m.removedig_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPBlobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner_artist {
		edges = append(edges, hpblob.EdgeOwnerArtist)
	}
	if m.clearedowner_member {
		edges = append(edges, hpblob.EdgeOwnerMember)
	}
	if m.clearedameblo_posts {
		edges = append(edges, hpblob.EdgeAmebloPosts)
	}
	if m.clearedig_posts {
		edges = append(edges, hpblob.EdgeIgPosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPBlobMutation) EdgeCleared(name string) bool {
	switch name {
	case hpblob.EdgeOwnerArtist:
		return m.clearedowner_artist
	case hpblob.EdgeOwnerMember:
		return m.clearedowner_member
	case hpblob.EdgeAmebloPosts:
		return m.clearedameblo_posts
	case hpblob.EdgeIgPosts:
		return m.clearedig_posts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPBlobMutation) ClearEdge(name string) error {
	switch name {
	case hpblob.EdgeOwnerArtist:
		m.ClearOwnerArtist()
		return nil
	case hpblob.EdgeOwnerMember:
		m.ClearOwnerMember()
		return nil
	}
	return fmt.Errorf("unknown HPBlob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPBlobMutation) ResetEdge(name string) error {
	switch name {
	case hpblob.EdgeOwnerArtist:
		m.ResetOwnerArtist()
		return nil
	case hpblob.EdgeOwnerMember:
		m.ResetOwnerMember()
		return nil
	case hpblob.EdgeAmebloPosts:
		m.ResetAmebloPosts()
		return nil
	case hpblob.EdgeIgPosts:
		m.ResetIgPosts()
		return nil
	}
	return fmt.Errorf("unknown HPBlob edge %s", name)
}

// HPElineupMallItemMutation represents an operation that mutates the HPElineupMallItem nodes in the graph.
type HPElineupMallItemMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	crawled_at                *time.Time
	error_count               *int
	adderror_count            *int
	manually_modified         **jsonfields.ManuallyModified
	last_error_message        *string
	recrawl_required          *bool
	created_at                *time.Time
	updated_at                *time.Time
	permalink                 *string
	name                      *string
	description               *string
	supplier                  *string
	price                     *int
	addprice                  *int
	is_limited_to_fc          *bool
	is_out_of_stock           *bool
	images                    *[]jsonfields.Media
	appendimages              []jsonfields.Media
	category                  *enums.HPElineupMallItemCategory
	order_start_at            *time.Time
	order_end_at              *time.Time
	clearedFields             map[string]struct{}
	tagged_artists            map[int]struct{}
	removedtagged_artists     map[int]struct{}
	clearedtagged_artists     bool
	tagged_members            map[int]struct{}
	removedtagged_members     map[int]struct{}
	clearedtagged_members     bool
	purchase_histories        map[int]struct{}
	removedpurchase_histories map[int]struct{}
	clearedpurchase_histories bool
	done                      bool
	oldValue                  func(context.Context) (*HPElineupMallItem, error)
	predicates                []predicate.HPElineupMallItem
}

var _ ent.Mutation = (*HPElineupMallItemMutation)(nil)

// hpelineupmallitemOption allows management of the mutation configuration using functional options.
type hpelineupmallitemOption func(*HPElineupMallItemMutation)

// newHPElineupMallItemMutation creates new mutation for the HPElineupMallItem entity.
func newHPElineupMallItemMutation(c config, op Op, opts ...hpelineupmallitemOption) *HPElineupMallItemMutation {
	m := &HPElineupMallItemMutation{
		config:        c,
		op:            op,
		typ:           TypeHPElineupMallItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPElineupMallItemID sets the ID field of the mutation.
func withHPElineupMallItemID(id int) hpelineupmallitemOption {
	return func(m *HPElineupMallItemMutation) {
		var (
			err   error
			once  sync.Once
			value *HPElineupMallItem
		)
		m.oldValue = func(ctx context.Context) (*HPElineupMallItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPElineupMallItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPElineupMallItem sets the old HPElineupMallItem of the mutation.
func withHPElineupMallItem(node *HPElineupMallItem) hpelineupmallitemOption {
	return func(m *HPElineupMallItemMutation) {
		m.oldValue = func(context.Context) (*HPElineupMallItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPElineupMallItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPElineupMallItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPElineupMallItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPElineupMallItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPElineupMallItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCrawledAt sets the "crawled_at" field.
func (m *HPElineupMallItemMutation) SetCrawledAt(t time.Time) {
	m.crawled_at = &t
}

// CrawledAt returns the value of the "crawled_at" field in the mutation.
func (m *HPElineupMallItemMutation) CrawledAt() (r time.Time, exists bool) {
	v := m.crawled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCrawledAt returns the old "crawled_at" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldCrawledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrawledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrawledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrawledAt: %w", err)
	}
	return oldValue.CrawledAt, nil
}

// ClearCrawledAt clears the value of the "crawled_at" field.
func (m *HPElineupMallItemMutation) ClearCrawledAt() {
	m.crawled_at = nil
	m.clearedFields[hpelineupmallitem.FieldCrawledAt] = struct{}{}
}

// CrawledAtCleared returns if the "crawled_at" field was cleared in this mutation.
func (m *HPElineupMallItemMutation) CrawledAtCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitem.FieldCrawledAt]
	return ok
}

// ResetCrawledAt resets all changes to the "crawled_at" field.
func (m *HPElineupMallItemMutation) ResetCrawledAt() {
	m.crawled_at = nil
	delete(m.clearedFields, hpelineupmallitem.FieldCrawledAt)
}

// SetErrorCount sets the "error_count" field.
func (m *HPElineupMallItemMutation) SetErrorCount(i int) {
	m.error_count = &i
	m.adderror_count = nil
}

// ErrorCount returns the value of the "error_count" field in the mutation.
func (m *HPElineupMallItemMutation) ErrorCount() (r int, exists bool) {
	v := m.error_count
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCount returns the old "error_count" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldErrorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCount: %w", err)
	}
	return oldValue.ErrorCount, nil
}

// AddErrorCount adds i to the "error_count" field.
func (m *HPElineupMallItemMutation) AddErrorCount(i int) {
	if m.adderror_count != nil {
		*m.adderror_count += i
	} else {
		m.adderror_count = &i
	}
}

// AddedErrorCount returns the value that was added to the "error_count" field in this mutation.
func (m *HPElineupMallItemMutation) AddedErrorCount() (r int, exists bool) {
	v := m.adderror_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrorCount resets all changes to the "error_count" field.
func (m *HPElineupMallItemMutation) ResetErrorCount() {
	m.error_count = nil
	m.adderror_count = nil
}

// SetManuallyModified sets the "manually_modified" field.
func (m *HPElineupMallItemMutation) SetManuallyModified(jm *jsonfields.ManuallyModified) {
	m.manually_modified = &jm
}

// ManuallyModified returns the value of the "manually_modified" field in the mutation.
func (m *HPElineupMallItemMutation) ManuallyModified() (r *jsonfields.ManuallyModified, exists bool) {
	v := m.manually_modified
	if v == nil {
		return
	}
	return *v, true
}

// OldManuallyModified returns the old "manually_modified" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldManuallyModified(ctx context.Context) (v *jsonfields.ManuallyModified, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManuallyModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManuallyModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManuallyModified: %w", err)
	}
	return oldValue.ManuallyModified, nil
}

// ClearManuallyModified clears the value of the "manually_modified" field.
func (m *HPElineupMallItemMutation) ClearManuallyModified() {
	m.manually_modified = nil
	m.clearedFields[hpelineupmallitem.FieldManuallyModified] = struct{}{}
}

// ManuallyModifiedCleared returns if the "manually_modified" field was cleared in this mutation.
func (m *HPElineupMallItemMutation) ManuallyModifiedCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitem.FieldManuallyModified]
	return ok
}

// ResetManuallyModified resets all changes to the "manually_modified" field.
func (m *HPElineupMallItemMutation) ResetManuallyModified() {
	m.manually_modified = nil
	delete(m.clearedFields, hpelineupmallitem.FieldManuallyModified)
}

// SetLastErrorMessage sets the "last_error_message" field.
func (m *HPElineupMallItemMutation) SetLastErrorMessage(s string) {
	m.last_error_message = &s
}

// LastErrorMessage returns the value of the "last_error_message" field in the mutation.
func (m *HPElineupMallItemMutation) LastErrorMessage() (r string, exists bool) {
	v := m.last_error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLastErrorMessage returns the old "last_error_message" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldLastErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastErrorMessage: %w", err)
	}
	return oldValue.LastErrorMessage, nil
}

// ClearLastErrorMessage clears the value of the "last_error_message" field.
func (m *HPElineupMallItemMutation) ClearLastErrorMessage() {
	m.last_error_message = nil
	m.clearedFields[hpelineupmallitem.FieldLastErrorMessage] = struct{}{}
}

// LastErrorMessageCleared returns if the "last_error_message" field was cleared in this mutation.
func (m *HPElineupMallItemMutation) LastErrorMessageCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitem.FieldLastErrorMessage]
	return ok
}

// ResetLastErrorMessage resets all changes to the "last_error_message" field.
func (m *HPElineupMallItemMutation) ResetLastErrorMessage() {
	m.last_error_message = nil
	delete(m.clearedFields, hpelineupmallitem.FieldLastErrorMessage)
}

// SetRecrawlRequired sets the "recrawl_required" field.
func (m *HPElineupMallItemMutation) SetRecrawlRequired(b bool) {
	m.recrawl_required = &b
}

// RecrawlRequired returns the value of the "recrawl_required" field in the mutation.
func (m *HPElineupMallItemMutation) RecrawlRequired() (r bool, exists bool) {
	v := m.recrawl_required
	if v == nil {
		return
	}
	return *v, true
}

// OldRecrawlRequired returns the old "recrawl_required" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldRecrawlRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecrawlRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecrawlRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecrawlRequired: %w", err)
	}
	return oldValue.RecrawlRequired, nil
}

// ClearRecrawlRequired clears the value of the "recrawl_required" field.
func (m *HPElineupMallItemMutation) ClearRecrawlRequired() {
	m.recrawl_required = nil
	m.clearedFields[hpelineupmallitem.FieldRecrawlRequired] = struct{}{}
}

// RecrawlRequiredCleared returns if the "recrawl_required" field was cleared in this mutation.
func (m *HPElineupMallItemMutation) RecrawlRequiredCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitem.FieldRecrawlRequired]
	return ok
}

// ResetRecrawlRequired resets all changes to the "recrawl_required" field.
func (m *HPElineupMallItemMutation) ResetRecrawlRequired() {
	m.recrawl_required = nil
	delete(m.clearedFields, hpelineupmallitem.FieldRecrawlRequired)
}

// SetCreatedAt sets the "created_at" field.
func (m *HPElineupMallItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPElineupMallItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPElineupMallItemMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpelineupmallitem.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPElineupMallItemMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitem.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPElineupMallItemMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpelineupmallitem.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPElineupMallItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPElineupMallItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPElineupMallItemMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpelineupmallitem.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPElineupMallItemMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitem.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPElineupMallItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpelineupmallitem.FieldUpdatedAt)
}

// SetPermalink sets the "permalink" field.
func (m *HPElineupMallItemMutation) SetPermalink(s string) {
	m.permalink = &s
}

// Permalink returns the value of the "permalink" field in the mutation.
func (m *HPElineupMallItemMutation) Permalink() (r string, exists bool) {
	v := m.permalink
	if v == nil {
		return
	}
	return *v, true
}

// OldPermalink returns the old "permalink" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldPermalink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermalink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermalink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermalink: %w", err)
	}
	return oldValue.Permalink, nil
}

// ResetPermalink resets all changes to the "permalink" field.
func (m *HPElineupMallItemMutation) ResetPermalink() {
	m.permalink = nil
}

// SetName sets the "name" field.
func (m *HPElineupMallItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HPElineupMallItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HPElineupMallItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HPElineupMallItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HPElineupMallItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HPElineupMallItemMutation) ResetDescription() {
	m.description = nil
}

// SetSupplier sets the "supplier" field.
func (m *HPElineupMallItemMutation) SetSupplier(s string) {
	m.supplier = &s
}

// Supplier returns the value of the "supplier" field in the mutation.
func (m *HPElineupMallItemMutation) Supplier() (r string, exists bool) {
	v := m.supplier
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplier returns the old "supplier" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldSupplier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplier: %w", err)
	}
	return oldValue.Supplier, nil
}

// ResetSupplier resets all changes to the "supplier" field.
func (m *HPElineupMallItemMutation) ResetSupplier() {
	m.supplier = nil
}

// SetPrice sets the "price" field.
func (m *HPElineupMallItemMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *HPElineupMallItemMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *HPElineupMallItemMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *HPElineupMallItemMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *HPElineupMallItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetIsLimitedToFc sets the "is_limited_to_fc" field.
func (m *HPElineupMallItemMutation) SetIsLimitedToFc(b bool) {
	m.is_limited_to_fc = &b
}

// IsLimitedToFc returns the value of the "is_limited_to_fc" field in the mutation.
func (m *HPElineupMallItemMutation) IsLimitedToFc() (r bool, exists bool) {
	v := m.is_limited_to_fc
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLimitedToFc returns the old "is_limited_to_fc" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldIsLimitedToFc(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLimitedToFc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLimitedToFc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLimitedToFc: %w", err)
	}
	return oldValue.IsLimitedToFc, nil
}

// ResetIsLimitedToFc resets all changes to the "is_limited_to_fc" field.
func (m *HPElineupMallItemMutation) ResetIsLimitedToFc() {
	m.is_limited_to_fc = nil
}

// SetIsOutOfStock sets the "is_out_of_stock" field.
func (m *HPElineupMallItemMutation) SetIsOutOfStock(b bool) {
	m.is_out_of_stock = &b
}

// IsOutOfStock returns the value of the "is_out_of_stock" field in the mutation.
func (m *HPElineupMallItemMutation) IsOutOfStock() (r bool, exists bool) {
	v := m.is_out_of_stock
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOutOfStock returns the old "is_out_of_stock" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldIsOutOfStock(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOutOfStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOutOfStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOutOfStock: %w", err)
	}
	return oldValue.IsOutOfStock, nil
}

// ResetIsOutOfStock resets all changes to the "is_out_of_stock" field.
func (m *HPElineupMallItemMutation) ResetIsOutOfStock() {
	m.is_out_of_stock = nil
}

// SetImages sets the "images" field.
func (m *HPElineupMallItemMutation) SetImages(j []jsonfields.Media) {
	m.images = &j
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *HPElineupMallItemMutation) Images() (r []jsonfields.Media, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldImages(ctx context.Context) (v []jsonfields.Media, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds j to the "images" field.
func (m *HPElineupMallItemMutation) AppendImages(j []jsonfields.Media) {
	m.appendimages = append(m.appendimages, j...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *HPElineupMallItemMutation) AppendedImages() ([]jsonfields.Media, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ResetImages resets all changes to the "images" field.
func (m *HPElineupMallItemMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
}

// SetCategory sets the "category" field.
func (m *HPElineupMallItemMutation) SetCategory(eemic enums.HPElineupMallItemCategory) {
	m.category = &eemic
}

// Category returns the value of the "category" field in the mutation.
func (m *HPElineupMallItemMutation) Category() (r enums.HPElineupMallItemCategory, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldCategory(ctx context.Context) (v enums.HPElineupMallItemCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *HPElineupMallItemMutation) ResetCategory() {
	m.category = nil
}

// SetOrderStartAt sets the "order_start_at" field.
func (m *HPElineupMallItemMutation) SetOrderStartAt(t time.Time) {
	m.order_start_at = &t
}

// OrderStartAt returns the value of the "order_start_at" field in the mutation.
func (m *HPElineupMallItemMutation) OrderStartAt() (r time.Time, exists bool) {
	v := m.order_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStartAt returns the old "order_start_at" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldOrderStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStartAt: %w", err)
	}
	return oldValue.OrderStartAt, nil
}

// ClearOrderStartAt clears the value of the "order_start_at" field.
func (m *HPElineupMallItemMutation) ClearOrderStartAt() {
	m.order_start_at = nil
	m.clearedFields[hpelineupmallitem.FieldOrderStartAt] = struct{}{}
}

// OrderStartAtCleared returns if the "order_start_at" field was cleared in this mutation.
func (m *HPElineupMallItemMutation) OrderStartAtCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitem.FieldOrderStartAt]
	return ok
}

// ResetOrderStartAt resets all changes to the "order_start_at" field.
func (m *HPElineupMallItemMutation) ResetOrderStartAt() {
	m.order_start_at = nil
	delete(m.clearedFields, hpelineupmallitem.FieldOrderStartAt)
}

// SetOrderEndAt sets the "order_end_at" field.
func (m *HPElineupMallItemMutation) SetOrderEndAt(t time.Time) {
	m.order_end_at = &t
}

// OrderEndAt returns the value of the "order_end_at" field in the mutation.
func (m *HPElineupMallItemMutation) OrderEndAt() (r time.Time, exists bool) {
	v := m.order_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderEndAt returns the old "order_end_at" field's value of the HPElineupMallItem entity.
// If the HPElineupMallItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemMutation) OldOrderEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderEndAt: %w", err)
	}
	return oldValue.OrderEndAt, nil
}

// ClearOrderEndAt clears the value of the "order_end_at" field.
func (m *HPElineupMallItemMutation) ClearOrderEndAt() {
	m.order_end_at = nil
	m.clearedFields[hpelineupmallitem.FieldOrderEndAt] = struct{}{}
}

// OrderEndAtCleared returns if the "order_end_at" field was cleared in this mutation.
func (m *HPElineupMallItemMutation) OrderEndAtCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitem.FieldOrderEndAt]
	return ok
}

// ResetOrderEndAt resets all changes to the "order_end_at" field.
func (m *HPElineupMallItemMutation) ResetOrderEndAt() {
	m.order_end_at = nil
	delete(m.clearedFields, hpelineupmallitem.FieldOrderEndAt)
}

// AddTaggedArtistIDs adds the "tagged_artists" edge to the HPArtist entity by ids.
func (m *HPElineupMallItemMutation) AddTaggedArtistIDs(ids ...int) {
	if m.tagged_artists == nil {
		m.tagged_artists = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_artists[ids[i]] = struct{}{}
	}
}

// ClearTaggedArtists clears the "tagged_artists" edge to the HPArtist entity.
func (m *HPElineupMallItemMutation) ClearTaggedArtists() {
	m.clearedtagged_artists = true
}

// TaggedArtistsCleared reports if the "tagged_artists" edge to the HPArtist entity was cleared.
func (m *HPElineupMallItemMutation) TaggedArtistsCleared() bool {
	return m.clearedtagged_artists
}

// RemoveTaggedArtistIDs removes the "tagged_artists" edge to the HPArtist entity by IDs.
func (m *HPElineupMallItemMutation) RemoveTaggedArtistIDs(ids ...int) {
	if m.removedtagged_artists == nil {
		m.removedtagged_artists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_artists, ids[i])
		m.removedtagged_artists[ids[i]] = struct{}{}
	}
}

// RemovedTaggedArtists returns the removed IDs of the "tagged_artists" edge to the HPArtist entity.
func (m *HPElineupMallItemMutation) RemovedTaggedArtistsIDs() (ids []int) {
	for id := range m.removedtagged_artists {
		ids = append(ids, id)
	}
	return
}

// TaggedArtistsIDs returns the "tagged_artists" edge IDs in the mutation.
func (m *HPElineupMallItemMutation) TaggedArtistsIDs() (ids []int) {
	for id := range m.tagged_artists {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedArtists resets all changes to the "tagged_artists" edge.
func (m *HPElineupMallItemMutation) ResetTaggedArtists() {
	m.tagged_artists = nil
	m.clearedtagged_artists = false
	m.removedtagged_artists = nil
}

// AddTaggedMemberIDs adds the "tagged_members" edge to the HPMember entity by ids.
func (m *HPElineupMallItemMutation) AddTaggedMemberIDs(ids ...int) {
	if m.tagged_members == nil {
		m.tagged_members = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_members[ids[i]] = struct{}{}
	}
}

// ClearTaggedMembers clears the "tagged_members" edge to the HPMember entity.
func (m *HPElineupMallItemMutation) ClearTaggedMembers() {
	m.clearedtagged_members = true
}

// TaggedMembersCleared reports if the "tagged_members" edge to the HPMember entity was cleared.
func (m *HPElineupMallItemMutation) TaggedMembersCleared() bool {
	return m.clearedtagged_members
}

// RemoveTaggedMemberIDs removes the "tagged_members" edge to the HPMember entity by IDs.
func (m *HPElineupMallItemMutation) RemoveTaggedMemberIDs(ids ...int) {
	if m.removedtagged_members == nil {
		m.removedtagged_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_members, ids[i])
		m.removedtagged_members[ids[i]] = struct{}{}
	}
}

// RemovedTaggedMembers returns the removed IDs of the "tagged_members" edge to the HPMember entity.
func (m *HPElineupMallItemMutation) RemovedTaggedMembersIDs() (ids []int) {
	for id := range m.removedtagged_members {
		ids = append(ids, id)
	}
	return
}

// TaggedMembersIDs returns the "tagged_members" edge IDs in the mutation.
func (m *HPElineupMallItemMutation) TaggedMembersIDs() (ids []int) {
	for id := range m.tagged_members {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedMembers resets all changes to the "tagged_members" edge.
func (m *HPElineupMallItemMutation) ResetTaggedMembers() {
	m.tagged_members = nil
	m.clearedtagged_members = false
	m.removedtagged_members = nil
}

// AddPurchaseHistoryIDs adds the "purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity by ids.
func (m *HPElineupMallItemMutation) AddPurchaseHistoryIDs(ids ...int) {
	if m.purchase_histories == nil {
		m.purchase_histories = make(map[int]struct{})
	}
	for i := range ids {
		m.purchase_histories[ids[i]] = struct{}{}
	}
}

// ClearPurchaseHistories clears the "purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity.
func (m *HPElineupMallItemMutation) ClearPurchaseHistories() {
	m.clearedpurchase_histories = true
}

// PurchaseHistoriesCleared reports if the "purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity was cleared.
func (m *HPElineupMallItemMutation) PurchaseHistoriesCleared() bool {
	return m.clearedpurchase_histories
}

// RemovePurchaseHistoryIDs removes the "purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity by IDs.
func (m *HPElineupMallItemMutation) RemovePurchaseHistoryIDs(ids ...int) {
	if m.removedpurchase_histories == nil {
		m.removedpurchase_histories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.purchase_histories, ids[i])
		m.removedpurchase_histories[ids[i]] = struct{}{}
	}
}

// RemovedPurchaseHistories returns the removed IDs of the "purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity.
func (m *HPElineupMallItemMutation) RemovedPurchaseHistoriesIDs() (ids []int) {
	for id := range m.removedpurchase_histories {
		ids = append(ids, id)
	}
	return
}

// PurchaseHistoriesIDs returns the "purchase_histories" edge IDs in the mutation.
func (m *HPElineupMallItemMutation) PurchaseHistoriesIDs() (ids []int) {
	for id := range m.purchase_histories {
		ids = append(ids, id)
	}
	return
}

// ResetPurchaseHistories resets all changes to the "purchase_histories" edge.
func (m *HPElineupMallItemMutation) ResetPurchaseHistories() {
	m.purchase_histories = nil
	m.clearedpurchase_histories = false
	m.removedpurchase_histories = nil
}

// Where appends a list predicates to the HPElineupMallItemMutation builder.
func (m *HPElineupMallItemMutation) Where(ps ...predicate.HPElineupMallItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPElineupMallItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPElineupMallItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPElineupMallItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPElineupMallItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPElineupMallItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPElineupMallItem).
func (m *HPElineupMallItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPElineupMallItemMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.crawled_at != nil {
		fields = append(fields, hpelineupmallitem.FieldCrawledAt)
	}
	if m.error_count != nil {
		fields = append(fields, hpelineupmallitem.FieldErrorCount)
	}
	if m.manually_modified != nil {
		fields = append(fields, hpelineupmallitem.FieldManuallyModified)
	}
	if m.last_error_message != nil {
		fields = append(fields, hpelineupmallitem.FieldLastErrorMessage)
	}
	if m.recrawl_required != nil {
		fields = append(fields, hpelineupmallitem.FieldRecrawlRequired)
	}
	if m.created_at != nil {
		fields = append(fields, hpelineupmallitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpelineupmallitem.FieldUpdatedAt)
	}
	if m.permalink != nil {
		fields = append(fields, hpelineupmallitem.FieldPermalink)
	}
	if m.name != nil {
		fields = append(fields, hpelineupmallitem.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hpelineupmallitem.FieldDescription)
	}
	if m.supplier != nil {
		fields = append(fields, hpelineupmallitem.FieldSupplier)
	}
	if m.price != nil {
		fields = append(fields, hpelineupmallitem.FieldPrice)
	}
	if m.is_limited_to_fc != nil {
		fields = append(fields, hpelineupmallitem.FieldIsLimitedToFc)
	}
	if m.is_out_of_stock != nil {
		fields = append(fields, hpelineupmallitem.FieldIsOutOfStock)
	}
	if m.images != nil {
		fields = append(fields, hpelineupmallitem.FieldImages)
	}
	if m.category != nil {
		fields = append(fields, hpelineupmallitem.FieldCategory)
	}
	if m.order_start_at != nil {
		fields = append(fields, hpelineupmallitem.FieldOrderStartAt)
	}
	if m.order_end_at != nil {
		fields = append(fields, hpelineupmallitem.FieldOrderEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPElineupMallItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpelineupmallitem.FieldCrawledAt:
		return m.CrawledAt()
	case hpelineupmallitem.FieldErrorCount:
		return m.ErrorCount()
	case hpelineupmallitem.FieldManuallyModified:
		return m.ManuallyModified()
	case hpelineupmallitem.FieldLastErrorMessage:
		return m.LastErrorMessage()
	case hpelineupmallitem.FieldRecrawlRequired:
		return m.RecrawlRequired()
	case hpelineupmallitem.FieldCreatedAt:
		return m.CreatedAt()
	case hpelineupmallitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpelineupmallitem.FieldPermalink:
		return m.Permalink()
	case hpelineupmallitem.FieldName:
		return m.Name()
	case hpelineupmallitem.FieldDescription:
		return m.Description()
	case hpelineupmallitem.FieldSupplier:
		return m.Supplier()
	case hpelineupmallitem.FieldPrice:
		return m.Price()
	case hpelineupmallitem.FieldIsLimitedToFc:
		return m.IsLimitedToFc()
	case hpelineupmallitem.FieldIsOutOfStock:
		return m.IsOutOfStock()
	case hpelineupmallitem.FieldImages:
		return m.Images()
	case hpelineupmallitem.FieldCategory:
		return m.Category()
	case hpelineupmallitem.FieldOrderStartAt:
		return m.OrderStartAt()
	case hpelineupmallitem.FieldOrderEndAt:
		return m.OrderEndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPElineupMallItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpelineupmallitem.FieldCrawledAt:
		return m.OldCrawledAt(ctx)
	case hpelineupmallitem.FieldErrorCount:
		return m.OldErrorCount(ctx)
	case hpelineupmallitem.FieldManuallyModified:
		return m.OldManuallyModified(ctx)
	case hpelineupmallitem.FieldLastErrorMessage:
		return m.OldLastErrorMessage(ctx)
	case hpelineupmallitem.FieldRecrawlRequired:
		return m.OldRecrawlRequired(ctx)
	case hpelineupmallitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpelineupmallitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpelineupmallitem.FieldPermalink:
		return m.OldPermalink(ctx)
	case hpelineupmallitem.FieldName:
		return m.OldName(ctx)
	case hpelineupmallitem.FieldDescription:
		return m.OldDescription(ctx)
	case hpelineupmallitem.FieldSupplier:
		return m.OldSupplier(ctx)
	case hpelineupmallitem.FieldPrice:
		return m.OldPrice(ctx)
	case hpelineupmallitem.FieldIsLimitedToFc:
		return m.OldIsLimitedToFc(ctx)
	case hpelineupmallitem.FieldIsOutOfStock:
		return m.OldIsOutOfStock(ctx)
	case hpelineupmallitem.FieldImages:
		return m.OldImages(ctx)
	case hpelineupmallitem.FieldCategory:
		return m.OldCategory(ctx)
	case hpelineupmallitem.FieldOrderStartAt:
		return m.OldOrderStartAt(ctx)
	case hpelineupmallitem.FieldOrderEndAt:
		return m.OldOrderEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown HPElineupMallItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPElineupMallItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpelineupmallitem.FieldCrawledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrawledAt(v)
		return nil
	case hpelineupmallitem.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCount(v)
		return nil
	case hpelineupmallitem.FieldManuallyModified:
		v, ok := value.(*jsonfields.ManuallyModified)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManuallyModified(v)
		return nil
	case hpelineupmallitem.FieldLastErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastErrorMessage(v)
		return nil
	case hpelineupmallitem.FieldRecrawlRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecrawlRequired(v)
		return nil
	case hpelineupmallitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpelineupmallitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpelineupmallitem.FieldPermalink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermalink(v)
		return nil
	case hpelineupmallitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hpelineupmallitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hpelineupmallitem.FieldSupplier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplier(v)
		return nil
	case hpelineupmallitem.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case hpelineupmallitem.FieldIsLimitedToFc:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLimitedToFc(v)
		return nil
	case hpelineupmallitem.FieldIsOutOfStock:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOutOfStock(v)
		return nil
	case hpelineupmallitem.FieldImages:
		v, ok := value.([]jsonfields.Media)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case hpelineupmallitem.FieldCategory:
		v, ok := value.(enums.HPElineupMallItemCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case hpelineupmallitem.FieldOrderStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStartAt(v)
		return nil
	case hpelineupmallitem.FieldOrderEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPElineupMallItemMutation) AddedFields() []string {
	var fields []string
	if m.adderror_count != nil {
		fields = append(fields, hpelineupmallitem.FieldErrorCount)
	}
	if m.addprice != nil {
		fields = append(fields, hpelineupmallitem.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPElineupMallItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpelineupmallitem.FieldErrorCount:
		return m.AddedErrorCount()
	case hpelineupmallitem.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPElineupMallItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpelineupmallitem.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCount(v)
		return nil
	case hpelineupmallitem.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPElineupMallItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpelineupmallitem.FieldCrawledAt) {
		fields = append(fields, hpelineupmallitem.FieldCrawledAt)
	}
	if m.FieldCleared(hpelineupmallitem.FieldManuallyModified) {
		fields = append(fields, hpelineupmallitem.FieldManuallyModified)
	}
	if m.FieldCleared(hpelineupmallitem.FieldLastErrorMessage) {
		fields = append(fields, hpelineupmallitem.FieldLastErrorMessage)
	}
	if m.FieldCleared(hpelineupmallitem.FieldRecrawlRequired) {
		fields = append(fields, hpelineupmallitem.FieldRecrawlRequired)
	}
	if m.FieldCleared(hpelineupmallitem.FieldCreatedAt) {
		fields = append(fields, hpelineupmallitem.FieldCreatedAt)
	}
	if m.FieldCleared(hpelineupmallitem.FieldUpdatedAt) {
		fields = append(fields, hpelineupmallitem.FieldUpdatedAt)
	}
	if m.FieldCleared(hpelineupmallitem.FieldOrderStartAt) {
		fields = append(fields, hpelineupmallitem.FieldOrderStartAt)
	}
	if m.FieldCleared(hpelineupmallitem.FieldOrderEndAt) {
		fields = append(fields, hpelineupmallitem.FieldOrderEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPElineupMallItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPElineupMallItemMutation) ClearField(name string) error {
	switch name {
	case hpelineupmallitem.FieldCrawledAt:
		m.ClearCrawledAt()
		return nil
	case hpelineupmallitem.FieldManuallyModified:
		m.ClearManuallyModified()
		return nil
	case hpelineupmallitem.FieldLastErrorMessage:
		m.ClearLastErrorMessage()
		return nil
	case hpelineupmallitem.FieldRecrawlRequired:
		m.ClearRecrawlRequired()
		return nil
	case hpelineupmallitem.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpelineupmallitem.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpelineupmallitem.FieldOrderStartAt:
		m.ClearOrderStartAt()
		return nil
	case hpelineupmallitem.FieldOrderEndAt:
		m.ClearOrderEndAt()
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPElineupMallItemMutation) ResetField(name string) error {
	switch name {
	case hpelineupmallitem.FieldCrawledAt:
		m.ResetCrawledAt()
		return nil
	case hpelineupmallitem.FieldErrorCount:
		m.ResetErrorCount()
		return nil
	case hpelineupmallitem.FieldManuallyModified:
		m.ResetManuallyModified()
		return nil
	case hpelineupmallitem.FieldLastErrorMessage:
		m.ResetLastErrorMessage()
		return nil
	case hpelineupmallitem.FieldRecrawlRequired:
		m.ResetRecrawlRequired()
		return nil
	case hpelineupmallitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpelineupmallitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpelineupmallitem.FieldPermalink:
		m.ResetPermalink()
		return nil
	case hpelineupmallitem.FieldName:
		m.ResetName()
		return nil
	case hpelineupmallitem.FieldDescription:
		m.ResetDescription()
		return nil
	case hpelineupmallitem.FieldSupplier:
		m.ResetSupplier()
		return nil
	case hpelineupmallitem.FieldPrice:
		m.ResetPrice()
		return nil
	case hpelineupmallitem.FieldIsLimitedToFc:
		m.ResetIsLimitedToFc()
		return nil
	case hpelineupmallitem.FieldIsOutOfStock:
		m.ResetIsOutOfStock()
		return nil
	case hpelineupmallitem.FieldImages:
		m.ResetImages()
		return nil
	case hpelineupmallitem.FieldCategory:
		m.ResetCategory()
		return nil
	case hpelineupmallitem.FieldOrderStartAt:
		m.ResetOrderStartAt()
		return nil
	case hpelineupmallitem.FieldOrderEndAt:
		m.ResetOrderEndAt()
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPElineupMallItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tagged_artists != nil {
		edges = append(edges, hpelineupmallitem.EdgeTaggedArtists)
	}
	if m.tagged_members != nil {
		edges = append(edges, hpelineupmallitem.EdgeTaggedMembers)
	}
	if m.purchase_histories != nil {
		edges = append(edges, hpelineupmallitem.EdgePurchaseHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPElineupMallItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpelineupmallitem.EdgeTaggedArtists:
		ids := make([]ent.Value, 0, len(m.tagged_artists))
		for id := range m.tagged_artists {
			ids = append(ids, id)
		}
		return ids
	case hpelineupmallitem.EdgeTaggedMembers:
		ids := make([]ent.Value, 0, len(m.tagged_members))
		for id := range m.tagged_members {
			ids = append(ids, id)
		}
		return ids
	case hpelineupmallitem.EdgePurchaseHistories:
		ids := make([]ent.Value, 0, len(m.purchase_histories))
		for id := range m.purchase_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPElineupMallItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtagged_artists != nil {
		edges = append(edges, hpelineupmallitem.EdgeTaggedArtists)
	}
	if m.removedtagged_members != nil {
		edges = append(edges, hpelineupmallitem.EdgeTaggedMembers)
	}
	if m.removedpurchase_histories != nil {
		edges = append(edges, hpelineupmallitem.EdgePurchaseHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPElineupMallItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpelineupmallitem.EdgeTaggedArtists:
		ids := make([]ent.Value, 0, len(m.removedtagged_artists))
		for id := range m.removedtagged_artists {
			ids = append(ids, id)
		}
		return ids
	case hpelineupmallitem.EdgeTaggedMembers:
		ids := make([]ent.Value, 0, len(m.removedtagged_members))
		for id := range m.removedtagged_members {
			ids = append(ids, id)
		}
		return ids
	case hpelineupmallitem.EdgePurchaseHistories:
		ids := make([]ent.Value, 0, len(m.removedpurchase_histories))
		for id := range m.removedpurchase_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPElineupMallItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtagged_artists {
		edges = append(edges, hpelineupmallitem.EdgeTaggedArtists)
	}
	if m.clearedtagged_members {
		edges = append(edges, hpelineupmallitem.EdgeTaggedMembers)
	}
	if m.clearedpurchase_histories {
		edges = append(edges, hpelineupmallitem.EdgePurchaseHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPElineupMallItemMutation) EdgeCleared(name string) bool {
	switch name {
	case hpelineupmallitem.EdgeTaggedArtists:
		return m.clearedtagged_artists
	case hpelineupmallitem.EdgeTaggedMembers:
		return m.clearedtagged_members
	case hpelineupmallitem.EdgePurchaseHistories:
		return m.clearedpurchase_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPElineupMallItemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HPElineupMallItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPElineupMallItemMutation) ResetEdge(name string) error {
	switch name {
	case hpelineupmallitem.EdgeTaggedArtists:
		m.ResetTaggedArtists()
		return nil
	case hpelineupmallitem.EdgeTaggedMembers:
		m.ResetTaggedMembers()
		return nil
	case hpelineupmallitem.EdgePurchaseHistories:
		m.ResetPurchaseHistories()
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItem edge %s", name)
}

// HPElineupMallItemPurchaseHistoryMutation represents an operation that mutates the HPElineupMallItemPurchaseHistory nodes in the graph.
type HPElineupMallItemPurchaseHistoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	order_id                 *string
	num                      *int
	addnum                   *int
	price                    *int
	addprice                 *int
	ordered_at               *time.Time
	permalink                *string
	name                     *string
	clearedFields            map[string]struct{}
	elineup_mall_item        *int
	clearedelineup_mall_item bool
	owner                    *int
	clearedowner             bool
	done                     bool
	oldValue                 func(context.Context) (*HPElineupMallItemPurchaseHistory, error)
	predicates               []predicate.HPElineupMallItemPurchaseHistory
}

var _ ent.Mutation = (*HPElineupMallItemPurchaseHistoryMutation)(nil)

// hpelineupmallitempurchasehistoryOption allows management of the mutation configuration using functional options.
type hpelineupmallitempurchasehistoryOption func(*HPElineupMallItemPurchaseHistoryMutation)

// newHPElineupMallItemPurchaseHistoryMutation creates new mutation for the HPElineupMallItemPurchaseHistory entity.
func newHPElineupMallItemPurchaseHistoryMutation(c config, op Op, opts ...hpelineupmallitempurchasehistoryOption) *HPElineupMallItemPurchaseHistoryMutation {
	m := &HPElineupMallItemPurchaseHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHPElineupMallItemPurchaseHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPElineupMallItemPurchaseHistoryID sets the ID field of the mutation.
func withHPElineupMallItemPurchaseHistoryID(id int) hpelineupmallitempurchasehistoryOption {
	return func(m *HPElineupMallItemPurchaseHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *HPElineupMallItemPurchaseHistory
		)
		m.oldValue = func(ctx context.Context) (*HPElineupMallItemPurchaseHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPElineupMallItemPurchaseHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPElineupMallItemPurchaseHistory sets the old HPElineupMallItemPurchaseHistory of the mutation.
func withHPElineupMallItemPurchaseHistory(node *HPElineupMallItemPurchaseHistory) hpelineupmallitempurchasehistoryOption {
	return func(m *HPElineupMallItemPurchaseHistoryMutation) {
		m.oldValue = func(context.Context) (*HPElineupMallItemPurchaseHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPElineupMallItemPurchaseHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPElineupMallItemPurchaseHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPElineupMallItemPurchaseHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPElineupMallItemPurchaseHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpelineupmallitempurchasehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitempurchasehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpelineupmallitempurchasehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpelineupmallitempurchasehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitempurchasehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpelineupmallitempurchasehistory.FieldUpdatedAt)
}

// SetOrderID sets the "order_id" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetOrderID(s string) {
	m.order_id = &s
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) OrderID() (r string, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetOrderID() {
	m.order_id = nil
}

// SetNum sets the "num" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetNum(i int) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) Num() (r int, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddNum(i int) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetPrice sets the "price" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetOrderedAt sets the "ordered_at" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetOrderedAt(t time.Time) {
	m.ordered_at = &t
}

// OrderedAt returns the value of the "ordered_at" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) OrderedAt() (r time.Time, exists bool) {
	v := m.ordered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderedAt returns the old "ordered_at" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldOrderedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderedAt: %w", err)
	}
	return oldValue.OrderedAt, nil
}

// ResetOrderedAt resets all changes to the "ordered_at" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetOrderedAt() {
	m.ordered_at = nil
}

// SetPermalink sets the "permalink" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetPermalink(s string) {
	m.permalink = &s
}

// Permalink returns the value of the "permalink" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) Permalink() (r string, exists bool) {
	v := m.permalink
	if v == nil {
		return
	}
	return *v, true
}

// OldPermalink returns the old "permalink" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldPermalink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermalink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermalink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermalink: %w", err)
	}
	return oldValue.Permalink, nil
}

// ResetPermalink resets all changes to the "permalink" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetPermalink() {
	m.permalink = nil
}

// SetName sets the "name" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetName() {
	m.name = nil
}

// SetPurchasedItemID sets the "purchased_item_id" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetPurchasedItemID(i int) {
	m.elineup_mall_item = &i
}

// PurchasedItemID returns the value of the "purchased_item_id" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) PurchasedItemID() (r int, exists bool) {
	v := m.elineup_mall_item
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchasedItemID returns the old "purchased_item_id" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldPurchasedItemID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchasedItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchasedItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchasedItemID: %w", err)
	}
	return oldValue.PurchasedItemID, nil
}

// ClearPurchasedItemID clears the value of the "purchased_item_id" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearPurchasedItemID() {
	m.elineup_mall_item = nil
	m.clearedFields[hpelineupmallitempurchasehistory.FieldPurchasedItemID] = struct{}{}
}

// PurchasedItemIDCleared returns if the "purchased_item_id" field was cleared in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) PurchasedItemIDCleared() bool {
	_, ok := m.clearedFields[hpelineupmallitempurchasehistory.FieldPurchasedItemID]
	return ok
}

// ResetPurchasedItemID resets all changes to the "purchased_item_id" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetPurchasedItemID() {
	m.elineup_mall_item = nil
	delete(m.clearedFields, hpelineupmallitempurchasehistory.FieldPurchasedItemID)
}

// SetOwnerUserID sets the "owner_user_id" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetOwnerUserID(i int) {
	m.owner = &i
}

// OwnerUserID returns the value of the "owner_user_id" field in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) OwnerUserID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerUserID returns the old "owner_user_id" field's value of the HPElineupMallItemPurchaseHistory entity.
// If the HPElineupMallItemPurchaseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldOwnerUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerUserID: %w", err)
	}
	return oldValue.OwnerUserID, nil
}

// ResetOwnerUserID resets all changes to the "owner_user_id" field.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetOwnerUserID() {
	m.owner = nil
}

// SetElineupMallItemID sets the "elineup_mall_item" edge to the HPElineupMallItem entity by id.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetElineupMallItemID(id int) {
	m.elineup_mall_item = &id
}

// ClearElineupMallItem clears the "elineup_mall_item" edge to the HPElineupMallItem entity.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearElineupMallItem() {
	m.clearedelineup_mall_item = true
}

// ElineupMallItemCleared reports if the "elineup_mall_item" edge to the HPElineupMallItem entity was cleared.
func (m *HPElineupMallItemPurchaseHistoryMutation) ElineupMallItemCleared() bool {
	return m.PurchasedItemIDCleared() || m.clearedelineup_mall_item
}

// ElineupMallItemID returns the "elineup_mall_item" edge ID in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) ElineupMallItemID() (id int, exists bool) {
	if m.elineup_mall_item != nil {
		return *m.elineup_mall_item, true
	}
	return
}

// ElineupMallItemIDs returns the "elineup_mall_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElineupMallItemID instead. It exists only for internal usage by the builders.
func (m *HPElineupMallItemPurchaseHistoryMutation) ElineupMallItemIDs() (ids []int) {
	if id := m.elineup_mall_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElineupMallItem resets all changes to the "elineup_mall_item" edge.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetElineupMallItem() {
	m.elineup_mall_item = nil
	m.clearedelineup_mall_item = false
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *HPElineupMallItemPurchaseHistoryMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *HPElineupMallItemPurchaseHistoryMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the HPElineupMallItemPurchaseHistoryMutation builder.
func (m *HPElineupMallItemPurchaseHistoryMutation) Where(ps ...predicate.HPElineupMallItemPurchaseHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPElineupMallItemPurchaseHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPElineupMallItemPurchaseHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPElineupMallItemPurchaseHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPElineupMallItemPurchaseHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPElineupMallItemPurchaseHistory).
func (m *HPElineupMallItemPurchaseHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPElineupMallItemPurchaseHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldUpdatedAt)
	}
	if m.order_id != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldOrderID)
	}
	if m.num != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldNum)
	}
	if m.price != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldPrice)
	}
	if m.ordered_at != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldOrderedAt)
	}
	if m.permalink != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldPermalink)
	}
	if m.name != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldName)
	}
	if m.elineup_mall_item != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldPurchasedItemID)
	}
	if m.owner != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldOwnerUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPElineupMallItemPurchaseHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpelineupmallitempurchasehistory.FieldCreatedAt:
		return m.CreatedAt()
	case hpelineupmallitempurchasehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpelineupmallitempurchasehistory.FieldOrderID:
		return m.OrderID()
	case hpelineupmallitempurchasehistory.FieldNum:
		return m.Num()
	case hpelineupmallitempurchasehistory.FieldPrice:
		return m.Price()
	case hpelineupmallitempurchasehistory.FieldOrderedAt:
		return m.OrderedAt()
	case hpelineupmallitempurchasehistory.FieldPermalink:
		return m.Permalink()
	case hpelineupmallitempurchasehistory.FieldName:
		return m.Name()
	case hpelineupmallitempurchasehistory.FieldPurchasedItemID:
		return m.PurchasedItemID()
	case hpelineupmallitempurchasehistory.FieldOwnerUserID:
		return m.OwnerUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPElineupMallItemPurchaseHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpelineupmallitempurchasehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpelineupmallitempurchasehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpelineupmallitempurchasehistory.FieldOrderID:
		return m.OldOrderID(ctx)
	case hpelineupmallitempurchasehistory.FieldNum:
		return m.OldNum(ctx)
	case hpelineupmallitempurchasehistory.FieldPrice:
		return m.OldPrice(ctx)
	case hpelineupmallitempurchasehistory.FieldOrderedAt:
		return m.OldOrderedAt(ctx)
	case hpelineupmallitempurchasehistory.FieldPermalink:
		return m.OldPermalink(ctx)
	case hpelineupmallitempurchasehistory.FieldName:
		return m.OldName(ctx)
	case hpelineupmallitempurchasehistory.FieldPurchasedItemID:
		return m.OldPurchasedItemID(ctx)
	case hpelineupmallitempurchasehistory.FieldOwnerUserID:
		return m.OldOwnerUserID(ctx)
	}
	return nil, fmt.Errorf("unknown HPElineupMallItemPurchaseHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPElineupMallItemPurchaseHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpelineupmallitempurchasehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldOrderedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderedAt(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldPermalink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermalink(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldPurchasedItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchasedItemID(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItemPurchaseHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addnum != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldNum)
	}
	if m.addprice != nil {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpelineupmallitempurchasehistory.FieldNum:
		return m.AddedNum()
	case hpelineupmallitempurchasehistory.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpelineupmallitempurchasehistory.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	case hpelineupmallitempurchasehistory.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItemPurchaseHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpelineupmallitempurchasehistory.FieldCreatedAt) {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldCreatedAt)
	}
	if m.FieldCleared(hpelineupmallitempurchasehistory.FieldUpdatedAt) {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(hpelineupmallitempurchasehistory.FieldPurchasedItemID) {
		fields = append(fields, hpelineupmallitempurchasehistory.FieldPurchasedItemID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearField(name string) error {
	switch name {
	case hpelineupmallitempurchasehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpelineupmallitempurchasehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpelineupmallitempurchasehistory.FieldPurchasedItemID:
		m.ClearPurchasedItemID()
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItemPurchaseHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetField(name string) error {
	switch name {
	case hpelineupmallitempurchasehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpelineupmallitempurchasehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpelineupmallitempurchasehistory.FieldOrderID:
		m.ResetOrderID()
		return nil
	case hpelineupmallitempurchasehistory.FieldNum:
		m.ResetNum()
		return nil
	case hpelineupmallitempurchasehistory.FieldPrice:
		m.ResetPrice()
		return nil
	case hpelineupmallitempurchasehistory.FieldOrderedAt:
		m.ResetOrderedAt()
		return nil
	case hpelineupmallitempurchasehistory.FieldPermalink:
		m.ResetPermalink()
		return nil
	case hpelineupmallitempurchasehistory.FieldName:
		m.ResetName()
		return nil
	case hpelineupmallitempurchasehistory.FieldPurchasedItemID:
		m.ResetPurchasedItemID()
		return nil
	case hpelineupmallitempurchasehistory.FieldOwnerUserID:
		m.ResetOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItemPurchaseHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.elineup_mall_item != nil {
		edges = append(edges, hpelineupmallitempurchasehistory.EdgeElineupMallItem)
	}
	if m.owner != nil {
		edges = append(edges, hpelineupmallitempurchasehistory.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpelineupmallitempurchasehistory.EdgeElineupMallItem:
		if id := m.elineup_mall_item; id != nil {
			return []ent.Value{*id}
		}
	case hpelineupmallitempurchasehistory.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedelineup_mall_item {
		edges = append(edges, hpelineupmallitempurchasehistory.EdgeElineupMallItem)
	}
	if m.clearedowner {
		edges = append(edges, hpelineupmallitempurchasehistory.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPElineupMallItemPurchaseHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case hpelineupmallitempurchasehistory.EdgeElineupMallItem:
		return m.clearedelineup_mall_item
	case hpelineupmallitempurchasehistory.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPElineupMallItemPurchaseHistoryMutation) ClearEdge(name string) error {
	switch name {
	case hpelineupmallitempurchasehistory.EdgeElineupMallItem:
		m.ClearElineupMallItem()
		return nil
	case hpelineupmallitempurchasehistory.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItemPurchaseHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPElineupMallItemPurchaseHistoryMutation) ResetEdge(name string) error {
	switch name {
	case hpelineupmallitempurchasehistory.EdgeElineupMallItem:
		m.ResetElineupMallItem()
		return nil
	case hpelineupmallitempurchasehistory.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown HPElineupMallItemPurchaseHistory edge %s", name)
}

// HPEventMutation represents an operation that mutates the HPEvent nodes in the graph.
type HPEventMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	updated_at                *time.Time
	key                       *string
	display_titles            *[]string
	appenddisplay_titles      []string
	open_at                   *time.Time
	start_at                  *time.Time
	venue                     *string
	prefecture                *string
	source                    *enums.HPEventSource
	clearedFields             map[string]struct{}
	members                   map[int]struct{}
	removedmembers            map[int]struct{}
	clearedmembers            bool
	artists                   map[int]struct{}
	removedartists            map[int]struct{}
	clearedartists            bool
	hpfc_event_tickets        map[int]struct{}
	removedhpfc_event_tickets map[int]struct{}
	clearedhpfc_event_tickets bool
	done                      bool
	oldValue                  func(context.Context) (*HPEvent, error)
	predicates                []predicate.HPEvent
}

var _ ent.Mutation = (*HPEventMutation)(nil)

// hpeventOption allows management of the mutation configuration using functional options.
type hpeventOption func(*HPEventMutation)

// newHPEventMutation creates new mutation for the HPEvent entity.
func newHPEventMutation(c config, op Op, opts ...hpeventOption) *HPEventMutation {
	m := &HPEventMutation{
		config:        c,
		op:            op,
		typ:           TypeHPEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPEventID sets the ID field of the mutation.
func withHPEventID(id int) hpeventOption {
	return func(m *HPEventMutation) {
		var (
			err   error
			once  sync.Once
			value *HPEvent
		)
		m.oldValue = func(ctx context.Context) (*HPEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPEvent sets the old HPEvent of the mutation.
func withHPEvent(node *HPEvent) hpeventOption {
	return func(m *HPEventMutation) {
		m.oldValue = func(context.Context) (*HPEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HPEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPEventMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpevent.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPEventMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpevent.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPEventMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpevent.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPEventMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpevent.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPEventMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpevent.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpevent.FieldUpdatedAt)
}

// SetKey sets the "key" field.
func (m *HPEventMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *HPEventMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *HPEventMutation) ResetKey() {
	m.key = nil
}

// SetDisplayTitles sets the "display_titles" field.
func (m *HPEventMutation) SetDisplayTitles(s []string) {
	m.display_titles = &s
	m.appenddisplay_titles = nil
}

// DisplayTitles returns the value of the "display_titles" field in the mutation.
func (m *HPEventMutation) DisplayTitles() (r []string, exists bool) {
	v := m.display_titles
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayTitles returns the old "display_titles" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldDisplayTitles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayTitles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayTitles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayTitles: %w", err)
	}
	return oldValue.DisplayTitles, nil
}

// AppendDisplayTitles adds s to the "display_titles" field.
func (m *HPEventMutation) AppendDisplayTitles(s []string) {
	m.appenddisplay_titles = append(m.appenddisplay_titles, s...)
}

// AppendedDisplayTitles returns the list of values that were appended to the "display_titles" field in this mutation.
func (m *HPEventMutation) AppendedDisplayTitles() ([]string, bool) {
	if len(m.appenddisplay_titles) == 0 {
		return nil, false
	}
	return m.appenddisplay_titles, true
}

// ResetDisplayTitles resets all changes to the "display_titles" field.
func (m *HPEventMutation) ResetDisplayTitles() {
	m.display_titles = nil
	m.appenddisplay_titles = nil
}

// SetOpenAt sets the "open_at" field.
func (m *HPEventMutation) SetOpenAt(t time.Time) {
	m.open_at = &t
}

// OpenAt returns the value of the "open_at" field in the mutation.
func (m *HPEventMutation) OpenAt() (r time.Time, exists bool) {
	v := m.open_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenAt returns the old "open_at" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldOpenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenAt: %w", err)
	}
	return oldValue.OpenAt, nil
}

// ClearOpenAt clears the value of the "open_at" field.
func (m *HPEventMutation) ClearOpenAt() {
	m.open_at = nil
	m.clearedFields[hpevent.FieldOpenAt] = struct{}{}
}

// OpenAtCleared returns if the "open_at" field was cleared in this mutation.
func (m *HPEventMutation) OpenAtCleared() bool {
	_, ok := m.clearedFields[hpevent.FieldOpenAt]
	return ok
}

// ResetOpenAt resets all changes to the "open_at" field.
func (m *HPEventMutation) ResetOpenAt() {
	m.open_at = nil
	delete(m.clearedFields, hpevent.FieldOpenAt)
}

// SetStartAt sets the "start_at" field.
func (m *HPEventMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *HPEventMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *HPEventMutation) ResetStartAt() {
	m.start_at = nil
}

// SetVenue sets the "venue" field.
func (m *HPEventMutation) SetVenue(s string) {
	m.venue = &s
}

// Venue returns the value of the "venue" field in the mutation.
func (m *HPEventMutation) Venue() (r string, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenue returns the old "venue" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldVenue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenue: %w", err)
	}
	return oldValue.Venue, nil
}

// ResetVenue resets all changes to the "venue" field.
func (m *HPEventMutation) ResetVenue() {
	m.venue = nil
}

// SetPrefecture sets the "prefecture" field.
func (m *HPEventMutation) SetPrefecture(s string) {
	m.prefecture = &s
}

// Prefecture returns the value of the "prefecture" field in the mutation.
func (m *HPEventMutation) Prefecture() (r string, exists bool) {
	v := m.prefecture
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefecture returns the old "prefecture" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldPrefecture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefecture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefecture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefecture: %w", err)
	}
	return oldValue.Prefecture, nil
}

// ResetPrefecture resets all changes to the "prefecture" field.
func (m *HPEventMutation) ResetPrefecture() {
	m.prefecture = nil
}

// SetSource sets the "source" field.
func (m *HPEventMutation) SetSource(ees enums.HPEventSource) {
	m.source = &ees
}

// Source returns the value of the "source" field in the mutation.
func (m *HPEventMutation) Source() (r enums.HPEventSource, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the HPEvent entity.
// If the HPEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPEventMutation) OldSource(ctx context.Context) (v enums.HPEventSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *HPEventMutation) ResetSource() {
	m.source = nil
}

// AddMemberIDs adds the "members" edge to the HPMember entity by ids.
func (m *HPEventMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the HPMember entity.
func (m *HPEventMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the HPMember entity was cleared.
func (m *HPEventMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the HPMember entity by IDs.
func (m *HPEventMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the HPMember entity.
func (m *HPEventMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *HPEventMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *HPEventMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddArtistIDs adds the "artists" edge to the HPArtist entity by ids.
func (m *HPEventMutation) AddArtistIDs(ids ...int) {
	if m.artists == nil {
		m.artists = make(map[int]struct{})
	}
	for i := range ids {
		m.artists[ids[i]] = struct{}{}
	}
}

// ClearArtists clears the "artists" edge to the HPArtist entity.
func (m *HPEventMutation) ClearArtists() {
	m.clearedartists = true
}

// ArtistsCleared reports if the "artists" edge to the HPArtist entity was cleared.
func (m *HPEventMutation) ArtistsCleared() bool {
	return m.clearedartists
}

// RemoveArtistIDs removes the "artists" edge to the HPArtist entity by IDs.
func (m *HPEventMutation) RemoveArtistIDs(ids ...int) {
	if m.removedartists == nil {
		m.removedartists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artists, ids[i])
		m.removedartists[ids[i]] = struct{}{}
	}
}

// RemovedArtists returns the removed IDs of the "artists" edge to the HPArtist entity.
func (m *HPEventMutation) RemovedArtistsIDs() (ids []int) {
	for id := range m.removedartists {
		ids = append(ids, id)
	}
	return
}

// ArtistsIDs returns the "artists" edge IDs in the mutation.
func (m *HPEventMutation) ArtistsIDs() (ids []int) {
	for id := range m.artists {
		ids = append(ids, id)
	}
	return
}

// ResetArtists resets all changes to the "artists" edge.
func (m *HPEventMutation) ResetArtists() {
	m.artists = nil
	m.clearedartists = false
	m.removedartists = nil
}

// AddHpfcEventTicketIDs adds the "hpfc_event_tickets" edge to the HPFCEventTicket entity by ids.
func (m *HPEventMutation) AddHpfcEventTicketIDs(ids ...int) {
	if m.hpfc_event_tickets == nil {
		m.hpfc_event_tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.hpfc_event_tickets[ids[i]] = struct{}{}
	}
}

// ClearHpfcEventTickets clears the "hpfc_event_tickets" edge to the HPFCEventTicket entity.
func (m *HPEventMutation) ClearHpfcEventTickets() {
	m.clearedhpfc_event_tickets = true
}

// HpfcEventTicketsCleared reports if the "hpfc_event_tickets" edge to the HPFCEventTicket entity was cleared.
func (m *HPEventMutation) HpfcEventTicketsCleared() bool {
	return m.clearedhpfc_event_tickets
}

// RemoveHpfcEventTicketIDs removes the "hpfc_event_tickets" edge to the HPFCEventTicket entity by IDs.
func (m *HPEventMutation) RemoveHpfcEventTicketIDs(ids ...int) {
	if m.removedhpfc_event_tickets == nil {
		m.removedhpfc_event_tickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hpfc_event_tickets, ids[i])
		m.removedhpfc_event_tickets[ids[i]] = struct{}{}
	}
}

// RemovedHpfcEventTickets returns the removed IDs of the "hpfc_event_tickets" edge to the HPFCEventTicket entity.
func (m *HPEventMutation) RemovedHpfcEventTicketsIDs() (ids []int) {
	for id := range m.removedhpfc_event_tickets {
		ids = append(ids, id)
	}
	return
}

// HpfcEventTicketsIDs returns the "hpfc_event_tickets" edge IDs in the mutation.
func (m *HPEventMutation) HpfcEventTicketsIDs() (ids []int) {
	for id := range m.hpfc_event_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetHpfcEventTickets resets all changes to the "hpfc_event_tickets" edge.
func (m *HPEventMutation) ResetHpfcEventTickets() {
	m.hpfc_event_tickets = nil
	m.clearedhpfc_event_tickets = false
	m.removedhpfc_event_tickets = nil
}

// Where appends a list predicates to the HPEventMutation builder.
func (m *HPEventMutation) Where(ps ...predicate.HPEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPEvent).
func (m *HPEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPEventMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, hpevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpevent.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, hpevent.FieldKey)
	}
	if m.display_titles != nil {
		fields = append(fields, hpevent.FieldDisplayTitles)
	}
	if m.open_at != nil {
		fields = append(fields, hpevent.FieldOpenAt)
	}
	if m.start_at != nil {
		fields = append(fields, hpevent.FieldStartAt)
	}
	if m.venue != nil {
		fields = append(fields, hpevent.FieldVenue)
	}
	if m.prefecture != nil {
		fields = append(fields, hpevent.FieldPrefecture)
	}
	if m.source != nil {
		fields = append(fields, hpevent.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpevent.FieldCreatedAt:
		return m.CreatedAt()
	case hpevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpevent.FieldKey:
		return m.Key()
	case hpevent.FieldDisplayTitles:
		return m.DisplayTitles()
	case hpevent.FieldOpenAt:
		return m.OpenAt()
	case hpevent.FieldStartAt:
		return m.StartAt()
	case hpevent.FieldVenue:
		return m.Venue()
	case hpevent.FieldPrefecture:
		return m.Prefecture()
	case hpevent.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpevent.FieldKey:
		return m.OldKey(ctx)
	case hpevent.FieldDisplayTitles:
		return m.OldDisplayTitles(ctx)
	case hpevent.FieldOpenAt:
		return m.OldOpenAt(ctx)
	case hpevent.FieldStartAt:
		return m.OldStartAt(ctx)
	case hpevent.FieldVenue:
		return m.OldVenue(ctx)
	case hpevent.FieldPrefecture:
		return m.OldPrefecture(ctx)
	case hpevent.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown HPEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpevent.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case hpevent.FieldDisplayTitles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayTitles(v)
		return nil
	case hpevent.FieldOpenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenAt(v)
		return nil
	case hpevent.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case hpevent.FieldVenue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenue(v)
		return nil
	case hpevent.FieldPrefecture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefecture(v)
		return nil
	case hpevent.FieldSource:
		v, ok := value.(enums.HPEventSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown HPEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HPEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpevent.FieldCreatedAt) {
		fields = append(fields, hpevent.FieldCreatedAt)
	}
	if m.FieldCleared(hpevent.FieldUpdatedAt) {
		fields = append(fields, hpevent.FieldUpdatedAt)
	}
	if m.FieldCleared(hpevent.FieldOpenAt) {
		fields = append(fields, hpevent.FieldOpenAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPEventMutation) ClearField(name string) error {
	switch name {
	case hpevent.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpevent.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpevent.FieldOpenAt:
		m.ClearOpenAt()
		return nil
	}
	return fmt.Errorf("unknown HPEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPEventMutation) ResetField(name string) error {
	switch name {
	case hpevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpevent.FieldKey:
		m.ResetKey()
		return nil
	case hpevent.FieldDisplayTitles:
		m.ResetDisplayTitles()
		return nil
	case hpevent.FieldOpenAt:
		m.ResetOpenAt()
		return nil
	case hpevent.FieldStartAt:
		m.ResetStartAt()
		return nil
	case hpevent.FieldVenue:
		m.ResetVenue()
		return nil
	case hpevent.FieldPrefecture:
		m.ResetPrefecture()
		return nil
	case hpevent.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown HPEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.members != nil {
		edges = append(edges, hpevent.EdgeMembers)
	}
	if m.artists != nil {
		edges = append(edges, hpevent.EdgeArtists)
	}
	if m.hpfc_event_tickets != nil {
		edges = append(edges, hpevent.EdgeHpfcEventTickets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpevent.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case hpevent.EdgeArtists:
		ids := make([]ent.Value, 0, len(m.artists))
		for id := range m.artists {
			ids = append(ids, id)
		}
		return ids
	case hpevent.EdgeHpfcEventTickets:
		ids := make([]ent.Value, 0, len(m.hpfc_event_tickets))
		for id := range m.hpfc_event_tickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmembers != nil {
		edges = append(edges, hpevent.EdgeMembers)
	}
	if m.removedartists != nil {
		edges = append(edges, hpevent.EdgeArtists)
	}
	if m.removedhpfc_event_tickets != nil {
		edges = append(edges, hpevent.EdgeHpfcEventTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpevent.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case hpevent.EdgeArtists:
		ids := make([]ent.Value, 0, len(m.removedartists))
		for id := range m.removedartists {
			ids = append(ids, id)
		}
		return ids
	case hpevent.EdgeHpfcEventTickets:
		ids := make([]ent.Value, 0, len(m.removedhpfc_event_tickets))
		for id := range m.removedhpfc_event_tickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmembers {
		edges = append(edges, hpevent.EdgeMembers)
	}
	if m.clearedartists {
		edges = append(edges, hpevent.EdgeArtists)
	}
	if m.clearedhpfc_event_tickets {
		edges = append(edges, hpevent.EdgeHpfcEventTickets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPEventMutation) EdgeCleared(name string) bool {
	switch name {
	case hpevent.EdgeMembers:
		return m.clearedmembers
	case hpevent.EdgeArtists:
		return m.clearedartists
	case hpevent.EdgeHpfcEventTickets:
		return m.clearedhpfc_event_tickets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPEventMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HPEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPEventMutation) ResetEdge(name string) error {
	switch name {
	case hpevent.EdgeMembers:
		m.ResetMembers()
		return nil
	case hpevent.EdgeArtists:
		m.ResetArtists()
		return nil
	case hpevent.EdgeHpfcEventTickets:
		m.ResetHpfcEventTickets()
		return nil
	}
	return fmt.Errorf("unknown HPEvent edge %s", name)
}

// HPFCEventTicketMutation represents an operation that mutates the HPFCEventTicket nodes in the graph.
type HPFCEventTicketMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	num                    *int
	addnum                 *int
	status                 *enums.HPFCEventTicketApplicationStatus
	fc_member_sha256       *string
	application_title      *string
	application_id         *string
	application_site       *enums.HPFCEventTicketApplicationSite
	application_start_date *time.Time
	application_due_date   *time.Time
	payment_start_date     *time.Time
	payment_due_date       *time.Time
	clearedFields          map[string]struct{}
	event                  *int
	clearedevent           bool
	user                   *int
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*HPFCEventTicket, error)
	predicates             []predicate.HPFCEventTicket
}

var _ ent.Mutation = (*HPFCEventTicketMutation)(nil)

// hpfceventticketOption allows management of the mutation configuration using functional options.
type hpfceventticketOption func(*HPFCEventTicketMutation)

// newHPFCEventTicketMutation creates new mutation for the HPFCEventTicket entity.
func newHPFCEventTicketMutation(c config, op Op, opts ...hpfceventticketOption) *HPFCEventTicketMutation {
	m := &HPFCEventTicketMutation{
		config:        c,
		op:            op,
		typ:           TypeHPFCEventTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPFCEventTicketID sets the ID field of the mutation.
func withHPFCEventTicketID(id int) hpfceventticketOption {
	return func(m *HPFCEventTicketMutation) {
		var (
			err   error
			once  sync.Once
			value *HPFCEventTicket
		)
		m.oldValue = func(ctx context.Context) (*HPFCEventTicket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPFCEventTicket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPFCEventTicket sets the old HPFCEventTicket of the mutation.
func withHPFCEventTicket(node *HPFCEventTicket) hpfceventticketOption {
	return func(m *HPFCEventTicketMutation) {
		m.oldValue = func(context.Context) (*HPFCEventTicket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPFCEventTicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPFCEventTicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPFCEventTicketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPFCEventTicketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPFCEventTicket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HPFCEventTicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPFCEventTicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPFCEventTicketMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpfceventticket.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPFCEventTicketMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpfceventticket.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPFCEventTicketMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpfceventticket.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPFCEventTicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPFCEventTicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPFCEventTicketMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpfceventticket.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPFCEventTicketMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpfceventticket.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPFCEventTicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpfceventticket.FieldUpdatedAt)
}

// SetNum sets the "num" field.
func (m *HPFCEventTicketMutation) SetNum(i int) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *HPFCEventTicketMutation) Num() (r int, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *HPFCEventTicketMutation) AddNum(i int) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *HPFCEventTicketMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *HPFCEventTicketMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetStatus sets the "status" field.
func (m *HPFCEventTicketMutation) SetStatus(eetas enums.HPFCEventTicketApplicationStatus) {
	m.status = &eetas
}

// Status returns the value of the "status" field in the mutation.
func (m *HPFCEventTicketMutation) Status() (r enums.HPFCEventTicketApplicationStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldStatus(ctx context.Context) (v enums.HPFCEventTicketApplicationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HPFCEventTicketMutation) ResetStatus() {
	m.status = nil
}

// SetFcMemberSha256 sets the "fc_member_sha256" field.
func (m *HPFCEventTicketMutation) SetFcMemberSha256(s string) {
	m.fc_member_sha256 = &s
}

// FcMemberSha256 returns the value of the "fc_member_sha256" field in the mutation.
func (m *HPFCEventTicketMutation) FcMemberSha256() (r string, exists bool) {
	v := m.fc_member_sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldFcMemberSha256 returns the old "fc_member_sha256" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldFcMemberSha256(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFcMemberSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFcMemberSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFcMemberSha256: %w", err)
	}
	return oldValue.FcMemberSha256, nil
}

// ResetFcMemberSha256 resets all changes to the "fc_member_sha256" field.
func (m *HPFCEventTicketMutation) ResetFcMemberSha256() {
	m.fc_member_sha256 = nil
}

// SetApplicationTitle sets the "application_title" field.
func (m *HPFCEventTicketMutation) SetApplicationTitle(s string) {
	m.application_title = &s
}

// ApplicationTitle returns the value of the "application_title" field in the mutation.
func (m *HPFCEventTicketMutation) ApplicationTitle() (r string, exists bool) {
	v := m.application_title
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationTitle returns the old "application_title" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldApplicationTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationTitle: %w", err)
	}
	return oldValue.ApplicationTitle, nil
}

// ResetApplicationTitle resets all changes to the "application_title" field.
func (m *HPFCEventTicketMutation) ResetApplicationTitle() {
	m.application_title = nil
}

// SetApplicationID sets the "application_id" field.
func (m *HPFCEventTicketMutation) SetApplicationID(s string) {
	m.application_id = &s
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *HPFCEventTicketMutation) ApplicationID() (r string, exists bool) {
	v := m.application_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldApplicationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ClearApplicationID clears the value of the "application_id" field.
func (m *HPFCEventTicketMutation) ClearApplicationID() {
	m.application_id = nil
	m.clearedFields[hpfceventticket.FieldApplicationID] = struct{}{}
}

// ApplicationIDCleared returns if the "application_id" field was cleared in this mutation.
func (m *HPFCEventTicketMutation) ApplicationIDCleared() bool {
	_, ok := m.clearedFields[hpfceventticket.FieldApplicationID]
	return ok
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *HPFCEventTicketMutation) ResetApplicationID() {
	m.application_id = nil
	delete(m.clearedFields, hpfceventticket.FieldApplicationID)
}

// SetApplicationSite sets the "application_site" field.
func (m *HPFCEventTicketMutation) SetApplicationSite(eetas enums.HPFCEventTicketApplicationSite) {
	m.application_site = &eetas
}

// ApplicationSite returns the value of the "application_site" field in the mutation.
func (m *HPFCEventTicketMutation) ApplicationSite() (r enums.HPFCEventTicketApplicationSite, exists bool) {
	v := m.application_site
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationSite returns the old "application_site" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldApplicationSite(ctx context.Context) (v enums.HPFCEventTicketApplicationSite, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationSite: %w", err)
	}
	return oldValue.ApplicationSite, nil
}

// ResetApplicationSite resets all changes to the "application_site" field.
func (m *HPFCEventTicketMutation) ResetApplicationSite() {
	m.application_site = nil
}

// SetApplicationStartDate sets the "application_start_date" field.
func (m *HPFCEventTicketMutation) SetApplicationStartDate(t time.Time) {
	m.application_start_date = &t
}

// ApplicationStartDate returns the value of the "application_start_date" field in the mutation.
func (m *HPFCEventTicketMutation) ApplicationStartDate() (r time.Time, exists bool) {
	v := m.application_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationStartDate returns the old "application_start_date" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldApplicationStartDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationStartDate: %w", err)
	}
	return oldValue.ApplicationStartDate, nil
}

// ClearApplicationStartDate clears the value of the "application_start_date" field.
func (m *HPFCEventTicketMutation) ClearApplicationStartDate() {
	m.application_start_date = nil
	m.clearedFields[hpfceventticket.FieldApplicationStartDate] = struct{}{}
}

// ApplicationStartDateCleared returns if the "application_start_date" field was cleared in this mutation.
func (m *HPFCEventTicketMutation) ApplicationStartDateCleared() bool {
	_, ok := m.clearedFields[hpfceventticket.FieldApplicationStartDate]
	return ok
}

// ResetApplicationStartDate resets all changes to the "application_start_date" field.
func (m *HPFCEventTicketMutation) ResetApplicationStartDate() {
	m.application_start_date = nil
	delete(m.clearedFields, hpfceventticket.FieldApplicationStartDate)
}

// SetApplicationDueDate sets the "application_due_date" field.
func (m *HPFCEventTicketMutation) SetApplicationDueDate(t time.Time) {
	m.application_due_date = &t
}

// ApplicationDueDate returns the value of the "application_due_date" field in the mutation.
func (m *HPFCEventTicketMutation) ApplicationDueDate() (r time.Time, exists bool) {
	v := m.application_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationDueDate returns the old "application_due_date" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldApplicationDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationDueDate: %w", err)
	}
	return oldValue.ApplicationDueDate, nil
}

// ClearApplicationDueDate clears the value of the "application_due_date" field.
func (m *HPFCEventTicketMutation) ClearApplicationDueDate() {
	m.application_due_date = nil
	m.clearedFields[hpfceventticket.FieldApplicationDueDate] = struct{}{}
}

// ApplicationDueDateCleared returns if the "application_due_date" field was cleared in this mutation.
func (m *HPFCEventTicketMutation) ApplicationDueDateCleared() bool {
	_, ok := m.clearedFields[hpfceventticket.FieldApplicationDueDate]
	return ok
}

// ResetApplicationDueDate resets all changes to the "application_due_date" field.
func (m *HPFCEventTicketMutation) ResetApplicationDueDate() {
	m.application_due_date = nil
	delete(m.clearedFields, hpfceventticket.FieldApplicationDueDate)
}

// SetPaymentStartDate sets the "payment_start_date" field.
func (m *HPFCEventTicketMutation) SetPaymentStartDate(t time.Time) {
	m.payment_start_date = &t
}

// PaymentStartDate returns the value of the "payment_start_date" field in the mutation.
func (m *HPFCEventTicketMutation) PaymentStartDate() (r time.Time, exists bool) {
	v := m.payment_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStartDate returns the old "payment_start_date" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldPaymentStartDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStartDate: %w", err)
	}
	return oldValue.PaymentStartDate, nil
}

// ClearPaymentStartDate clears the value of the "payment_start_date" field.
func (m *HPFCEventTicketMutation) ClearPaymentStartDate() {
	m.payment_start_date = nil
	m.clearedFields[hpfceventticket.FieldPaymentStartDate] = struct{}{}
}

// PaymentStartDateCleared returns if the "payment_start_date" field was cleared in this mutation.
func (m *HPFCEventTicketMutation) PaymentStartDateCleared() bool {
	_, ok := m.clearedFields[hpfceventticket.FieldPaymentStartDate]
	return ok
}

// ResetPaymentStartDate resets all changes to the "payment_start_date" field.
func (m *HPFCEventTicketMutation) ResetPaymentStartDate() {
	m.payment_start_date = nil
	delete(m.clearedFields, hpfceventticket.FieldPaymentStartDate)
}

// SetPaymentDueDate sets the "payment_due_date" field.
func (m *HPFCEventTicketMutation) SetPaymentDueDate(t time.Time) {
	m.payment_due_date = &t
}

// PaymentDueDate returns the value of the "payment_due_date" field in the mutation.
func (m *HPFCEventTicketMutation) PaymentDueDate() (r time.Time, exists bool) {
	v := m.payment_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentDueDate returns the old "payment_due_date" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldPaymentDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentDueDate: %w", err)
	}
	return oldValue.PaymentDueDate, nil
}

// ClearPaymentDueDate clears the value of the "payment_due_date" field.
func (m *HPFCEventTicketMutation) ClearPaymentDueDate() {
	m.payment_due_date = nil
	m.clearedFields[hpfceventticket.FieldPaymentDueDate] = struct{}{}
}

// PaymentDueDateCleared returns if the "payment_due_date" field was cleared in this mutation.
func (m *HPFCEventTicketMutation) PaymentDueDateCleared() bool {
	_, ok := m.clearedFields[hpfceventticket.FieldPaymentDueDate]
	return ok
}

// ResetPaymentDueDate resets all changes to the "payment_due_date" field.
func (m *HPFCEventTicketMutation) ResetPaymentDueDate() {
	m.payment_due_date = nil
	delete(m.clearedFields, hpfceventticket.FieldPaymentDueDate)
}

// SetOwnerUserID sets the "owner_user_id" field.
func (m *HPFCEventTicketMutation) SetOwnerUserID(i int) {
	m.user = &i
}

// OwnerUserID returns the value of the "owner_user_id" field in the mutation.
func (m *HPFCEventTicketMutation) OwnerUserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerUserID returns the old "owner_user_id" field's value of the HPFCEventTicket entity.
// If the HPFCEventTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFCEventTicketMutation) OldOwnerUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerUserID: %w", err)
	}
	return oldValue.OwnerUserID, nil
}

// ResetOwnerUserID resets all changes to the "owner_user_id" field.
func (m *HPFCEventTicketMutation) ResetOwnerUserID() {
	m.user = nil
}

// SetEventID sets the "event" edge to the HPEvent entity by id.
func (m *HPFCEventTicketMutation) SetEventID(id int) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the HPEvent entity.
func (m *HPFCEventTicketMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the HPEvent entity was cleared.
func (m *HPFCEventTicketMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *HPFCEventTicketMutation) EventID() (id int, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *HPFCEventTicketMutation) EventIDs() (ids []int) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *HPFCEventTicketMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *HPFCEventTicketMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *HPFCEventTicketMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *HPFCEventTicketMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *HPFCEventTicketMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *HPFCEventTicketMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *HPFCEventTicketMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the HPFCEventTicketMutation builder.
func (m *HPFCEventTicketMutation) Where(ps ...predicate.HPFCEventTicket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPFCEventTicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPFCEventTicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPFCEventTicket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPFCEventTicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPFCEventTicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPFCEventTicket).
func (m *HPFCEventTicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPFCEventTicketMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, hpfceventticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpfceventticket.FieldUpdatedAt)
	}
	if m.num != nil {
		fields = append(fields, hpfceventticket.FieldNum)
	}
	if m.status != nil {
		fields = append(fields, hpfceventticket.FieldStatus)
	}
	if m.fc_member_sha256 != nil {
		fields = append(fields, hpfceventticket.FieldFcMemberSha256)
	}
	if m.application_title != nil {
		fields = append(fields, hpfceventticket.FieldApplicationTitle)
	}
	if m.application_id != nil {
		fields = append(fields, hpfceventticket.FieldApplicationID)
	}
	if m.application_site != nil {
		fields = append(fields, hpfceventticket.FieldApplicationSite)
	}
	if m.application_start_date != nil {
		fields = append(fields, hpfceventticket.FieldApplicationStartDate)
	}
	if m.application_due_date != nil {
		fields = append(fields, hpfceventticket.FieldApplicationDueDate)
	}
	if m.payment_start_date != nil {
		fields = append(fields, hpfceventticket.FieldPaymentStartDate)
	}
	if m.payment_due_date != nil {
		fields = append(fields, hpfceventticket.FieldPaymentDueDate)
	}
	if m.user != nil {
		fields = append(fields, hpfceventticket.FieldOwnerUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPFCEventTicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpfceventticket.FieldCreatedAt:
		return m.CreatedAt()
	case hpfceventticket.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpfceventticket.FieldNum:
		return m.Num()
	case hpfceventticket.FieldStatus:
		return m.Status()
	case hpfceventticket.FieldFcMemberSha256:
		return m.FcMemberSha256()
	case hpfceventticket.FieldApplicationTitle:
		return m.ApplicationTitle()
	case hpfceventticket.FieldApplicationID:
		return m.ApplicationID()
	case hpfceventticket.FieldApplicationSite:
		return m.ApplicationSite()
	case hpfceventticket.FieldApplicationStartDate:
		return m.ApplicationStartDate()
	case hpfceventticket.FieldApplicationDueDate:
		return m.ApplicationDueDate()
	case hpfceventticket.FieldPaymentStartDate:
		return m.PaymentStartDate()
	case hpfceventticket.FieldPaymentDueDate:
		return m.PaymentDueDate()
	case hpfceventticket.FieldOwnerUserID:
		return m.OwnerUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPFCEventTicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpfceventticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpfceventticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpfceventticket.FieldNum:
		return m.OldNum(ctx)
	case hpfceventticket.FieldStatus:
		return m.OldStatus(ctx)
	case hpfceventticket.FieldFcMemberSha256:
		return m.OldFcMemberSha256(ctx)
	case hpfceventticket.FieldApplicationTitle:
		return m.OldApplicationTitle(ctx)
	case hpfceventticket.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case hpfceventticket.FieldApplicationSite:
		return m.OldApplicationSite(ctx)
	case hpfceventticket.FieldApplicationStartDate:
		return m.OldApplicationStartDate(ctx)
	case hpfceventticket.FieldApplicationDueDate:
		return m.OldApplicationDueDate(ctx)
	case hpfceventticket.FieldPaymentStartDate:
		return m.OldPaymentStartDate(ctx)
	case hpfceventticket.FieldPaymentDueDate:
		return m.OldPaymentDueDate(ctx)
	case hpfceventticket.FieldOwnerUserID:
		return m.OldOwnerUserID(ctx)
	}
	return nil, fmt.Errorf("unknown HPFCEventTicket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPFCEventTicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpfceventticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpfceventticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpfceventticket.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case hpfceventticket.FieldStatus:
		v, ok := value.(enums.HPFCEventTicketApplicationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hpfceventticket.FieldFcMemberSha256:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFcMemberSha256(v)
		return nil
	case hpfceventticket.FieldApplicationTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationTitle(v)
		return nil
	case hpfceventticket.FieldApplicationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case hpfceventticket.FieldApplicationSite:
		v, ok := value.(enums.HPFCEventTicketApplicationSite)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationSite(v)
		return nil
	case hpfceventticket.FieldApplicationStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationStartDate(v)
		return nil
	case hpfceventticket.FieldApplicationDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationDueDate(v)
		return nil
	case hpfceventticket.FieldPaymentStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStartDate(v)
		return nil
	case hpfceventticket.FieldPaymentDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentDueDate(v)
		return nil
	case hpfceventticket.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown HPFCEventTicket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPFCEventTicketMutation) AddedFields() []string {
	var fields []string
	if m.addnum != nil {
		fields = append(fields, hpfceventticket.FieldNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPFCEventTicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpfceventticket.FieldNum:
		return m.AddedNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPFCEventTicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpfceventticket.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	}
	return fmt.Errorf("unknown HPFCEventTicket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPFCEventTicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpfceventticket.FieldCreatedAt) {
		fields = append(fields, hpfceventticket.FieldCreatedAt)
	}
	if m.FieldCleared(hpfceventticket.FieldUpdatedAt) {
		fields = append(fields, hpfceventticket.FieldUpdatedAt)
	}
	if m.FieldCleared(hpfceventticket.FieldApplicationID) {
		fields = append(fields, hpfceventticket.FieldApplicationID)
	}
	if m.FieldCleared(hpfceventticket.FieldApplicationStartDate) {
		fields = append(fields, hpfceventticket.FieldApplicationStartDate)
	}
	if m.FieldCleared(hpfceventticket.FieldApplicationDueDate) {
		fields = append(fields, hpfceventticket.FieldApplicationDueDate)
	}
	if m.FieldCleared(hpfceventticket.FieldPaymentStartDate) {
		fields = append(fields, hpfceventticket.FieldPaymentStartDate)
	}
	if m.FieldCleared(hpfceventticket.FieldPaymentDueDate) {
		fields = append(fields, hpfceventticket.FieldPaymentDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPFCEventTicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPFCEventTicketMutation) ClearField(name string) error {
	switch name {
	case hpfceventticket.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpfceventticket.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpfceventticket.FieldApplicationID:
		m.ClearApplicationID()
		return nil
	case hpfceventticket.FieldApplicationStartDate:
		m.ClearApplicationStartDate()
		return nil
	case hpfceventticket.FieldApplicationDueDate:
		m.ClearApplicationDueDate()
		return nil
	case hpfceventticket.FieldPaymentStartDate:
		m.ClearPaymentStartDate()
		return nil
	case hpfceventticket.FieldPaymentDueDate:
		m.ClearPaymentDueDate()
		return nil
	}
	return fmt.Errorf("unknown HPFCEventTicket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPFCEventTicketMutation) ResetField(name string) error {
	switch name {
	case hpfceventticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpfceventticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpfceventticket.FieldNum:
		m.ResetNum()
		return nil
	case hpfceventticket.FieldStatus:
		m.ResetStatus()
		return nil
	case hpfceventticket.FieldFcMemberSha256:
		m.ResetFcMemberSha256()
		return nil
	case hpfceventticket.FieldApplicationTitle:
		m.ResetApplicationTitle()
		return nil
	case hpfceventticket.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case hpfceventticket.FieldApplicationSite:
		m.ResetApplicationSite()
		return nil
	case hpfceventticket.FieldApplicationStartDate:
		m.ResetApplicationStartDate()
		return nil
	case hpfceventticket.FieldApplicationDueDate:
		m.ResetApplicationDueDate()
		return nil
	case hpfceventticket.FieldPaymentStartDate:
		m.ResetPaymentStartDate()
		return nil
	case hpfceventticket.FieldPaymentDueDate:
		m.ResetPaymentDueDate()
		return nil
	case hpfceventticket.FieldOwnerUserID:
		m.ResetOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown HPFCEventTicket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPFCEventTicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, hpfceventticket.EdgeEvent)
	}
	if m.user != nil {
		edges = append(edges, hpfceventticket.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPFCEventTicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpfceventticket.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case hpfceventticket.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPFCEventTicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPFCEventTicketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPFCEventTicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, hpfceventticket.EdgeEvent)
	}
	if m.cleareduser {
		edges = append(edges, hpfceventticket.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPFCEventTicketMutation) EdgeCleared(name string) bool {
	switch name {
	case hpfceventticket.EdgeEvent:
		return m.clearedevent
	case hpfceventticket.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPFCEventTicketMutation) ClearEdge(name string) error {
	switch name {
	case hpfceventticket.EdgeEvent:
		m.ClearEvent()
		return nil
	case hpfceventticket.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown HPFCEventTicket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPFCEventTicketMutation) ResetEdge(name string) error {
	switch name {
	case hpfceventticket.EdgeEvent:
		m.ResetEvent()
		return nil
	case hpfceventticket.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown HPFCEventTicket edge %s", name)
}

// HPFeedItemMutation represents an operation that mutates the HPFeedItem nodes in the graph.
type HPFeedItemMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	source_id             *int
	addsource_id          *int
	asset_type            *enums.HPAssetType
	title                 *string
	post_at               *time.Time
	source_url            *string
	image_url             *string
	media                 *[]jsonfields.Media
	appendmedia           []jsonfields.Media
	clearedFields         map[string]struct{}
	view_histories        map[int]struct{}
	removedview_histories map[int]struct{}
	clearedview_histories bool
	owner_artist          *int
	clearedowner_artist   bool
	owner_member          *int
	clearedowner_member   bool
	tagged_artists        map[int]struct{}
	removedtagged_artists map[int]struct{}
	clearedtagged_artists bool
	tagged_members        map[int]struct{}
	removedtagged_members map[int]struct{}
	clearedtagged_members bool
	done                  bool
	oldValue              func(context.Context) (*HPFeedItem, error)
	predicates            []predicate.HPFeedItem
}

var _ ent.Mutation = (*HPFeedItemMutation)(nil)

// hpfeeditemOption allows management of the mutation configuration using functional options.
type hpfeeditemOption func(*HPFeedItemMutation)

// newHPFeedItemMutation creates new mutation for the HPFeedItem entity.
func newHPFeedItemMutation(c config, op Op, opts ...hpfeeditemOption) *HPFeedItemMutation {
	m := &HPFeedItemMutation{
		config:        c,
		op:            op,
		typ:           TypeHPFeedItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPFeedItemID sets the ID field of the mutation.
func withHPFeedItemID(id int) hpfeeditemOption {
	return func(m *HPFeedItemMutation) {
		var (
			err   error
			once  sync.Once
			value *HPFeedItem
		)
		m.oldValue = func(ctx context.Context) (*HPFeedItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPFeedItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPFeedItem sets the old HPFeedItem of the mutation.
func withHPFeedItem(node *HPFeedItem) hpfeeditemOption {
	return func(m *HPFeedItemMutation) {
		m.oldValue = func(context.Context) (*HPFeedItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPFeedItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPFeedItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPFeedItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPFeedItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPFeedItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HPFeedItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPFeedItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPFeedItemMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpfeeditem.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPFeedItemMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpfeeditem.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPFeedItemMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpfeeditem.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPFeedItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPFeedItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPFeedItemMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpfeeditem.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPFeedItemMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpfeeditem.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPFeedItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpfeeditem.FieldUpdatedAt)
}

// SetSourceID sets the "source_id" field.
func (m *HPFeedItemMutation) SetSourceID(i int) {
	m.source_id = &i
	m.addsource_id = nil
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *HPFeedItemMutation) SourceID() (r int, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// AddSourceID adds i to the "source_id" field.
func (m *HPFeedItemMutation) AddSourceID(i int) {
	if m.addsource_id != nil {
		*m.addsource_id += i
	} else {
		m.addsource_id = &i
	}
}

// AddedSourceID returns the value that was added to the "source_id" field in this mutation.
func (m *HPFeedItemMutation) AddedSourceID() (r int, exists bool) {
	v := m.addsource_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *HPFeedItemMutation) ResetSourceID() {
	m.source_id = nil
	m.addsource_id = nil
}

// SetAssetType sets the "asset_type" field.
func (m *HPFeedItemMutation) SetAssetType(eat enums.HPAssetType) {
	m.asset_type = &eat
}

// AssetType returns the value of the "asset_type" field in the mutation.
func (m *HPFeedItemMutation) AssetType() (r enums.HPAssetType, exists bool) {
	v := m.asset_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetType returns the old "asset_type" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldAssetType(ctx context.Context) (v enums.HPAssetType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetType: %w", err)
	}
	return oldValue.AssetType, nil
}

// ResetAssetType resets all changes to the "asset_type" field.
func (m *HPFeedItemMutation) ResetAssetType() {
	m.asset_type = nil
}

// SetTitle sets the "title" field.
func (m *HPFeedItemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *HPFeedItemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *HPFeedItemMutation) ResetTitle() {
	m.title = nil
}

// SetPostAt sets the "post_at" field.
func (m *HPFeedItemMutation) SetPostAt(t time.Time) {
	m.post_at = &t
}

// PostAt returns the value of the "post_at" field in the mutation.
func (m *HPFeedItemMutation) PostAt() (r time.Time, exists bool) {
	v := m.post_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPostAt returns the old "post_at" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldPostAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostAt: %w", err)
	}
	return oldValue.PostAt, nil
}

// ResetPostAt resets all changes to the "post_at" field.
func (m *HPFeedItemMutation) ResetPostAt() {
	m.post_at = nil
}

// SetSourceURL sets the "source_url" field.
func (m *HPFeedItemMutation) SetSourceURL(s string) {
	m.source_url = &s
}

// SourceURL returns the value of the "source_url" field in the mutation.
func (m *HPFeedItemMutation) SourceURL() (r string, exists bool) {
	v := m.source_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceURL returns the old "source_url" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldSourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceURL: %w", err)
	}
	return oldValue.SourceURL, nil
}

// ResetSourceURL resets all changes to the "source_url" field.
func (m *HPFeedItemMutation) ResetSourceURL() {
	m.source_url = nil
}

// SetImageURL sets the "image_url" field.
func (m *HPFeedItemMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *HPFeedItemMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldImageURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *HPFeedItemMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[hpfeeditem.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *HPFeedItemMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[hpfeeditem.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *HPFeedItemMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, hpfeeditem.FieldImageURL)
}

// SetMedia sets the "media" field.
func (m *HPFeedItemMutation) SetMedia(j []jsonfields.Media) {
	m.media = &j
	m.appendmedia = nil
}

// Media returns the value of the "media" field in the mutation.
func (m *HPFeedItemMutation) Media() (r []jsonfields.Media, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMedia returns the old "media" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldMedia(ctx context.Context) (v []jsonfields.Media, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedia: %w", err)
	}
	return oldValue.Media, nil
}

// AppendMedia adds j to the "media" field.
func (m *HPFeedItemMutation) AppendMedia(j []jsonfields.Media) {
	m.appendmedia = append(m.appendmedia, j...)
}

// AppendedMedia returns the list of values that were appended to the "media" field in this mutation.
func (m *HPFeedItemMutation) AppendedMedia() ([]jsonfields.Media, bool) {
	if len(m.appendmedia) == 0 {
		return nil, false
	}
	return m.appendmedia, true
}

// ResetMedia resets all changes to the "media" field.
func (m *HPFeedItemMutation) ResetMedia() {
	m.media = nil
	m.appendmedia = nil
}

// SetOwnerArtistID sets the "owner_artist_id" field.
func (m *HPFeedItemMutation) SetOwnerArtistID(i int) {
	m.owner_artist = &i
}

// OwnerArtistID returns the value of the "owner_artist_id" field in the mutation.
func (m *HPFeedItemMutation) OwnerArtistID() (r int, exists bool) {
	v := m.owner_artist
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerArtistID returns the old "owner_artist_id" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldOwnerArtistID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerArtistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerArtistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerArtistID: %w", err)
	}
	return oldValue.OwnerArtistID, nil
}

// ClearOwnerArtistID clears the value of the "owner_artist_id" field.
func (m *HPFeedItemMutation) ClearOwnerArtistID() {
	m.owner_artist = nil
	m.clearedFields[hpfeeditem.FieldOwnerArtistID] = struct{}{}
}

// OwnerArtistIDCleared returns if the "owner_artist_id" field was cleared in this mutation.
func (m *HPFeedItemMutation) OwnerArtistIDCleared() bool {
	_, ok := m.clearedFields[hpfeeditem.FieldOwnerArtistID]
	return ok
}

// ResetOwnerArtistID resets all changes to the "owner_artist_id" field.
func (m *HPFeedItemMutation) ResetOwnerArtistID() {
	m.owner_artist = nil
	delete(m.clearedFields, hpfeeditem.FieldOwnerArtistID)
}

// SetOwnerMemberID sets the "owner_member_id" field.
func (m *HPFeedItemMutation) SetOwnerMemberID(i int) {
	m.owner_member = &i
}

// OwnerMemberID returns the value of the "owner_member_id" field in the mutation.
func (m *HPFeedItemMutation) OwnerMemberID() (r int, exists bool) {
	v := m.owner_member
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerMemberID returns the old "owner_member_id" field's value of the HPFeedItem entity.
// If the HPFeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFeedItemMutation) OldOwnerMemberID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerMemberID: %w", err)
	}
	return oldValue.OwnerMemberID, nil
}

// ClearOwnerMemberID clears the value of the "owner_member_id" field.
func (m *HPFeedItemMutation) ClearOwnerMemberID() {
	m.owner_member = nil
	m.clearedFields[hpfeeditem.FieldOwnerMemberID] = struct{}{}
}

// OwnerMemberIDCleared returns if the "owner_member_id" field was cleared in this mutation.
func (m *HPFeedItemMutation) OwnerMemberIDCleared() bool {
	_, ok := m.clearedFields[hpfeeditem.FieldOwnerMemberID]
	return ok
}

// ResetOwnerMemberID resets all changes to the "owner_member_id" field.
func (m *HPFeedItemMutation) ResetOwnerMemberID() {
	m.owner_member = nil
	delete(m.clearedFields, hpfeeditem.FieldOwnerMemberID)
}

// AddViewHistoryIDs adds the "view_histories" edge to the HPViewHistory entity by ids.
func (m *HPFeedItemMutation) AddViewHistoryIDs(ids ...int) {
	if m.view_histories == nil {
		m.view_histories = make(map[int]struct{})
	}
	for i := range ids {
		m.view_histories[ids[i]] = struct{}{}
	}
}

// ClearViewHistories clears the "view_histories" edge to the HPViewHistory entity.
func (m *HPFeedItemMutation) ClearViewHistories() {
	m.clearedview_histories = true
}

// ViewHistoriesCleared reports if the "view_histories" edge to the HPViewHistory entity was cleared.
func (m *HPFeedItemMutation) ViewHistoriesCleared() bool {
	return m.clearedview_histories
}

// RemoveViewHistoryIDs removes the "view_histories" edge to the HPViewHistory entity by IDs.
func (m *HPFeedItemMutation) RemoveViewHistoryIDs(ids ...int) {
	if m.removedview_histories == nil {
		m.removedview_histories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.view_histories, ids[i])
		m.removedview_histories[ids[i]] = struct{}{}
	}
}

// RemovedViewHistories returns the removed IDs of the "view_histories" edge to the HPViewHistory entity.
func (m *HPFeedItemMutation) RemovedViewHistoriesIDs() (ids []int) {
	for id := range m.removedview_histories {
		ids = append(ids, id)
	}
	return
}

// ViewHistoriesIDs returns the "view_histories" edge IDs in the mutation.
func (m *HPFeedItemMutation) ViewHistoriesIDs() (ids []int) {
	for id := range m.view_histories {
		ids = append(ids, id)
	}
	return
}

// ResetViewHistories resets all changes to the "view_histories" edge.
func (m *HPFeedItemMutation) ResetViewHistories() {
	m.view_histories = nil
	m.clearedview_histories = false
	m.removedview_histories = nil
}

// ClearOwnerArtist clears the "owner_artist" edge to the HPArtist entity.
func (m *HPFeedItemMutation) ClearOwnerArtist() {
	m.clearedowner_artist = true
}

// OwnerArtistCleared reports if the "owner_artist" edge to the HPArtist entity was cleared.
func (m *HPFeedItemMutation) OwnerArtistCleared() bool {
	return m.OwnerArtistIDCleared() || m.clearedowner_artist
}

// OwnerArtistIDs returns the "owner_artist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerArtistID instead. It exists only for internal usage by the builders.
func (m *HPFeedItemMutation) OwnerArtistIDs() (ids []int) {
	if id := m.owner_artist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerArtist resets all changes to the "owner_artist" edge.
func (m *HPFeedItemMutation) ResetOwnerArtist() {
	m.owner_artist = nil
	m.clearedowner_artist = false
}

// ClearOwnerMember clears the "owner_member" edge to the HPMember entity.
func (m *HPFeedItemMutation) ClearOwnerMember() {
	m.clearedowner_member = true
}

// OwnerMemberCleared reports if the "owner_member" edge to the HPMember entity was cleared.
func (m *HPFeedItemMutation) OwnerMemberCleared() bool {
	return m.OwnerMemberIDCleared() || m.clearedowner_member
}

// OwnerMemberIDs returns the "owner_member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerMemberID instead. It exists only for internal usage by the builders.
func (m *HPFeedItemMutation) OwnerMemberIDs() (ids []int) {
	if id := m.owner_member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerMember resets all changes to the "owner_member" edge.
func (m *HPFeedItemMutation) ResetOwnerMember() {
	m.owner_member = nil
	m.clearedowner_member = false
}

// AddTaggedArtistIDs adds the "tagged_artists" edge to the HPArtist entity by ids.
func (m *HPFeedItemMutation) AddTaggedArtistIDs(ids ...int) {
	if m.tagged_artists == nil {
		m.tagged_artists = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_artists[ids[i]] = struct{}{}
	}
}

// ClearTaggedArtists clears the "tagged_artists" edge to the HPArtist entity.
func (m *HPFeedItemMutation) ClearTaggedArtists() {
	m.clearedtagged_artists = true
}

// TaggedArtistsCleared reports if the "tagged_artists" edge to the HPArtist entity was cleared.
func (m *HPFeedItemMutation) TaggedArtistsCleared() bool {
	return m.clearedtagged_artists
}

// RemoveTaggedArtistIDs removes the "tagged_artists" edge to the HPArtist entity by IDs.
func (m *HPFeedItemMutation) RemoveTaggedArtistIDs(ids ...int) {
	if m.removedtagged_artists == nil {
		m.removedtagged_artists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_artists, ids[i])
		m.removedtagged_artists[ids[i]] = struct{}{}
	}
}

// RemovedTaggedArtists returns the removed IDs of the "tagged_artists" edge to the HPArtist entity.
func (m *HPFeedItemMutation) RemovedTaggedArtistsIDs() (ids []int) {
	for id := range m.removedtagged_artists {
		ids = append(ids, id)
	}
	return
}

// TaggedArtistsIDs returns the "tagged_artists" edge IDs in the mutation.
func (m *HPFeedItemMutation) TaggedArtistsIDs() (ids []int) {
	for id := range m.tagged_artists {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedArtists resets all changes to the "tagged_artists" edge.
func (m *HPFeedItemMutation) ResetTaggedArtists() {
	m.tagged_artists = nil
	m.clearedtagged_artists = false
	m.removedtagged_artists = nil
}

// AddTaggedMemberIDs adds the "tagged_members" edge to the HPMember entity by ids.
func (m *HPFeedItemMutation) AddTaggedMemberIDs(ids ...int) {
	if m.tagged_members == nil {
		m.tagged_members = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_members[ids[i]] = struct{}{}
	}
}

// ClearTaggedMembers clears the "tagged_members" edge to the HPMember entity.
func (m *HPFeedItemMutation) ClearTaggedMembers() {
	m.clearedtagged_members = true
}

// TaggedMembersCleared reports if the "tagged_members" edge to the HPMember entity was cleared.
func (m *HPFeedItemMutation) TaggedMembersCleared() bool {
	return m.clearedtagged_members
}

// RemoveTaggedMemberIDs removes the "tagged_members" edge to the HPMember entity by IDs.
func (m *HPFeedItemMutation) RemoveTaggedMemberIDs(ids ...int) {
	if m.removedtagged_members == nil {
		m.removedtagged_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_members, ids[i])
		m.removedtagged_members[ids[i]] = struct{}{}
	}
}

// RemovedTaggedMembers returns the removed IDs of the "tagged_members" edge to the HPMember entity.
func (m *HPFeedItemMutation) RemovedTaggedMembersIDs() (ids []int) {
	for id := range m.removedtagged_members {
		ids = append(ids, id)
	}
	return
}

// TaggedMembersIDs returns the "tagged_members" edge IDs in the mutation.
func (m *HPFeedItemMutation) TaggedMembersIDs() (ids []int) {
	for id := range m.tagged_members {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedMembers resets all changes to the "tagged_members" edge.
func (m *HPFeedItemMutation) ResetTaggedMembers() {
	m.tagged_members = nil
	m.clearedtagged_members = false
	m.removedtagged_members = nil
}

// Where appends a list predicates to the HPFeedItemMutation builder.
func (m *HPFeedItemMutation) Where(ps ...predicate.HPFeedItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPFeedItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPFeedItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPFeedItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPFeedItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPFeedItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPFeedItem).
func (m *HPFeedItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPFeedItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, hpfeeditem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpfeeditem.FieldUpdatedAt)
	}
	if m.source_id != nil {
		fields = append(fields, hpfeeditem.FieldSourceID)
	}
	if m.asset_type != nil {
		fields = append(fields, hpfeeditem.FieldAssetType)
	}
	if m.title != nil {
		fields = append(fields, hpfeeditem.FieldTitle)
	}
	if m.post_at != nil {
		fields = append(fields, hpfeeditem.FieldPostAt)
	}
	if m.source_url != nil {
		fields = append(fields, hpfeeditem.FieldSourceURL)
	}
	if m.image_url != nil {
		fields = append(fields, hpfeeditem.FieldImageURL)
	}
	if m.media != nil {
		fields = append(fields, hpfeeditem.FieldMedia)
	}
	if m.owner_artist != nil {
		fields = append(fields, hpfeeditem.FieldOwnerArtistID)
	}
	if m.owner_member != nil {
		fields = append(fields, hpfeeditem.FieldOwnerMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPFeedItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpfeeditem.FieldCreatedAt:
		return m.CreatedAt()
	case hpfeeditem.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpfeeditem.FieldSourceID:
		return m.SourceID()
	case hpfeeditem.FieldAssetType:
		return m.AssetType()
	case hpfeeditem.FieldTitle:
		return m.Title()
	case hpfeeditem.FieldPostAt:
		return m.PostAt()
	case hpfeeditem.FieldSourceURL:
		return m.SourceURL()
	case hpfeeditem.FieldImageURL:
		return m.ImageURL()
	case hpfeeditem.FieldMedia:
		return m.Media()
	case hpfeeditem.FieldOwnerArtistID:
		return m.OwnerArtistID()
	case hpfeeditem.FieldOwnerMemberID:
		return m.OwnerMemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPFeedItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpfeeditem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpfeeditem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpfeeditem.FieldSourceID:
		return m.OldSourceID(ctx)
	case hpfeeditem.FieldAssetType:
		return m.OldAssetType(ctx)
	case hpfeeditem.FieldTitle:
		return m.OldTitle(ctx)
	case hpfeeditem.FieldPostAt:
		return m.OldPostAt(ctx)
	case hpfeeditem.FieldSourceURL:
		return m.OldSourceURL(ctx)
	case hpfeeditem.FieldImageURL:
		return m.OldImageURL(ctx)
	case hpfeeditem.FieldMedia:
		return m.OldMedia(ctx)
	case hpfeeditem.FieldOwnerArtistID:
		return m.OldOwnerArtistID(ctx)
	case hpfeeditem.FieldOwnerMemberID:
		return m.OldOwnerMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown HPFeedItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPFeedItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpfeeditem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpfeeditem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpfeeditem.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case hpfeeditem.FieldAssetType:
		v, ok := value.(enums.HPAssetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetType(v)
		return nil
	case hpfeeditem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case hpfeeditem.FieldPostAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostAt(v)
		return nil
	case hpfeeditem.FieldSourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceURL(v)
		return nil
	case hpfeeditem.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case hpfeeditem.FieldMedia:
		v, ok := value.([]jsonfields.Media)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedia(v)
		return nil
	case hpfeeditem.FieldOwnerArtistID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerArtistID(v)
		return nil
	case hpfeeditem.FieldOwnerMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown HPFeedItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPFeedItemMutation) AddedFields() []string {
	var fields []string
	if m.addsource_id != nil {
		fields = append(fields, hpfeeditem.FieldSourceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPFeedItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpfeeditem.FieldSourceID:
		return m.AddedSourceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPFeedItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpfeeditem.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceID(v)
		return nil
	}
	return fmt.Errorf("unknown HPFeedItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPFeedItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpfeeditem.FieldCreatedAt) {
		fields = append(fields, hpfeeditem.FieldCreatedAt)
	}
	if m.FieldCleared(hpfeeditem.FieldUpdatedAt) {
		fields = append(fields, hpfeeditem.FieldUpdatedAt)
	}
	if m.FieldCleared(hpfeeditem.FieldImageURL) {
		fields = append(fields, hpfeeditem.FieldImageURL)
	}
	if m.FieldCleared(hpfeeditem.FieldOwnerArtistID) {
		fields = append(fields, hpfeeditem.FieldOwnerArtistID)
	}
	if m.FieldCleared(hpfeeditem.FieldOwnerMemberID) {
		fields = append(fields, hpfeeditem.FieldOwnerMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPFeedItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPFeedItemMutation) ClearField(name string) error {
	switch name {
	case hpfeeditem.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpfeeditem.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpfeeditem.FieldImageURL:
		m.ClearImageURL()
		return nil
	case hpfeeditem.FieldOwnerArtistID:
		m.ClearOwnerArtistID()
		return nil
	case hpfeeditem.FieldOwnerMemberID:
		m.ClearOwnerMemberID()
		return nil
	}
	return fmt.Errorf("unknown HPFeedItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPFeedItemMutation) ResetField(name string) error {
	switch name {
	case hpfeeditem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpfeeditem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpfeeditem.FieldSourceID:
		m.ResetSourceID()
		return nil
	case hpfeeditem.FieldAssetType:
		m.ResetAssetType()
		return nil
	case hpfeeditem.FieldTitle:
		m.ResetTitle()
		return nil
	case hpfeeditem.FieldPostAt:
		m.ResetPostAt()
		return nil
	case hpfeeditem.FieldSourceURL:
		m.ResetSourceURL()
		return nil
	case hpfeeditem.FieldImageURL:
		m.ResetImageURL()
		return nil
	case hpfeeditem.FieldMedia:
		m.ResetMedia()
		return nil
	case hpfeeditem.FieldOwnerArtistID:
		m.ResetOwnerArtistID()
		return nil
	case hpfeeditem.FieldOwnerMemberID:
		m.ResetOwnerMemberID()
		return nil
	}
	return fmt.Errorf("unknown HPFeedItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPFeedItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.view_histories != nil {
		edges = append(edges, hpfeeditem.EdgeViewHistories)
	}
	if m.owner_artist != nil {
		edges = append(edges, hpfeeditem.EdgeOwnerArtist)
	}
	if m.owner_member != nil {
		edges = append(edges, hpfeeditem.EdgeOwnerMember)
	}
	if m.tagged_artists != nil {
		edges = append(edges, hpfeeditem.EdgeTaggedArtists)
	}
	if m.tagged_members != nil {
		edges = append(edges, hpfeeditem.EdgeTaggedMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPFeedItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpfeeditem.EdgeViewHistories:
		ids := make([]ent.Value, 0, len(m.view_histories))
		for id := range m.view_histories {
			ids = append(ids, id)
		}
		return ids
	case hpfeeditem.EdgeOwnerArtist:
		if id := m.owner_artist; id != nil {
			return []ent.Value{*id}
		}
	case hpfeeditem.EdgeOwnerMember:
		if id := m.owner_member; id != nil {
			return []ent.Value{*id}
		}
	case hpfeeditem.EdgeTaggedArtists:
		ids := make([]ent.Value, 0, len(m.tagged_artists))
		for id := range m.tagged_artists {
			ids = append(ids, id)
		}
		return ids
	case hpfeeditem.EdgeTaggedMembers:
		ids := make([]ent.Value, 0, len(m.tagged_members))
		for id := range m.tagged_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPFeedItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedview_histories != nil {
		edges = append(edges, hpfeeditem.EdgeViewHistories)
	}
	if m.removedtagged_artists != nil {
		edges = append(edges, hpfeeditem.EdgeTaggedArtists)
	}
	if m.removedtagged_members != nil {
		edges = append(edges, hpfeeditem.EdgeTaggedMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPFeedItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpfeeditem.EdgeViewHistories:
		ids := make([]ent.Value, 0, len(m.removedview_histories))
		for id := range m.removedview_histories {
			ids = append(ids, id)
		}
		return ids
	case hpfeeditem.EdgeTaggedArtists:
		ids := make([]ent.Value, 0, len(m.removedtagged_artists))
		for id := range m.removedtagged_artists {
			ids = append(ids, id)
		}
		return ids
	case hpfeeditem.EdgeTaggedMembers:
		ids := make([]ent.Value, 0, len(m.removedtagged_members))
		for id := range m.removedtagged_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPFeedItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedview_histories {
		edges = append(edges, hpfeeditem.EdgeViewHistories)
	}
	if m.clearedowner_artist {
		edges = append(edges, hpfeeditem.EdgeOwnerArtist)
	}
	if m.clearedowner_member {
		edges = append(edges, hpfeeditem.EdgeOwnerMember)
	}
	if m.clearedtagged_artists {
		edges = append(edges, hpfeeditem.EdgeTaggedArtists)
	}
	if m.clearedtagged_members {
		edges = append(edges, hpfeeditem.EdgeTaggedMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPFeedItemMutation) EdgeCleared(name string) bool {
	switch name {
	case hpfeeditem.EdgeViewHistories:
		return m.clearedview_histories
	case hpfeeditem.EdgeOwnerArtist:
		return m.clearedowner_artist
	case hpfeeditem.EdgeOwnerMember:
		return m.clearedowner_member
	case hpfeeditem.EdgeTaggedArtists:
		return m.clearedtagged_artists
	case hpfeeditem.EdgeTaggedMembers:
		return m.clearedtagged_members
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPFeedItemMutation) ClearEdge(name string) error {
	switch name {
	case hpfeeditem.EdgeOwnerArtist:
		m.ClearOwnerArtist()
		return nil
	case hpfeeditem.EdgeOwnerMember:
		m.ClearOwnerMember()
		return nil
	}
	return fmt.Errorf("unknown HPFeedItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPFeedItemMutation) ResetEdge(name string) error {
	switch name {
	case hpfeeditem.EdgeViewHistories:
		m.ResetViewHistories()
		return nil
	case hpfeeditem.EdgeOwnerArtist:
		m.ResetOwnerArtist()
		return nil
	case hpfeeditem.EdgeOwnerMember:
		m.ResetOwnerMember()
		return nil
	case hpfeeditem.EdgeTaggedArtists:
		m.ResetTaggedArtists()
		return nil
	case hpfeeditem.EdgeTaggedMembers:
		m.ResetTaggedMembers()
		return nil
	}
	return fmt.Errorf("unknown HPFeedItem edge %s", name)
}

// HPFollowMutation represents an operation that mutates the HPFollow nodes in the graph.
type HPFollowMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	created_at                           *time.Time
	updated_at                           *time.Time
	_type                                *enums.HPFollowType
	elineupmall_other                    *enums.HPFollowType
	elineupmall_photo_daily              *enums.HPFollowType
	elineupmall_photo_a4                 *enums.HPFollowType
	elineupmall_photo_a5                 *enums.HPFollowType
	elineupmall_photo_2l                 *enums.HPFollowType
	elineupmall_photo_other              *enums.HPFollowType
	elineupmall_photo_album              *enums.HPFollowType
	elineupmall_photo_album_other        *enums.HPFollowType
	elineupmall_photo_book               *enums.HPFollowType
	elineupmall_photo_book_other         *enums.HPFollowType
	elineupmall_dvd                      *enums.HPFollowType
	elineupmall_dvd_magazine             *enums.HPFollowType
	elineupmall_dvd_magazine_other       *enums.HPFollowType
	elineupmall_blueray                  *enums.HPFollowType
	elineupmall_penlight                 *enums.HPFollowType
	elineupmall_collection_pinnap_poster *enums.HPFollowType
	elineupmall_collection_photo         *enums.HPFollowType
	elineupmall_collection_other         *enums.HPFollowType
	elineupmall_tshirt                   *enums.HPFollowType
	elineupmall_microfiber_towel         *enums.HPFollowType
	elineupmall_muffler_towel            *enums.HPFollowType
	elineupmall_fsk                      *enums.HPFollowType
	elineupmall_keyring_other            *enums.HPFollowType
	elineupmall_clear_file               *enums.HPFollowType
	clearedFields                        map[string]struct{}
	user                                 *int
	cleareduser                          bool
	member                               *int
	clearedmember                        bool
	artist                               *int
	clearedartist                        bool
	done                                 bool
	oldValue                             func(context.Context) (*HPFollow, error)
	predicates                           []predicate.HPFollow
}

var _ ent.Mutation = (*HPFollowMutation)(nil)

// hpfollowOption allows management of the mutation configuration using functional options.
type hpfollowOption func(*HPFollowMutation)

// newHPFollowMutation creates new mutation for the HPFollow entity.
func newHPFollowMutation(c config, op Op, opts ...hpfollowOption) *HPFollowMutation {
	m := &HPFollowMutation{
		config:        c,
		op:            op,
		typ:           TypeHPFollow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPFollowID sets the ID field of the mutation.
func withHPFollowID(id int) hpfollowOption {
	return func(m *HPFollowMutation) {
		var (
			err   error
			once  sync.Once
			value *HPFollow
		)
		m.oldValue = func(ctx context.Context) (*HPFollow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPFollow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPFollow sets the old HPFollow of the mutation.
func withHPFollow(node *HPFollow) hpfollowOption {
	return func(m *HPFollowMutation) {
		m.oldValue = func(context.Context) (*HPFollow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPFollowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPFollowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPFollowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPFollowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPFollow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HPFollowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPFollowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPFollowMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpfollow.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPFollowMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpfollow.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPFollowMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpfollow.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPFollowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPFollowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPFollowMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpfollow.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPFollowMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpfollow.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPFollowMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpfollow.FieldUpdatedAt)
}

// SetType sets the "type" field.
func (m *HPFollowMutation) SetType(eft enums.HPFollowType) {
	m._type = &eft
}

// GetType returns the value of the "type" field in the mutation.
func (m *HPFollowMutation) GetType() (r enums.HPFollowType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldType(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *HPFollowMutation) ResetType() {
	m._type = nil
}

// SetElineupmallOther sets the "elineupmall_other" field.
func (m *HPFollowMutation) SetElineupmallOther(eft enums.HPFollowType) {
	m.elineupmall_other = &eft
}

// ElineupmallOther returns the value of the "elineupmall_other" field in the mutation.
func (m *HPFollowMutation) ElineupmallOther() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_other
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallOther returns the old "elineupmall_other" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallOther(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallOther: %w", err)
	}
	return oldValue.ElineupmallOther, nil
}

// ResetElineupmallOther resets all changes to the "elineupmall_other" field.
func (m *HPFollowMutation) ResetElineupmallOther() {
	m.elineupmall_other = nil
}

// SetElineupmallPhotoDaily sets the "elineupmall_photo_daily" field.
func (m *HPFollowMutation) SetElineupmallPhotoDaily(eft enums.HPFollowType) {
	m.elineupmall_photo_daily = &eft
}

// ElineupmallPhotoDaily returns the value of the "elineupmall_photo_daily" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhotoDaily() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_daily
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhotoDaily returns the old "elineupmall_photo_daily" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhotoDaily(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhotoDaily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhotoDaily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhotoDaily: %w", err)
	}
	return oldValue.ElineupmallPhotoDaily, nil
}

// ResetElineupmallPhotoDaily resets all changes to the "elineupmall_photo_daily" field.
func (m *HPFollowMutation) ResetElineupmallPhotoDaily() {
	m.elineupmall_photo_daily = nil
}

// SetElineupmallPhotoA4 sets the "elineupmall_photo_a4" field.
func (m *HPFollowMutation) SetElineupmallPhotoA4(eft enums.HPFollowType) {
	m.elineupmall_photo_a4 = &eft
}

// ElineupmallPhotoA4 returns the value of the "elineupmall_photo_a4" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhotoA4() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_a4
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhotoA4 returns the old "elineupmall_photo_a4" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhotoA4(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhotoA4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhotoA4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhotoA4: %w", err)
	}
	return oldValue.ElineupmallPhotoA4, nil
}

// ResetElineupmallPhotoA4 resets all changes to the "elineupmall_photo_a4" field.
func (m *HPFollowMutation) ResetElineupmallPhotoA4() {
	m.elineupmall_photo_a4 = nil
}

// SetElineupmallPhotoA5 sets the "elineupmall_photo_a5" field.
func (m *HPFollowMutation) SetElineupmallPhotoA5(eft enums.HPFollowType) {
	m.elineupmall_photo_a5 = &eft
}

// ElineupmallPhotoA5 returns the value of the "elineupmall_photo_a5" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhotoA5() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_a5
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhotoA5 returns the old "elineupmall_photo_a5" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhotoA5(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhotoA5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhotoA5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhotoA5: %w", err)
	}
	return oldValue.ElineupmallPhotoA5, nil
}

// ResetElineupmallPhotoA5 resets all changes to the "elineupmall_photo_a5" field.
func (m *HPFollowMutation) ResetElineupmallPhotoA5() {
	m.elineupmall_photo_a5 = nil
}

// SetElineupmallPhoto2l sets the "elineupmall_photo_2l" field.
func (m *HPFollowMutation) SetElineupmallPhoto2l(eft enums.HPFollowType) {
	m.elineupmall_photo_2l = &eft
}

// ElineupmallPhoto2l returns the value of the "elineupmall_photo_2l" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhoto2l() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_2l
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhoto2l returns the old "elineupmall_photo_2l" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhoto2l(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhoto2l is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhoto2l requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhoto2l: %w", err)
	}
	return oldValue.ElineupmallPhoto2l, nil
}

// ResetElineupmallPhoto2l resets all changes to the "elineupmall_photo_2l" field.
func (m *HPFollowMutation) ResetElineupmallPhoto2l() {
	m.elineupmall_photo_2l = nil
}

// SetElineupmallPhotoOther sets the "elineupmall_photo_other" field.
func (m *HPFollowMutation) SetElineupmallPhotoOther(eft enums.HPFollowType) {
	m.elineupmall_photo_other = &eft
}

// ElineupmallPhotoOther returns the value of the "elineupmall_photo_other" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhotoOther() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_other
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhotoOther returns the old "elineupmall_photo_other" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhotoOther(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhotoOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhotoOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhotoOther: %w", err)
	}
	return oldValue.ElineupmallPhotoOther, nil
}

// ResetElineupmallPhotoOther resets all changes to the "elineupmall_photo_other" field.
func (m *HPFollowMutation) ResetElineupmallPhotoOther() {
	m.elineupmall_photo_other = nil
}

// SetElineupmallPhotoAlbum sets the "elineupmall_photo_album" field.
func (m *HPFollowMutation) SetElineupmallPhotoAlbum(eft enums.HPFollowType) {
	m.elineupmall_photo_album = &eft
}

// ElineupmallPhotoAlbum returns the value of the "elineupmall_photo_album" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhotoAlbum() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_album
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhotoAlbum returns the old "elineupmall_photo_album" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhotoAlbum(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhotoAlbum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhotoAlbum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhotoAlbum: %w", err)
	}
	return oldValue.ElineupmallPhotoAlbum, nil
}

// ResetElineupmallPhotoAlbum resets all changes to the "elineupmall_photo_album" field.
func (m *HPFollowMutation) ResetElineupmallPhotoAlbum() {
	m.elineupmall_photo_album = nil
}

// SetElineupmallPhotoAlbumOther sets the "elineupmall_photo_album_other" field.
func (m *HPFollowMutation) SetElineupmallPhotoAlbumOther(eft enums.HPFollowType) {
	m.elineupmall_photo_album_other = &eft
}

// ElineupmallPhotoAlbumOther returns the value of the "elineupmall_photo_album_other" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhotoAlbumOther() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_album_other
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhotoAlbumOther returns the old "elineupmall_photo_album_other" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhotoAlbumOther(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhotoAlbumOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhotoAlbumOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhotoAlbumOther: %w", err)
	}
	return oldValue.ElineupmallPhotoAlbumOther, nil
}

// ResetElineupmallPhotoAlbumOther resets all changes to the "elineupmall_photo_album_other" field.
func (m *HPFollowMutation) ResetElineupmallPhotoAlbumOther() {
	m.elineupmall_photo_album_other = nil
}

// SetElineupmallPhotoBook sets the "elineupmall_photo_book" field.
func (m *HPFollowMutation) SetElineupmallPhotoBook(eft enums.HPFollowType) {
	m.elineupmall_photo_book = &eft
}

// ElineupmallPhotoBook returns the value of the "elineupmall_photo_book" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhotoBook() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_book
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhotoBook returns the old "elineupmall_photo_book" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhotoBook(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhotoBook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhotoBook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhotoBook: %w", err)
	}
	return oldValue.ElineupmallPhotoBook, nil
}

// ResetElineupmallPhotoBook resets all changes to the "elineupmall_photo_book" field.
func (m *HPFollowMutation) ResetElineupmallPhotoBook() {
	m.elineupmall_photo_book = nil
}

// SetElineupmallPhotoBookOther sets the "elineupmall_photo_book_other" field.
func (m *HPFollowMutation) SetElineupmallPhotoBookOther(eft enums.HPFollowType) {
	m.elineupmall_photo_book_other = &eft
}

// ElineupmallPhotoBookOther returns the value of the "elineupmall_photo_book_other" field in the mutation.
func (m *HPFollowMutation) ElineupmallPhotoBookOther() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_photo_book_other
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPhotoBookOther returns the old "elineupmall_photo_book_other" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPhotoBookOther(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPhotoBookOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPhotoBookOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPhotoBookOther: %w", err)
	}
	return oldValue.ElineupmallPhotoBookOther, nil
}

// ResetElineupmallPhotoBookOther resets all changes to the "elineupmall_photo_book_other" field.
func (m *HPFollowMutation) ResetElineupmallPhotoBookOther() {
	m.elineupmall_photo_book_other = nil
}

// SetElineupmallDvd sets the "elineupmall_dvd" field.
func (m *HPFollowMutation) SetElineupmallDvd(eft enums.HPFollowType) {
	m.elineupmall_dvd = &eft
}

// ElineupmallDvd returns the value of the "elineupmall_dvd" field in the mutation.
func (m *HPFollowMutation) ElineupmallDvd() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_dvd
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallDvd returns the old "elineupmall_dvd" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallDvd(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallDvd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallDvd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallDvd: %w", err)
	}
	return oldValue.ElineupmallDvd, nil
}

// ResetElineupmallDvd resets all changes to the "elineupmall_dvd" field.
func (m *HPFollowMutation) ResetElineupmallDvd() {
	m.elineupmall_dvd = nil
}

// SetElineupmallDvdMagazine sets the "elineupmall_dvd_magazine" field.
func (m *HPFollowMutation) SetElineupmallDvdMagazine(eft enums.HPFollowType) {
	m.elineupmall_dvd_magazine = &eft
}

// ElineupmallDvdMagazine returns the value of the "elineupmall_dvd_magazine" field in the mutation.
func (m *HPFollowMutation) ElineupmallDvdMagazine() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_dvd_magazine
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallDvdMagazine returns the old "elineupmall_dvd_magazine" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallDvdMagazine(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallDvdMagazine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallDvdMagazine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallDvdMagazine: %w", err)
	}
	return oldValue.ElineupmallDvdMagazine, nil
}

// ResetElineupmallDvdMagazine resets all changes to the "elineupmall_dvd_magazine" field.
func (m *HPFollowMutation) ResetElineupmallDvdMagazine() {
	m.elineupmall_dvd_magazine = nil
}

// SetElineupmallDvdMagazineOther sets the "elineupmall_dvd_magazine_other" field.
func (m *HPFollowMutation) SetElineupmallDvdMagazineOther(eft enums.HPFollowType) {
	m.elineupmall_dvd_magazine_other = &eft
}

// ElineupmallDvdMagazineOther returns the value of the "elineupmall_dvd_magazine_other" field in the mutation.
func (m *HPFollowMutation) ElineupmallDvdMagazineOther() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_dvd_magazine_other
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallDvdMagazineOther returns the old "elineupmall_dvd_magazine_other" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallDvdMagazineOther(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallDvdMagazineOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallDvdMagazineOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallDvdMagazineOther: %w", err)
	}
	return oldValue.ElineupmallDvdMagazineOther, nil
}

// ResetElineupmallDvdMagazineOther resets all changes to the "elineupmall_dvd_magazine_other" field.
func (m *HPFollowMutation) ResetElineupmallDvdMagazineOther() {
	m.elineupmall_dvd_magazine_other = nil
}

// SetElineupmallBlueray sets the "elineupmall_blueray" field.
func (m *HPFollowMutation) SetElineupmallBlueray(eft enums.HPFollowType) {
	m.elineupmall_blueray = &eft
}

// ElineupmallBlueray returns the value of the "elineupmall_blueray" field in the mutation.
func (m *HPFollowMutation) ElineupmallBlueray() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_blueray
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallBlueray returns the old "elineupmall_blueray" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallBlueray(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallBlueray is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallBlueray requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallBlueray: %w", err)
	}
	return oldValue.ElineupmallBlueray, nil
}

// ResetElineupmallBlueray resets all changes to the "elineupmall_blueray" field.
func (m *HPFollowMutation) ResetElineupmallBlueray() {
	m.elineupmall_blueray = nil
}

// SetElineupmallPenlight sets the "elineupmall_penlight" field.
func (m *HPFollowMutation) SetElineupmallPenlight(eft enums.HPFollowType) {
	m.elineupmall_penlight = &eft
}

// ElineupmallPenlight returns the value of the "elineupmall_penlight" field in the mutation.
func (m *HPFollowMutation) ElineupmallPenlight() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_penlight
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallPenlight returns the old "elineupmall_penlight" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallPenlight(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallPenlight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallPenlight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallPenlight: %w", err)
	}
	return oldValue.ElineupmallPenlight, nil
}

// ResetElineupmallPenlight resets all changes to the "elineupmall_penlight" field.
func (m *HPFollowMutation) ResetElineupmallPenlight() {
	m.elineupmall_penlight = nil
}

// SetElineupmallCollectionPinnapPoster sets the "elineupmall_collection_pinnap_poster" field.
func (m *HPFollowMutation) SetElineupmallCollectionPinnapPoster(eft enums.HPFollowType) {
	m.elineupmall_collection_pinnap_poster = &eft
}

// ElineupmallCollectionPinnapPoster returns the value of the "elineupmall_collection_pinnap_poster" field in the mutation.
func (m *HPFollowMutation) ElineupmallCollectionPinnapPoster() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_collection_pinnap_poster
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallCollectionPinnapPoster returns the old "elineupmall_collection_pinnap_poster" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallCollectionPinnapPoster(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallCollectionPinnapPoster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallCollectionPinnapPoster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallCollectionPinnapPoster: %w", err)
	}
	return oldValue.ElineupmallCollectionPinnapPoster, nil
}

// ResetElineupmallCollectionPinnapPoster resets all changes to the "elineupmall_collection_pinnap_poster" field.
func (m *HPFollowMutation) ResetElineupmallCollectionPinnapPoster() {
	m.elineupmall_collection_pinnap_poster = nil
}

// SetElineupmallCollectionPhoto sets the "elineupmall_collection_photo" field.
func (m *HPFollowMutation) SetElineupmallCollectionPhoto(eft enums.HPFollowType) {
	m.elineupmall_collection_photo = &eft
}

// ElineupmallCollectionPhoto returns the value of the "elineupmall_collection_photo" field in the mutation.
func (m *HPFollowMutation) ElineupmallCollectionPhoto() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_collection_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallCollectionPhoto returns the old "elineupmall_collection_photo" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallCollectionPhoto(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallCollectionPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallCollectionPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallCollectionPhoto: %w", err)
	}
	return oldValue.ElineupmallCollectionPhoto, nil
}

// ResetElineupmallCollectionPhoto resets all changes to the "elineupmall_collection_photo" field.
func (m *HPFollowMutation) ResetElineupmallCollectionPhoto() {
	m.elineupmall_collection_photo = nil
}

// SetElineupmallCollectionOther sets the "elineupmall_collection_other" field.
func (m *HPFollowMutation) SetElineupmallCollectionOther(eft enums.HPFollowType) {
	m.elineupmall_collection_other = &eft
}

// ElineupmallCollectionOther returns the value of the "elineupmall_collection_other" field in the mutation.
func (m *HPFollowMutation) ElineupmallCollectionOther() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_collection_other
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallCollectionOther returns the old "elineupmall_collection_other" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallCollectionOther(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallCollectionOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallCollectionOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallCollectionOther: %w", err)
	}
	return oldValue.ElineupmallCollectionOther, nil
}

// ResetElineupmallCollectionOther resets all changes to the "elineupmall_collection_other" field.
func (m *HPFollowMutation) ResetElineupmallCollectionOther() {
	m.elineupmall_collection_other = nil
}

// SetElineupmallTshirt sets the "elineupmall_tshirt" field.
func (m *HPFollowMutation) SetElineupmallTshirt(eft enums.HPFollowType) {
	m.elineupmall_tshirt = &eft
}

// ElineupmallTshirt returns the value of the "elineupmall_tshirt" field in the mutation.
func (m *HPFollowMutation) ElineupmallTshirt() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_tshirt
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallTshirt returns the old "elineupmall_tshirt" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallTshirt(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallTshirt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallTshirt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallTshirt: %w", err)
	}
	return oldValue.ElineupmallTshirt, nil
}

// ResetElineupmallTshirt resets all changes to the "elineupmall_tshirt" field.
func (m *HPFollowMutation) ResetElineupmallTshirt() {
	m.elineupmall_tshirt = nil
}

// SetElineupmallMicrofiberTowel sets the "elineupmall_microfiber_towel" field.
func (m *HPFollowMutation) SetElineupmallMicrofiberTowel(eft enums.HPFollowType) {
	m.elineupmall_microfiber_towel = &eft
}

// ElineupmallMicrofiberTowel returns the value of the "elineupmall_microfiber_towel" field in the mutation.
func (m *HPFollowMutation) ElineupmallMicrofiberTowel() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_microfiber_towel
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallMicrofiberTowel returns the old "elineupmall_microfiber_towel" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallMicrofiberTowel(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallMicrofiberTowel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallMicrofiberTowel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallMicrofiberTowel: %w", err)
	}
	return oldValue.ElineupmallMicrofiberTowel, nil
}

// ResetElineupmallMicrofiberTowel resets all changes to the "elineupmall_microfiber_towel" field.
func (m *HPFollowMutation) ResetElineupmallMicrofiberTowel() {
	m.elineupmall_microfiber_towel = nil
}

// SetElineupmallMufflerTowel sets the "elineupmall_muffler_towel" field.
func (m *HPFollowMutation) SetElineupmallMufflerTowel(eft enums.HPFollowType) {
	m.elineupmall_muffler_towel = &eft
}

// ElineupmallMufflerTowel returns the value of the "elineupmall_muffler_towel" field in the mutation.
func (m *HPFollowMutation) ElineupmallMufflerTowel() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_muffler_towel
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallMufflerTowel returns the old "elineupmall_muffler_towel" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallMufflerTowel(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallMufflerTowel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallMufflerTowel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallMufflerTowel: %w", err)
	}
	return oldValue.ElineupmallMufflerTowel, nil
}

// ResetElineupmallMufflerTowel resets all changes to the "elineupmall_muffler_towel" field.
func (m *HPFollowMutation) ResetElineupmallMufflerTowel() {
	m.elineupmall_muffler_towel = nil
}

// SetElineupmallFsk sets the "elineupmall_fsk" field.
func (m *HPFollowMutation) SetElineupmallFsk(eft enums.HPFollowType) {
	m.elineupmall_fsk = &eft
}

// ElineupmallFsk returns the value of the "elineupmall_fsk" field in the mutation.
func (m *HPFollowMutation) ElineupmallFsk() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_fsk
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallFsk returns the old "elineupmall_fsk" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallFsk(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallFsk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallFsk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallFsk: %w", err)
	}
	return oldValue.ElineupmallFsk, nil
}

// ResetElineupmallFsk resets all changes to the "elineupmall_fsk" field.
func (m *HPFollowMutation) ResetElineupmallFsk() {
	m.elineupmall_fsk = nil
}

// SetElineupmallKeyringOther sets the "elineupmall_keyring_other" field.
func (m *HPFollowMutation) SetElineupmallKeyringOther(eft enums.HPFollowType) {
	m.elineupmall_keyring_other = &eft
}

// ElineupmallKeyringOther returns the value of the "elineupmall_keyring_other" field in the mutation.
func (m *HPFollowMutation) ElineupmallKeyringOther() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_keyring_other
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallKeyringOther returns the old "elineupmall_keyring_other" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallKeyringOther(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallKeyringOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallKeyringOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallKeyringOther: %w", err)
	}
	return oldValue.ElineupmallKeyringOther, nil
}

// ResetElineupmallKeyringOther resets all changes to the "elineupmall_keyring_other" field.
func (m *HPFollowMutation) ResetElineupmallKeyringOther() {
	m.elineupmall_keyring_other = nil
}

// SetElineupmallClearFile sets the "elineupmall_clear_file" field.
func (m *HPFollowMutation) SetElineupmallClearFile(eft enums.HPFollowType) {
	m.elineupmall_clear_file = &eft
}

// ElineupmallClearFile returns the value of the "elineupmall_clear_file" field in the mutation.
func (m *HPFollowMutation) ElineupmallClearFile() (r enums.HPFollowType, exists bool) {
	v := m.elineupmall_clear_file
	if v == nil {
		return
	}
	return *v, true
}

// OldElineupmallClearFile returns the old "elineupmall_clear_file" field's value of the HPFollow entity.
// If the HPFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPFollowMutation) OldElineupmallClearFile(ctx context.Context) (v enums.HPFollowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElineupmallClearFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElineupmallClearFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElineupmallClearFile: %w", err)
	}
	return oldValue.ElineupmallClearFile, nil
}

// ResetElineupmallClearFile resets all changes to the "elineupmall_clear_file" field.
func (m *HPFollowMutation) ResetElineupmallClearFile() {
	m.elineupmall_clear_file = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *HPFollowMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *HPFollowMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *HPFollowMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *HPFollowMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *HPFollowMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *HPFollowMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetMemberID sets the "member" edge to the HPMember entity by id.
func (m *HPFollowMutation) SetMemberID(id int) {
	m.member = &id
}

// ClearMember clears the "member" edge to the HPMember entity.
func (m *HPFollowMutation) ClearMember() {
	m.clearedmember = true
}

// MemberCleared reports if the "member" edge to the HPMember entity was cleared.
func (m *HPFollowMutation) MemberCleared() bool {
	return m.clearedmember
}

// MemberID returns the "member" edge ID in the mutation.
func (m *HPFollowMutation) MemberID() (id int, exists bool) {
	if m.member != nil {
		return *m.member, true
	}
	return
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *HPFollowMutation) MemberIDs() (ids []int) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *HPFollowMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// SetArtistID sets the "artist" edge to the HPArtist entity by id.
func (m *HPFollowMutation) SetArtistID(id int) {
	m.artist = &id
}

// ClearArtist clears the "artist" edge to the HPArtist entity.
func (m *HPFollowMutation) ClearArtist() {
	m.clearedartist = true
}

// ArtistCleared reports if the "artist" edge to the HPArtist entity was cleared.
func (m *HPFollowMutation) ArtistCleared() bool {
	return m.clearedartist
}

// ArtistID returns the "artist" edge ID in the mutation.
func (m *HPFollowMutation) ArtistID() (id int, exists bool) {
	if m.artist != nil {
		return *m.artist, true
	}
	return
}

// ArtistIDs returns the "artist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtistID instead. It exists only for internal usage by the builders.
func (m *HPFollowMutation) ArtistIDs() (ids []int) {
	if id := m.artist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtist resets all changes to the "artist" edge.
func (m *HPFollowMutation) ResetArtist() {
	m.artist = nil
	m.clearedartist = false
}

// Where appends a list predicates to the HPFollowMutation builder.
func (m *HPFollowMutation) Where(ps ...predicate.HPFollow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPFollowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPFollowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPFollow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPFollowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPFollowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPFollow).
func (m *HPFollowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPFollowMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.created_at != nil {
		fields = append(fields, hpfollow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpfollow.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, hpfollow.FieldType)
	}
	if m.elineupmall_other != nil {
		fields = append(fields, hpfollow.FieldElineupmallOther)
	}
	if m.elineupmall_photo_daily != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhotoDaily)
	}
	if m.elineupmall_photo_a4 != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhotoA4)
	}
	if m.elineupmall_photo_a5 != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhotoA5)
	}
	if m.elineupmall_photo_2l != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhoto2l)
	}
	if m.elineupmall_photo_other != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhotoOther)
	}
	if m.elineupmall_photo_album != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhotoAlbum)
	}
	if m.elineupmall_photo_album_other != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhotoAlbumOther)
	}
	if m.elineupmall_photo_book != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhotoBook)
	}
	if m.elineupmall_photo_book_other != nil {
		fields = append(fields, hpfollow.FieldElineupmallPhotoBookOther)
	}
	if m.elineupmall_dvd != nil {
		fields = append(fields, hpfollow.FieldElineupmallDvd)
	}
	if m.elineupmall_dvd_magazine != nil {
		fields = append(fields, hpfollow.FieldElineupmallDvdMagazine)
	}
	if m.elineupmall_dvd_magazine_other != nil {
		fields = append(fields, hpfollow.FieldElineupmallDvdMagazineOther)
	}
	if m.elineupmall_blueray != nil {
		fields = append(fields, hpfollow.FieldElineupmallBlueray)
	}
	if m.elineupmall_penlight != nil {
		fields = append(fields, hpfollow.FieldElineupmallPenlight)
	}
	if m.elineupmall_collection_pinnap_poster != nil {
		fields = append(fields, hpfollow.FieldElineupmallCollectionPinnapPoster)
	}
	if m.elineupmall_collection_photo != nil {
		fields = append(fields, hpfollow.FieldElineupmallCollectionPhoto)
	}
	if m.elineupmall_collection_other != nil {
		fields = append(fields, hpfollow.FieldElineupmallCollectionOther)
	}
	if m.elineupmall_tshirt != nil {
		fields = append(fields, hpfollow.FieldElineupmallTshirt)
	}
	if m.elineupmall_microfiber_towel != nil {
		fields = append(fields, hpfollow.FieldElineupmallMicrofiberTowel)
	}
	if m.elineupmall_muffler_towel != nil {
		fields = append(fields, hpfollow.FieldElineupmallMufflerTowel)
	}
	if m.elineupmall_fsk != nil {
		fields = append(fields, hpfollow.FieldElineupmallFsk)
	}
	if m.elineupmall_keyring_other != nil {
		fields = append(fields, hpfollow.FieldElineupmallKeyringOther)
	}
	if m.elineupmall_clear_file != nil {
		fields = append(fields, hpfollow.FieldElineupmallClearFile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPFollowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpfollow.FieldCreatedAt:
		return m.CreatedAt()
	case hpfollow.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpfollow.FieldType:
		return m.GetType()
	case hpfollow.FieldElineupmallOther:
		return m.ElineupmallOther()
	case hpfollow.FieldElineupmallPhotoDaily:
		return m.ElineupmallPhotoDaily()
	case hpfollow.FieldElineupmallPhotoA4:
		return m.ElineupmallPhotoA4()
	case hpfollow.FieldElineupmallPhotoA5:
		return m.ElineupmallPhotoA5()
	case hpfollow.FieldElineupmallPhoto2l:
		return m.ElineupmallPhoto2l()
	case hpfollow.FieldElineupmallPhotoOther:
		return m.ElineupmallPhotoOther()
	case hpfollow.FieldElineupmallPhotoAlbum:
		return m.ElineupmallPhotoAlbum()
	case hpfollow.FieldElineupmallPhotoAlbumOther:
		return m.ElineupmallPhotoAlbumOther()
	case hpfollow.FieldElineupmallPhotoBook:
		return m.ElineupmallPhotoBook()
	case hpfollow.FieldElineupmallPhotoBookOther:
		return m.ElineupmallPhotoBookOther()
	case hpfollow.FieldElineupmallDvd:
		return m.ElineupmallDvd()
	case hpfollow.FieldElineupmallDvdMagazine:
		return m.ElineupmallDvdMagazine()
	case hpfollow.FieldElineupmallDvdMagazineOther:
		return m.ElineupmallDvdMagazineOther()
	case hpfollow.FieldElineupmallBlueray:
		return m.ElineupmallBlueray()
	case hpfollow.FieldElineupmallPenlight:
		return m.ElineupmallPenlight()
	case hpfollow.FieldElineupmallCollectionPinnapPoster:
		return m.ElineupmallCollectionPinnapPoster()
	case hpfollow.FieldElineupmallCollectionPhoto:
		return m.ElineupmallCollectionPhoto()
	case hpfollow.FieldElineupmallCollectionOther:
		return m.ElineupmallCollectionOther()
	case hpfollow.FieldElineupmallTshirt:
		return m.ElineupmallTshirt()
	case hpfollow.FieldElineupmallMicrofiberTowel:
		return m.ElineupmallMicrofiberTowel()
	case hpfollow.FieldElineupmallMufflerTowel:
		return m.ElineupmallMufflerTowel()
	case hpfollow.FieldElineupmallFsk:
		return m.ElineupmallFsk()
	case hpfollow.FieldElineupmallKeyringOther:
		return m.ElineupmallKeyringOther()
	case hpfollow.FieldElineupmallClearFile:
		return m.ElineupmallClearFile()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPFollowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpfollow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpfollow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpfollow.FieldType:
		return m.OldType(ctx)
	case hpfollow.FieldElineupmallOther:
		return m.OldElineupmallOther(ctx)
	case hpfollow.FieldElineupmallPhotoDaily:
		return m.OldElineupmallPhotoDaily(ctx)
	case hpfollow.FieldElineupmallPhotoA4:
		return m.OldElineupmallPhotoA4(ctx)
	case hpfollow.FieldElineupmallPhotoA5:
		return m.OldElineupmallPhotoA5(ctx)
	case hpfollow.FieldElineupmallPhoto2l:
		return m.OldElineupmallPhoto2l(ctx)
	case hpfollow.FieldElineupmallPhotoOther:
		return m.OldElineupmallPhotoOther(ctx)
	case hpfollow.FieldElineupmallPhotoAlbum:
		return m.OldElineupmallPhotoAlbum(ctx)
	case hpfollow.FieldElineupmallPhotoAlbumOther:
		return m.OldElineupmallPhotoAlbumOther(ctx)
	case hpfollow.FieldElineupmallPhotoBook:
		return m.OldElineupmallPhotoBook(ctx)
	case hpfollow.FieldElineupmallPhotoBookOther:
		return m.OldElineupmallPhotoBookOther(ctx)
	case hpfollow.FieldElineupmallDvd:
		return m.OldElineupmallDvd(ctx)
	case hpfollow.FieldElineupmallDvdMagazine:
		return m.OldElineupmallDvdMagazine(ctx)
	case hpfollow.FieldElineupmallDvdMagazineOther:
		return m.OldElineupmallDvdMagazineOther(ctx)
	case hpfollow.FieldElineupmallBlueray:
		return m.OldElineupmallBlueray(ctx)
	case hpfollow.FieldElineupmallPenlight:
		return m.OldElineupmallPenlight(ctx)
	case hpfollow.FieldElineupmallCollectionPinnapPoster:
		return m.OldElineupmallCollectionPinnapPoster(ctx)
	case hpfollow.FieldElineupmallCollectionPhoto:
		return m.OldElineupmallCollectionPhoto(ctx)
	case hpfollow.FieldElineupmallCollectionOther:
		return m.OldElineupmallCollectionOther(ctx)
	case hpfollow.FieldElineupmallTshirt:
		return m.OldElineupmallTshirt(ctx)
	case hpfollow.FieldElineupmallMicrofiberTowel:
		return m.OldElineupmallMicrofiberTowel(ctx)
	case hpfollow.FieldElineupmallMufflerTowel:
		return m.OldElineupmallMufflerTowel(ctx)
	case hpfollow.FieldElineupmallFsk:
		return m.OldElineupmallFsk(ctx)
	case hpfollow.FieldElineupmallKeyringOther:
		return m.OldElineupmallKeyringOther(ctx)
	case hpfollow.FieldElineupmallClearFile:
		return m.OldElineupmallClearFile(ctx)
	}
	return nil, fmt.Errorf("unknown HPFollow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPFollowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpfollow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpfollow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpfollow.FieldType:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case hpfollow.FieldElineupmallOther:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallOther(v)
		return nil
	case hpfollow.FieldElineupmallPhotoDaily:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhotoDaily(v)
		return nil
	case hpfollow.FieldElineupmallPhotoA4:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhotoA4(v)
		return nil
	case hpfollow.FieldElineupmallPhotoA5:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhotoA5(v)
		return nil
	case hpfollow.FieldElineupmallPhoto2l:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhoto2l(v)
		return nil
	case hpfollow.FieldElineupmallPhotoOther:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhotoOther(v)
		return nil
	case hpfollow.FieldElineupmallPhotoAlbum:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhotoAlbum(v)
		return nil
	case hpfollow.FieldElineupmallPhotoAlbumOther:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhotoAlbumOther(v)
		return nil
	case hpfollow.FieldElineupmallPhotoBook:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhotoBook(v)
		return nil
	case hpfollow.FieldElineupmallPhotoBookOther:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPhotoBookOther(v)
		return nil
	case hpfollow.FieldElineupmallDvd:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallDvd(v)
		return nil
	case hpfollow.FieldElineupmallDvdMagazine:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallDvdMagazine(v)
		return nil
	case hpfollow.FieldElineupmallDvdMagazineOther:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallDvdMagazineOther(v)
		return nil
	case hpfollow.FieldElineupmallBlueray:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallBlueray(v)
		return nil
	case hpfollow.FieldElineupmallPenlight:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallPenlight(v)
		return nil
	case hpfollow.FieldElineupmallCollectionPinnapPoster:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallCollectionPinnapPoster(v)
		return nil
	case hpfollow.FieldElineupmallCollectionPhoto:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallCollectionPhoto(v)
		return nil
	case hpfollow.FieldElineupmallCollectionOther:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallCollectionOther(v)
		return nil
	case hpfollow.FieldElineupmallTshirt:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallTshirt(v)
		return nil
	case hpfollow.FieldElineupmallMicrofiberTowel:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallMicrofiberTowel(v)
		return nil
	case hpfollow.FieldElineupmallMufflerTowel:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallMufflerTowel(v)
		return nil
	case hpfollow.FieldElineupmallFsk:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallFsk(v)
		return nil
	case hpfollow.FieldElineupmallKeyringOther:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallKeyringOther(v)
		return nil
	case hpfollow.FieldElineupmallClearFile:
		v, ok := value.(enums.HPFollowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElineupmallClearFile(v)
		return nil
	}
	return fmt.Errorf("unknown HPFollow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPFollowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPFollowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPFollowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HPFollow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPFollowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpfollow.FieldCreatedAt) {
		fields = append(fields, hpfollow.FieldCreatedAt)
	}
	if m.FieldCleared(hpfollow.FieldUpdatedAt) {
		fields = append(fields, hpfollow.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPFollowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPFollowMutation) ClearField(name string) error {
	switch name {
	case hpfollow.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpfollow.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown HPFollow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPFollowMutation) ResetField(name string) error {
	switch name {
	case hpfollow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpfollow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpfollow.FieldType:
		m.ResetType()
		return nil
	case hpfollow.FieldElineupmallOther:
		m.ResetElineupmallOther()
		return nil
	case hpfollow.FieldElineupmallPhotoDaily:
		m.ResetElineupmallPhotoDaily()
		return nil
	case hpfollow.FieldElineupmallPhotoA4:
		m.ResetElineupmallPhotoA4()
		return nil
	case hpfollow.FieldElineupmallPhotoA5:
		m.ResetElineupmallPhotoA5()
		return nil
	case hpfollow.FieldElineupmallPhoto2l:
		m.ResetElineupmallPhoto2l()
		return nil
	case hpfollow.FieldElineupmallPhotoOther:
		m.ResetElineupmallPhotoOther()
		return nil
	case hpfollow.FieldElineupmallPhotoAlbum:
		m.ResetElineupmallPhotoAlbum()
		return nil
	case hpfollow.FieldElineupmallPhotoAlbumOther:
		m.ResetElineupmallPhotoAlbumOther()
		return nil
	case hpfollow.FieldElineupmallPhotoBook:
		m.ResetElineupmallPhotoBook()
		return nil
	case hpfollow.FieldElineupmallPhotoBookOther:
		m.ResetElineupmallPhotoBookOther()
		return nil
	case hpfollow.FieldElineupmallDvd:
		m.ResetElineupmallDvd()
		return nil
	case hpfollow.FieldElineupmallDvdMagazine:
		m.ResetElineupmallDvdMagazine()
		return nil
	case hpfollow.FieldElineupmallDvdMagazineOther:
		m.ResetElineupmallDvdMagazineOther()
		return nil
	case hpfollow.FieldElineupmallBlueray:
		m.ResetElineupmallBlueray()
		return nil
	case hpfollow.FieldElineupmallPenlight:
		m.ResetElineupmallPenlight()
		return nil
	case hpfollow.FieldElineupmallCollectionPinnapPoster:
		m.ResetElineupmallCollectionPinnapPoster()
		return nil
	case hpfollow.FieldElineupmallCollectionPhoto:
		m.ResetElineupmallCollectionPhoto()
		return nil
	case hpfollow.FieldElineupmallCollectionOther:
		m.ResetElineupmallCollectionOther()
		return nil
	case hpfollow.FieldElineupmallTshirt:
		m.ResetElineupmallTshirt()
		return nil
	case hpfollow.FieldElineupmallMicrofiberTowel:
		m.ResetElineupmallMicrofiberTowel()
		return nil
	case hpfollow.FieldElineupmallMufflerTowel:
		m.ResetElineupmallMufflerTowel()
		return nil
	case hpfollow.FieldElineupmallFsk:
		m.ResetElineupmallFsk()
		return nil
	case hpfollow.FieldElineupmallKeyringOther:
		m.ResetElineupmallKeyringOther()
		return nil
	case hpfollow.FieldElineupmallClearFile:
		m.ResetElineupmallClearFile()
		return nil
	}
	return fmt.Errorf("unknown HPFollow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPFollowMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, hpfollow.EdgeUser)
	}
	if m.member != nil {
		edges = append(edges, hpfollow.EdgeMember)
	}
	if m.artist != nil {
		edges = append(edges, hpfollow.EdgeArtist)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPFollowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpfollow.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case hpfollow.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case hpfollow.EdgeArtist:
		if id := m.artist; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPFollowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPFollowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPFollowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, hpfollow.EdgeUser)
	}
	if m.clearedmember {
		edges = append(edges, hpfollow.EdgeMember)
	}
	if m.clearedartist {
		edges = append(edges, hpfollow.EdgeArtist)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPFollowMutation) EdgeCleared(name string) bool {
	switch name {
	case hpfollow.EdgeUser:
		return m.cleareduser
	case hpfollow.EdgeMember:
		return m.clearedmember
	case hpfollow.EdgeArtist:
		return m.clearedartist
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPFollowMutation) ClearEdge(name string) error {
	switch name {
	case hpfollow.EdgeUser:
		m.ClearUser()
		return nil
	case hpfollow.EdgeMember:
		m.ClearMember()
		return nil
	case hpfollow.EdgeArtist:
		m.ClearArtist()
		return nil
	}
	return fmt.Errorf("unknown HPFollow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPFollowMutation) ResetEdge(name string) error {
	switch name {
	case hpfollow.EdgeUser:
		m.ResetUser()
		return nil
	case hpfollow.EdgeMember:
		m.ResetMember()
		return nil
	case hpfollow.EdgeArtist:
		m.ResetArtist()
		return nil
	}
	return fmt.Errorf("unknown HPFollow edge %s", name)
}

// HPIgPostMutation represents an operation that mutates the HPIgPost nodes in the graph.
type HPIgPostMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	crawled_at            *time.Time
	error_count           *int
	adderror_count        *int
	manually_modified     **jsonfields.ManuallyModified
	last_error_message    *string
	recrawl_required      *bool
	created_at            *time.Time
	updated_at            *time.Time
	shortcode             *string
	description           *string
	post_at               *time.Time
	media                 *[]jsonfields.Media
	appendmedia           []jsonfields.Media
	likes                 *int
	addlikes              *int
	comments              *int
	addcomments           *int
	recrawl_args          **jsonfields.HPIgCrawlArgs
	clearedFields         map[string]struct{}
	owner_artist          *int
	clearedowner_artist   bool
	owner_member          *int
	clearedowner_member   bool
	asset                 *int
	clearedasset          bool
	tagged_artists        map[int]struct{}
	removedtagged_artists map[int]struct{}
	clearedtagged_artists bool
	tagged_members        map[int]struct{}
	removedtagged_members map[int]struct{}
	clearedtagged_members bool
	blobs                 map[int]struct{}
	removedblobs          map[int]struct{}
	clearedblobs          bool
	done                  bool
	oldValue              func(context.Context) (*HPIgPost, error)
	predicates            []predicate.HPIgPost
}

var _ ent.Mutation = (*HPIgPostMutation)(nil)

// hpigpostOption allows management of the mutation configuration using functional options.
type hpigpostOption func(*HPIgPostMutation)

// newHPIgPostMutation creates new mutation for the HPIgPost entity.
func newHPIgPostMutation(c config, op Op, opts ...hpigpostOption) *HPIgPostMutation {
	m := &HPIgPostMutation{
		config:        c,
		op:            op,
		typ:           TypeHPIgPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPIgPostID sets the ID field of the mutation.
func withHPIgPostID(id int) hpigpostOption {
	return func(m *HPIgPostMutation) {
		var (
			err   error
			once  sync.Once
			value *HPIgPost
		)
		m.oldValue = func(ctx context.Context) (*HPIgPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPIgPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPIgPost sets the old HPIgPost of the mutation.
func withHPIgPost(node *HPIgPost) hpigpostOption {
	return func(m *HPIgPostMutation) {
		m.oldValue = func(context.Context) (*HPIgPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPIgPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPIgPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPIgPostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPIgPostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPIgPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCrawledAt sets the "crawled_at" field.
func (m *HPIgPostMutation) SetCrawledAt(t time.Time) {
	m.crawled_at = &t
}

// CrawledAt returns the value of the "crawled_at" field in the mutation.
func (m *HPIgPostMutation) CrawledAt() (r time.Time, exists bool) {
	v := m.crawled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCrawledAt returns the old "crawled_at" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldCrawledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrawledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrawledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrawledAt: %w", err)
	}
	return oldValue.CrawledAt, nil
}

// ClearCrawledAt clears the value of the "crawled_at" field.
func (m *HPIgPostMutation) ClearCrawledAt() {
	m.crawled_at = nil
	m.clearedFields[hpigpost.FieldCrawledAt] = struct{}{}
}

// CrawledAtCleared returns if the "crawled_at" field was cleared in this mutation.
func (m *HPIgPostMutation) CrawledAtCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldCrawledAt]
	return ok
}

// ResetCrawledAt resets all changes to the "crawled_at" field.
func (m *HPIgPostMutation) ResetCrawledAt() {
	m.crawled_at = nil
	delete(m.clearedFields, hpigpost.FieldCrawledAt)
}

// SetErrorCount sets the "error_count" field.
func (m *HPIgPostMutation) SetErrorCount(i int) {
	m.error_count = &i
	m.adderror_count = nil
}

// ErrorCount returns the value of the "error_count" field in the mutation.
func (m *HPIgPostMutation) ErrorCount() (r int, exists bool) {
	v := m.error_count
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCount returns the old "error_count" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldErrorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCount: %w", err)
	}
	return oldValue.ErrorCount, nil
}

// AddErrorCount adds i to the "error_count" field.
func (m *HPIgPostMutation) AddErrorCount(i int) {
	if m.adderror_count != nil {
		*m.adderror_count += i
	} else {
		m.adderror_count = &i
	}
}

// AddedErrorCount returns the value that was added to the "error_count" field in this mutation.
func (m *HPIgPostMutation) AddedErrorCount() (r int, exists bool) {
	v := m.adderror_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrorCount resets all changes to the "error_count" field.
func (m *HPIgPostMutation) ResetErrorCount() {
	m.error_count = nil
	m.adderror_count = nil
}

// SetManuallyModified sets the "manually_modified" field.
func (m *HPIgPostMutation) SetManuallyModified(jm *jsonfields.ManuallyModified) {
	m.manually_modified = &jm
}

// ManuallyModified returns the value of the "manually_modified" field in the mutation.
func (m *HPIgPostMutation) ManuallyModified() (r *jsonfields.ManuallyModified, exists bool) {
	v := m.manually_modified
	if v == nil {
		return
	}
	return *v, true
}

// OldManuallyModified returns the old "manually_modified" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldManuallyModified(ctx context.Context) (v *jsonfields.ManuallyModified, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManuallyModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManuallyModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManuallyModified: %w", err)
	}
	return oldValue.ManuallyModified, nil
}

// ClearManuallyModified clears the value of the "manually_modified" field.
func (m *HPIgPostMutation) ClearManuallyModified() {
	m.manually_modified = nil
	m.clearedFields[hpigpost.FieldManuallyModified] = struct{}{}
}

// ManuallyModifiedCleared returns if the "manually_modified" field was cleared in this mutation.
func (m *HPIgPostMutation) ManuallyModifiedCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldManuallyModified]
	return ok
}

// ResetManuallyModified resets all changes to the "manually_modified" field.
func (m *HPIgPostMutation) ResetManuallyModified() {
	m.manually_modified = nil
	delete(m.clearedFields, hpigpost.FieldManuallyModified)
}

// SetLastErrorMessage sets the "last_error_message" field.
func (m *HPIgPostMutation) SetLastErrorMessage(s string) {
	m.last_error_message = &s
}

// LastErrorMessage returns the value of the "last_error_message" field in the mutation.
func (m *HPIgPostMutation) LastErrorMessage() (r string, exists bool) {
	v := m.last_error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLastErrorMessage returns the old "last_error_message" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldLastErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastErrorMessage: %w", err)
	}
	return oldValue.LastErrorMessage, nil
}

// ClearLastErrorMessage clears the value of the "last_error_message" field.
func (m *HPIgPostMutation) ClearLastErrorMessage() {
	m.last_error_message = nil
	m.clearedFields[hpigpost.FieldLastErrorMessage] = struct{}{}
}

// LastErrorMessageCleared returns if the "last_error_message" field was cleared in this mutation.
func (m *HPIgPostMutation) LastErrorMessageCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldLastErrorMessage]
	return ok
}

// ResetLastErrorMessage resets all changes to the "last_error_message" field.
func (m *HPIgPostMutation) ResetLastErrorMessage() {
	m.last_error_message = nil
	delete(m.clearedFields, hpigpost.FieldLastErrorMessage)
}

// SetRecrawlRequired sets the "recrawl_required" field.
func (m *HPIgPostMutation) SetRecrawlRequired(b bool) {
	m.recrawl_required = &b
}

// RecrawlRequired returns the value of the "recrawl_required" field in the mutation.
func (m *HPIgPostMutation) RecrawlRequired() (r bool, exists bool) {
	v := m.recrawl_required
	if v == nil {
		return
	}
	return *v, true
}

// OldRecrawlRequired returns the old "recrawl_required" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldRecrawlRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecrawlRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecrawlRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecrawlRequired: %w", err)
	}
	return oldValue.RecrawlRequired, nil
}

// ClearRecrawlRequired clears the value of the "recrawl_required" field.
func (m *HPIgPostMutation) ClearRecrawlRequired() {
	m.recrawl_required = nil
	m.clearedFields[hpigpost.FieldRecrawlRequired] = struct{}{}
}

// RecrawlRequiredCleared returns if the "recrawl_required" field was cleared in this mutation.
func (m *HPIgPostMutation) RecrawlRequiredCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldRecrawlRequired]
	return ok
}

// ResetRecrawlRequired resets all changes to the "recrawl_required" field.
func (m *HPIgPostMutation) ResetRecrawlRequired() {
	m.recrawl_required = nil
	delete(m.clearedFields, hpigpost.FieldRecrawlRequired)
}

// SetCreatedAt sets the "created_at" field.
func (m *HPIgPostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPIgPostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPIgPostMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpigpost.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPIgPostMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPIgPostMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpigpost.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPIgPostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPIgPostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPIgPostMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpigpost.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPIgPostMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPIgPostMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpigpost.FieldUpdatedAt)
}

// SetShortcode sets the "shortcode" field.
func (m *HPIgPostMutation) SetShortcode(s string) {
	m.shortcode = &s
}

// Shortcode returns the value of the "shortcode" field in the mutation.
func (m *HPIgPostMutation) Shortcode() (r string, exists bool) {
	v := m.shortcode
	if v == nil {
		return
	}
	return *v, true
}

// OldShortcode returns the old "shortcode" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldShortcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortcode: %w", err)
	}
	return oldValue.Shortcode, nil
}

// ResetShortcode resets all changes to the "shortcode" field.
func (m *HPIgPostMutation) ResetShortcode() {
	m.shortcode = nil
}

// SetDescription sets the "description" field.
func (m *HPIgPostMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HPIgPostMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HPIgPostMutation) ResetDescription() {
	m.description = nil
}

// SetPostAt sets the "post_at" field.
func (m *HPIgPostMutation) SetPostAt(t time.Time) {
	m.post_at = &t
}

// PostAt returns the value of the "post_at" field in the mutation.
func (m *HPIgPostMutation) PostAt() (r time.Time, exists bool) {
	v := m.post_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPostAt returns the old "post_at" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldPostAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostAt: %w", err)
	}
	return oldValue.PostAt, nil
}

// ResetPostAt resets all changes to the "post_at" field.
func (m *HPIgPostMutation) ResetPostAt() {
	m.post_at = nil
}

// SetMedia sets the "media" field.
func (m *HPIgPostMutation) SetMedia(j []jsonfields.Media) {
	m.media = &j
	m.appendmedia = nil
}

// Media returns the value of the "media" field in the mutation.
func (m *HPIgPostMutation) Media() (r []jsonfields.Media, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMedia returns the old "media" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldMedia(ctx context.Context) (v []jsonfields.Media, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedia: %w", err)
	}
	return oldValue.Media, nil
}

// AppendMedia adds j to the "media" field.
func (m *HPIgPostMutation) AppendMedia(j []jsonfields.Media) {
	m.appendmedia = append(m.appendmedia, j...)
}

// AppendedMedia returns the list of values that were appended to the "media" field in this mutation.
func (m *HPIgPostMutation) AppendedMedia() ([]jsonfields.Media, bool) {
	if len(m.appendmedia) == 0 {
		return nil, false
	}
	return m.appendmedia, true
}

// ResetMedia resets all changes to the "media" field.
func (m *HPIgPostMutation) ResetMedia() {
	m.media = nil
	m.appendmedia = nil
}

// SetLikes sets the "likes" field.
func (m *HPIgPostMutation) SetLikes(i int) {
	m.likes = &i
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *HPIgPostMutation) Likes() (r int, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldLikes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds i to the "likes" field.
func (m *HPIgPostMutation) AddLikes(i int) {
	if m.addlikes != nil {
		*m.addlikes += i
	} else {
		m.addlikes = &i
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *HPIgPostMutation) AddedLikes() (r int, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikes resets all changes to the "likes" field.
func (m *HPIgPostMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
}

// SetComments sets the "comments" field.
func (m *HPIgPostMutation) SetComments(i int) {
	m.comments = &i
	m.addcomments = nil
}

// Comments returns the value of the "comments" field in the mutation.
func (m *HPIgPostMutation) Comments() (r int, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldComments(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// AddComments adds i to the "comments" field.
func (m *HPIgPostMutation) AddComments(i int) {
	if m.addcomments != nil {
		*m.addcomments += i
	} else {
		m.addcomments = &i
	}
}

// AddedComments returns the value that was added to the "comments" field in this mutation.
func (m *HPIgPostMutation) AddedComments() (r int, exists bool) {
	v := m.addcomments
	if v == nil {
		return
	}
	return *v, true
}

// ResetComments resets all changes to the "comments" field.
func (m *HPIgPostMutation) ResetComments() {
	m.comments = nil
	m.addcomments = nil
}

// SetRecrawlArgs sets the "recrawl_args" field.
func (m *HPIgPostMutation) SetRecrawlArgs(jica *jsonfields.HPIgCrawlArgs) {
	m.recrawl_args = &jica
}

// RecrawlArgs returns the value of the "recrawl_args" field in the mutation.
func (m *HPIgPostMutation) RecrawlArgs() (r *jsonfields.HPIgCrawlArgs, exists bool) {
	v := m.recrawl_args
	if v == nil {
		return
	}
	return *v, true
}

// OldRecrawlArgs returns the old "recrawl_args" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldRecrawlArgs(ctx context.Context) (v *jsonfields.HPIgCrawlArgs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecrawlArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecrawlArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecrawlArgs: %w", err)
	}
	return oldValue.RecrawlArgs, nil
}

// ClearRecrawlArgs clears the value of the "recrawl_args" field.
func (m *HPIgPostMutation) ClearRecrawlArgs() {
	m.recrawl_args = nil
	m.clearedFields[hpigpost.FieldRecrawlArgs] = struct{}{}
}

// RecrawlArgsCleared returns if the "recrawl_args" field was cleared in this mutation.
func (m *HPIgPostMutation) RecrawlArgsCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldRecrawlArgs]
	return ok
}

// ResetRecrawlArgs resets all changes to the "recrawl_args" field.
func (m *HPIgPostMutation) ResetRecrawlArgs() {
	m.recrawl_args = nil
	delete(m.clearedFields, hpigpost.FieldRecrawlArgs)
}

// SetOwnerArtistID sets the "owner_artist_id" field.
func (m *HPIgPostMutation) SetOwnerArtistID(i int) {
	m.owner_artist = &i
}

// OwnerArtistID returns the value of the "owner_artist_id" field in the mutation.
func (m *HPIgPostMutation) OwnerArtistID() (r int, exists bool) {
	v := m.owner_artist
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerArtistID returns the old "owner_artist_id" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldOwnerArtistID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerArtistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerArtistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerArtistID: %w", err)
	}
	return oldValue.OwnerArtistID, nil
}

// ClearOwnerArtistID clears the value of the "owner_artist_id" field.
func (m *HPIgPostMutation) ClearOwnerArtistID() {
	m.owner_artist = nil
	m.clearedFields[hpigpost.FieldOwnerArtistID] = struct{}{}
}

// OwnerArtistIDCleared returns if the "owner_artist_id" field was cleared in this mutation.
func (m *HPIgPostMutation) OwnerArtistIDCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldOwnerArtistID]
	return ok
}

// ResetOwnerArtistID resets all changes to the "owner_artist_id" field.
func (m *HPIgPostMutation) ResetOwnerArtistID() {
	m.owner_artist = nil
	delete(m.clearedFields, hpigpost.FieldOwnerArtistID)
}

// SetOwnerMemberID sets the "owner_member_id" field.
func (m *HPIgPostMutation) SetOwnerMemberID(i int) {
	m.owner_member = &i
}

// OwnerMemberID returns the value of the "owner_member_id" field in the mutation.
func (m *HPIgPostMutation) OwnerMemberID() (r int, exists bool) {
	v := m.owner_member
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerMemberID returns the old "owner_member_id" field's value of the HPIgPost entity.
// If the HPIgPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPIgPostMutation) OldOwnerMemberID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerMemberID: %w", err)
	}
	return oldValue.OwnerMemberID, nil
}

// ClearOwnerMemberID clears the value of the "owner_member_id" field.
func (m *HPIgPostMutation) ClearOwnerMemberID() {
	m.owner_member = nil
	m.clearedFields[hpigpost.FieldOwnerMemberID] = struct{}{}
}

// OwnerMemberIDCleared returns if the "owner_member_id" field was cleared in this mutation.
func (m *HPIgPostMutation) OwnerMemberIDCleared() bool {
	_, ok := m.clearedFields[hpigpost.FieldOwnerMemberID]
	return ok
}

// ResetOwnerMemberID resets all changes to the "owner_member_id" field.
func (m *HPIgPostMutation) ResetOwnerMemberID() {
	m.owner_member = nil
	delete(m.clearedFields, hpigpost.FieldOwnerMemberID)
}

// ClearOwnerArtist clears the "owner_artist" edge to the HPArtist entity.
func (m *HPIgPostMutation) ClearOwnerArtist() {
	m.clearedowner_artist = true
}

// OwnerArtistCleared reports if the "owner_artist" edge to the HPArtist entity was cleared.
func (m *HPIgPostMutation) OwnerArtistCleared() bool {
	return m.OwnerArtistIDCleared() || m.clearedowner_artist
}

// OwnerArtistIDs returns the "owner_artist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerArtistID instead. It exists only for internal usage by the builders.
func (m *HPIgPostMutation) OwnerArtistIDs() (ids []int) {
	if id := m.owner_artist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerArtist resets all changes to the "owner_artist" edge.
func (m *HPIgPostMutation) ResetOwnerArtist() {
	m.owner_artist = nil
	m.clearedowner_artist = false
}

// ClearOwnerMember clears the "owner_member" edge to the HPMember entity.
func (m *HPIgPostMutation) ClearOwnerMember() {
	m.clearedowner_member = true
}

// OwnerMemberCleared reports if the "owner_member" edge to the HPMember entity was cleared.
func (m *HPIgPostMutation) OwnerMemberCleared() bool {
	return m.OwnerMemberIDCleared() || m.clearedowner_member
}

// OwnerMemberIDs returns the "owner_member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerMemberID instead. It exists only for internal usage by the builders.
func (m *HPIgPostMutation) OwnerMemberIDs() (ids []int) {
	if id := m.owner_member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerMember resets all changes to the "owner_member" edge.
func (m *HPIgPostMutation) ResetOwnerMember() {
	m.owner_member = nil
	m.clearedowner_member = false
}

// SetAssetID sets the "asset" edge to the HPAsset entity by id.
func (m *HPIgPostMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the HPAsset entity.
func (m *HPIgPostMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the HPAsset entity was cleared.
func (m *HPIgPostMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *HPIgPostMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *HPIgPostMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *HPIgPostMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddTaggedArtistIDs adds the "tagged_artists" edge to the HPArtist entity by ids.
func (m *HPIgPostMutation) AddTaggedArtistIDs(ids ...int) {
	if m.tagged_artists == nil {
		m.tagged_artists = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_artists[ids[i]] = struct{}{}
	}
}

// ClearTaggedArtists clears the "tagged_artists" edge to the HPArtist entity.
func (m *HPIgPostMutation) ClearTaggedArtists() {
	m.clearedtagged_artists = true
}

// TaggedArtistsCleared reports if the "tagged_artists" edge to the HPArtist entity was cleared.
func (m *HPIgPostMutation) TaggedArtistsCleared() bool {
	return m.clearedtagged_artists
}

// RemoveTaggedArtistIDs removes the "tagged_artists" edge to the HPArtist entity by IDs.
func (m *HPIgPostMutation) RemoveTaggedArtistIDs(ids ...int) {
	if m.removedtagged_artists == nil {
		m.removedtagged_artists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_artists, ids[i])
		m.removedtagged_artists[ids[i]] = struct{}{}
	}
}

// RemovedTaggedArtists returns the removed IDs of the "tagged_artists" edge to the HPArtist entity.
func (m *HPIgPostMutation) RemovedTaggedArtistsIDs() (ids []int) {
	for id := range m.removedtagged_artists {
		ids = append(ids, id)
	}
	return
}

// TaggedArtistsIDs returns the "tagged_artists" edge IDs in the mutation.
func (m *HPIgPostMutation) TaggedArtistsIDs() (ids []int) {
	for id := range m.tagged_artists {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedArtists resets all changes to the "tagged_artists" edge.
func (m *HPIgPostMutation) ResetTaggedArtists() {
	m.tagged_artists = nil
	m.clearedtagged_artists = false
	m.removedtagged_artists = nil
}

// AddTaggedMemberIDs adds the "tagged_members" edge to the HPMember entity by ids.
func (m *HPIgPostMutation) AddTaggedMemberIDs(ids ...int) {
	if m.tagged_members == nil {
		m.tagged_members = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_members[ids[i]] = struct{}{}
	}
}

// ClearTaggedMembers clears the "tagged_members" edge to the HPMember entity.
func (m *HPIgPostMutation) ClearTaggedMembers() {
	m.clearedtagged_members = true
}

// TaggedMembersCleared reports if the "tagged_members" edge to the HPMember entity was cleared.
func (m *HPIgPostMutation) TaggedMembersCleared() bool {
	return m.clearedtagged_members
}

// RemoveTaggedMemberIDs removes the "tagged_members" edge to the HPMember entity by IDs.
func (m *HPIgPostMutation) RemoveTaggedMemberIDs(ids ...int) {
	if m.removedtagged_members == nil {
		m.removedtagged_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_members, ids[i])
		m.removedtagged_members[ids[i]] = struct{}{}
	}
}

// RemovedTaggedMembers returns the removed IDs of the "tagged_members" edge to the HPMember entity.
func (m *HPIgPostMutation) RemovedTaggedMembersIDs() (ids []int) {
	for id := range m.removedtagged_members {
		ids = append(ids, id)
	}
	return
}

// TaggedMembersIDs returns the "tagged_members" edge IDs in the mutation.
func (m *HPIgPostMutation) TaggedMembersIDs() (ids []int) {
	for id := range m.tagged_members {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedMembers resets all changes to the "tagged_members" edge.
func (m *HPIgPostMutation) ResetTaggedMembers() {
	m.tagged_members = nil
	m.clearedtagged_members = false
	m.removedtagged_members = nil
}

// AddBlobIDs adds the "blobs" edge to the HPBlob entity by ids.
func (m *HPIgPostMutation) AddBlobIDs(ids ...int) {
	if m.blobs == nil {
		m.blobs = make(map[int]struct{})
	}
	for i := range ids {
		m.blobs[ids[i]] = struct{}{}
	}
}

// ClearBlobs clears the "blobs" edge to the HPBlob entity.
func (m *HPIgPostMutation) ClearBlobs() {
	m.clearedblobs = true
}

// BlobsCleared reports if the "blobs" edge to the HPBlob entity was cleared.
func (m *HPIgPostMutation) BlobsCleared() bool {
	return m.clearedblobs
}

// RemoveBlobIDs removes the "blobs" edge to the HPBlob entity by IDs.
func (m *HPIgPostMutation) RemoveBlobIDs(ids ...int) {
	if m.removedblobs == nil {
		m.removedblobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blobs, ids[i])
		m.removedblobs[ids[i]] = struct{}{}
	}
}

// RemovedBlobs returns the removed IDs of the "blobs" edge to the HPBlob entity.
func (m *HPIgPostMutation) RemovedBlobsIDs() (ids []int) {
	for id := range m.removedblobs {
		ids = append(ids, id)
	}
	return
}

// BlobsIDs returns the "blobs" edge IDs in the mutation.
func (m *HPIgPostMutation) BlobsIDs() (ids []int) {
	for id := range m.blobs {
		ids = append(ids, id)
	}
	return
}

// ResetBlobs resets all changes to the "blobs" edge.
func (m *HPIgPostMutation) ResetBlobs() {
	m.blobs = nil
	m.clearedblobs = false
	m.removedblobs = nil
}

// Where appends a list predicates to the HPIgPostMutation builder.
func (m *HPIgPostMutation) Where(ps ...predicate.HPIgPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPIgPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPIgPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPIgPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPIgPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPIgPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPIgPost).
func (m *HPIgPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPIgPostMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.crawled_at != nil {
		fields = append(fields, hpigpost.FieldCrawledAt)
	}
	if m.error_count != nil {
		fields = append(fields, hpigpost.FieldErrorCount)
	}
	if m.manually_modified != nil {
		fields = append(fields, hpigpost.FieldManuallyModified)
	}
	if m.last_error_message != nil {
		fields = append(fields, hpigpost.FieldLastErrorMessage)
	}
	if m.recrawl_required != nil {
		fields = append(fields, hpigpost.FieldRecrawlRequired)
	}
	if m.created_at != nil {
		fields = append(fields, hpigpost.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpigpost.FieldUpdatedAt)
	}
	if m.shortcode != nil {
		fields = append(fields, hpigpost.FieldShortcode)
	}
	if m.description != nil {
		fields = append(fields, hpigpost.FieldDescription)
	}
	if m.post_at != nil {
		fields = append(fields, hpigpost.FieldPostAt)
	}
	if m.media != nil {
		fields = append(fields, hpigpost.FieldMedia)
	}
	if m.likes != nil {
		fields = append(fields, hpigpost.FieldLikes)
	}
	if m.comments != nil {
		fields = append(fields, hpigpost.FieldComments)
	}
	if m.recrawl_args != nil {
		fields = append(fields, hpigpost.FieldRecrawlArgs)
	}
	if m.owner_artist != nil {
		fields = append(fields, hpigpost.FieldOwnerArtistID)
	}
	if m.owner_member != nil {
		fields = append(fields, hpigpost.FieldOwnerMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPIgPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpigpost.FieldCrawledAt:
		return m.CrawledAt()
	case hpigpost.FieldErrorCount:
		return m.ErrorCount()
	case hpigpost.FieldManuallyModified:
		return m.ManuallyModified()
	case hpigpost.FieldLastErrorMessage:
		return m.LastErrorMessage()
	case hpigpost.FieldRecrawlRequired:
		return m.RecrawlRequired()
	case hpigpost.FieldCreatedAt:
		return m.CreatedAt()
	case hpigpost.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpigpost.FieldShortcode:
		return m.Shortcode()
	case hpigpost.FieldDescription:
		return m.Description()
	case hpigpost.FieldPostAt:
		return m.PostAt()
	case hpigpost.FieldMedia:
		return m.Media()
	case hpigpost.FieldLikes:
		return m.Likes()
	case hpigpost.FieldComments:
		return m.Comments()
	case hpigpost.FieldRecrawlArgs:
		return m.RecrawlArgs()
	case hpigpost.FieldOwnerArtistID:
		return m.OwnerArtistID()
	case hpigpost.FieldOwnerMemberID:
		return m.OwnerMemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPIgPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpigpost.FieldCrawledAt:
		return m.OldCrawledAt(ctx)
	case hpigpost.FieldErrorCount:
		return m.OldErrorCount(ctx)
	case hpigpost.FieldManuallyModified:
		return m.OldManuallyModified(ctx)
	case hpigpost.FieldLastErrorMessage:
		return m.OldLastErrorMessage(ctx)
	case hpigpost.FieldRecrawlRequired:
		return m.OldRecrawlRequired(ctx)
	case hpigpost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpigpost.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpigpost.FieldShortcode:
		return m.OldShortcode(ctx)
	case hpigpost.FieldDescription:
		return m.OldDescription(ctx)
	case hpigpost.FieldPostAt:
		return m.OldPostAt(ctx)
	case hpigpost.FieldMedia:
		return m.OldMedia(ctx)
	case hpigpost.FieldLikes:
		return m.OldLikes(ctx)
	case hpigpost.FieldComments:
		return m.OldComments(ctx)
	case hpigpost.FieldRecrawlArgs:
		return m.OldRecrawlArgs(ctx)
	case hpigpost.FieldOwnerArtistID:
		return m.OldOwnerArtistID(ctx)
	case hpigpost.FieldOwnerMemberID:
		return m.OldOwnerMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown HPIgPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPIgPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpigpost.FieldCrawledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrawledAt(v)
		return nil
	case hpigpost.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCount(v)
		return nil
	case hpigpost.FieldManuallyModified:
		v, ok := value.(*jsonfields.ManuallyModified)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManuallyModified(v)
		return nil
	case hpigpost.FieldLastErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastErrorMessage(v)
		return nil
	case hpigpost.FieldRecrawlRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecrawlRequired(v)
		return nil
	case hpigpost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpigpost.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpigpost.FieldShortcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortcode(v)
		return nil
	case hpigpost.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hpigpost.FieldPostAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostAt(v)
		return nil
	case hpigpost.FieldMedia:
		v, ok := value.([]jsonfields.Media)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedia(v)
		return nil
	case hpigpost.FieldLikes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case hpigpost.FieldComments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case hpigpost.FieldRecrawlArgs:
		v, ok := value.(*jsonfields.HPIgCrawlArgs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecrawlArgs(v)
		return nil
	case hpigpost.FieldOwnerArtistID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerArtistID(v)
		return nil
	case hpigpost.FieldOwnerMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown HPIgPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPIgPostMutation) AddedFields() []string {
	var fields []string
	if m.adderror_count != nil {
		fields = append(fields, hpigpost.FieldErrorCount)
	}
	if m.addlikes != nil {
		fields = append(fields, hpigpost.FieldLikes)
	}
	if m.addcomments != nil {
		fields = append(fields, hpigpost.FieldComments)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPIgPostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpigpost.FieldErrorCount:
		return m.AddedErrorCount()
	case hpigpost.FieldLikes:
		return m.AddedLikes()
	case hpigpost.FieldComments:
		return m.AddedComments()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPIgPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpigpost.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCount(v)
		return nil
	case hpigpost.FieldLikes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	case hpigpost.FieldComments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddComments(v)
		return nil
	}
	return fmt.Errorf("unknown HPIgPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPIgPostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpigpost.FieldCrawledAt) {
		fields = append(fields, hpigpost.FieldCrawledAt)
	}
	if m.FieldCleared(hpigpost.FieldManuallyModified) {
		fields = append(fields, hpigpost.FieldManuallyModified)
	}
	if m.FieldCleared(hpigpost.FieldLastErrorMessage) {
		fields = append(fields, hpigpost.FieldLastErrorMessage)
	}
	if m.FieldCleared(hpigpost.FieldRecrawlRequired) {
		fields = append(fields, hpigpost.FieldRecrawlRequired)
	}
	if m.FieldCleared(hpigpost.FieldCreatedAt) {
		fields = append(fields, hpigpost.FieldCreatedAt)
	}
	if m.FieldCleared(hpigpost.FieldUpdatedAt) {
		fields = append(fields, hpigpost.FieldUpdatedAt)
	}
	if m.FieldCleared(hpigpost.FieldRecrawlArgs) {
		fields = append(fields, hpigpost.FieldRecrawlArgs)
	}
	if m.FieldCleared(hpigpost.FieldOwnerArtistID) {
		fields = append(fields, hpigpost.FieldOwnerArtistID)
	}
	if m.FieldCleared(hpigpost.FieldOwnerMemberID) {
		fields = append(fields, hpigpost.FieldOwnerMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPIgPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPIgPostMutation) ClearField(name string) error {
	switch name {
	case hpigpost.FieldCrawledAt:
		m.ClearCrawledAt()
		return nil
	case hpigpost.FieldManuallyModified:
		m.ClearManuallyModified()
		return nil
	case hpigpost.FieldLastErrorMessage:
		m.ClearLastErrorMessage()
		return nil
	case hpigpost.FieldRecrawlRequired:
		m.ClearRecrawlRequired()
		return nil
	case hpigpost.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpigpost.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpigpost.FieldRecrawlArgs:
		m.ClearRecrawlArgs()
		return nil
	case hpigpost.FieldOwnerArtistID:
		m.ClearOwnerArtistID()
		return nil
	case hpigpost.FieldOwnerMemberID:
		m.ClearOwnerMemberID()
		return nil
	}
	return fmt.Errorf("unknown HPIgPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPIgPostMutation) ResetField(name string) error {
	switch name {
	case hpigpost.FieldCrawledAt:
		m.ResetCrawledAt()
		return nil
	case hpigpost.FieldErrorCount:
		m.ResetErrorCount()
		return nil
	case hpigpost.FieldManuallyModified:
		m.ResetManuallyModified()
		return nil
	case hpigpost.FieldLastErrorMessage:
		m.ResetLastErrorMessage()
		return nil
	case hpigpost.FieldRecrawlRequired:
		m.ResetRecrawlRequired()
		return nil
	case hpigpost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpigpost.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpigpost.FieldShortcode:
		m.ResetShortcode()
		return nil
	case hpigpost.FieldDescription:
		m.ResetDescription()
		return nil
	case hpigpost.FieldPostAt:
		m.ResetPostAt()
		return nil
	case hpigpost.FieldMedia:
		m.ResetMedia()
		return nil
	case hpigpost.FieldLikes:
		m.ResetLikes()
		return nil
	case hpigpost.FieldComments:
		m.ResetComments()
		return nil
	case hpigpost.FieldRecrawlArgs:
		m.ResetRecrawlArgs()
		return nil
	case hpigpost.FieldOwnerArtistID:
		m.ResetOwnerArtistID()
		return nil
	case hpigpost.FieldOwnerMemberID:
		m.ResetOwnerMemberID()
		return nil
	}
	return fmt.Errorf("unknown HPIgPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPIgPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.owner_artist != nil {
		edges = append(edges, hpigpost.EdgeOwnerArtist)
	}
	if m.owner_member != nil {
		edges = append(edges, hpigpost.EdgeOwnerMember)
	}
	if m.asset != nil {
		edges = append(edges, hpigpost.EdgeAsset)
	}
	if m.tagged_artists != nil {
		edges = append(edges, hpigpost.EdgeTaggedArtists)
	}
	if m.tagged_members != nil {
		edges = append(edges, hpigpost.EdgeTaggedMembers)
	}
	if m.blobs != nil {
		edges = append(edges, hpigpost.EdgeBlobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPIgPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpigpost.EdgeOwnerArtist:
		if id := m.owner_artist; id != nil {
			return []ent.Value{*id}
		}
	case hpigpost.EdgeOwnerMember:
		if id := m.owner_member; id != nil {
			return []ent.Value{*id}
		}
	case hpigpost.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case hpigpost.EdgeTaggedArtists:
		ids := make([]ent.Value, 0, len(m.tagged_artists))
		for id := range m.tagged_artists {
			ids = append(ids, id)
		}
		return ids
	case hpigpost.EdgeTaggedMembers:
		ids := make([]ent.Value, 0, len(m.tagged_members))
		for id := range m.tagged_members {
			ids = append(ids, id)
		}
		return ids
	case hpigpost.EdgeBlobs:
		ids := make([]ent.Value, 0, len(m.blobs))
		for id := range m.blobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPIgPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtagged_artists != nil {
		edges = append(edges, hpigpost.EdgeTaggedArtists)
	}
	if m.removedtagged_members != nil {
		edges = append(edges, hpigpost.EdgeTaggedMembers)
	}
	if m.removedblobs != nil {
		edges = append(edges, hpigpost.EdgeBlobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPIgPostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpigpost.EdgeTaggedArtists:
		ids := make([]ent.Value, 0, len(m.removedtagged_artists))
		for id := range m.removedtagged_artists {
			ids = append(ids, id)
		}
		return ids
	case hpigpost.EdgeTaggedMembers:
		ids := make([]ent.Value, 0, len(m.removedtagged_members))
		for id := range m.removedtagged_members {
			ids = append(ids, id)
		}
		return ids
	case hpigpost.EdgeBlobs:
		ids := make([]ent.Value, 0, len(m.removedblobs))
		for id := range m.removedblobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPIgPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedowner_artist {
		edges = append(edges, hpigpost.EdgeOwnerArtist)
	}
	if m.clearedowner_member {
		edges = append(edges, hpigpost.EdgeOwnerMember)
	}
	if m.clearedasset {
		edges = append(edges, hpigpost.EdgeAsset)
	}
	if m.clearedtagged_artists {
		edges = append(edges, hpigpost.EdgeTaggedArtists)
	}
	if m.clearedtagged_members {
		edges = append(edges, hpigpost.EdgeTaggedMembers)
	}
	if m.clearedblobs {
		edges = append(edges, hpigpost.EdgeBlobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPIgPostMutation) EdgeCleared(name string) bool {
	switch name {
	case hpigpost.EdgeOwnerArtist:
		return m.clearedowner_artist
	case hpigpost.EdgeOwnerMember:
		return m.clearedowner_member
	case hpigpost.EdgeAsset:
		return m.clearedasset
	case hpigpost.EdgeTaggedArtists:
		return m.clearedtagged_artists
	case hpigpost.EdgeTaggedMembers:
		return m.clearedtagged_members
	case hpigpost.EdgeBlobs:
		return m.clearedblobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPIgPostMutation) ClearEdge(name string) error {
	switch name {
	case hpigpost.EdgeOwnerArtist:
		m.ClearOwnerArtist()
		return nil
	case hpigpost.EdgeOwnerMember:
		m.ClearOwnerMember()
		return nil
	case hpigpost.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown HPIgPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPIgPostMutation) ResetEdge(name string) error {
	switch name {
	case hpigpost.EdgeOwnerArtist:
		m.ResetOwnerArtist()
		return nil
	case hpigpost.EdgeOwnerMember:
		m.ResetOwnerMember()
		return nil
	case hpigpost.EdgeAsset:
		m.ResetAsset()
		return nil
	case hpigpost.EdgeTaggedArtists:
		m.ResetTaggedArtists()
		return nil
	case hpigpost.EdgeTaggedMembers:
		m.ResetTaggedMembers()
		return nil
	case hpigpost.EdgeBlobs:
		m.ResetBlobs()
		return nil
	}
	return fmt.Errorf("unknown HPIgPost edge %s", name)
}

// HPMemberMutation represents an operation that mutates the HPMember nodes in the graph.
type HPMemberMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	crawled_at                       *time.Time
	error_count                      *int
	adderror_count                   *int
	manually_modified                **jsonfields.ManuallyModified
	last_error_message               *string
	recrawl_required                 *bool
	created_at                       *time.Time
	updated_at                       *time.Time
	key                              *string
	artist_key                       *string
	name                             *string
	name_kana                        *string
	thumbnail_url                    *string
	date_of_birth                    *time.Time
	blood_type                       *string
	hometown                         *string
	join_at                          *time.Time
	graduate_at                      *time.Time
	color_rgb                        *string
	color_name                       *string
	clearedFields                    map[string]struct{}
	assets                           map[int]struct{}
	removedassets                    map[int]struct{}
	clearedassets                    bool
	artist                           *int
	clearedartist                    bool
	owning_feed                      map[int]struct{}
	removedowning_feed               map[int]struct{}
	clearedowning_feed               bool
	tagged_feed                      map[int]struct{}
	removedtagged_feed               map[int]struct{}
	clearedtagged_feed               bool
	owning_ig_posts                  map[int]struct{}
	removedowning_ig_posts           map[int]struct{}
	clearedowning_ig_posts           bool
	tagged_ig_posts                  map[int]struct{}
	removedtagged_ig_posts           map[int]struct{}
	clearedtagged_ig_posts           bool
	owning_ameblo_posts              map[int]struct{}
	removedowning_ameblo_posts       map[int]struct{}
	clearedowning_ameblo_posts       bool
	tagged_ameblo_posts              map[int]struct{}
	removedtagged_ameblo_posts       map[int]struct{}
	clearedtagged_ameblo_posts       bool
	tagged_elineup_mall_items        map[int]struct{}
	removedtagged_elineup_mall_items map[int]struct{}
	clearedtagged_elineup_mall_items bool
	followed_by                      map[int]struct{}
	removedfollowed_by               map[int]struct{}
	clearedfollowed_by               bool
	done                             bool
	oldValue                         func(context.Context) (*HPMember, error)
	predicates                       []predicate.HPMember
}

var _ ent.Mutation = (*HPMemberMutation)(nil)

// hpmemberOption allows management of the mutation configuration using functional options.
type hpmemberOption func(*HPMemberMutation)

// newHPMemberMutation creates new mutation for the HPMember entity.
func newHPMemberMutation(c config, op Op, opts ...hpmemberOption) *HPMemberMutation {
	m := &HPMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeHPMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPMemberID sets the ID field of the mutation.
func withHPMemberID(id int) hpmemberOption {
	return func(m *HPMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *HPMember
		)
		m.oldValue = func(ctx context.Context) (*HPMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPMember sets the old HPMember of the mutation.
func withHPMember(node *HPMember) hpmemberOption {
	return func(m *HPMemberMutation) {
		m.oldValue = func(context.Context) (*HPMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCrawledAt sets the "crawled_at" field.
func (m *HPMemberMutation) SetCrawledAt(t time.Time) {
	m.crawled_at = &t
}

// CrawledAt returns the value of the "crawled_at" field in the mutation.
func (m *HPMemberMutation) CrawledAt() (r time.Time, exists bool) {
	v := m.crawled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCrawledAt returns the old "crawled_at" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldCrawledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrawledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrawledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrawledAt: %w", err)
	}
	return oldValue.CrawledAt, nil
}

// ClearCrawledAt clears the value of the "crawled_at" field.
func (m *HPMemberMutation) ClearCrawledAt() {
	m.crawled_at = nil
	m.clearedFields[hpmember.FieldCrawledAt] = struct{}{}
}

// CrawledAtCleared returns if the "crawled_at" field was cleared in this mutation.
func (m *HPMemberMutation) CrawledAtCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldCrawledAt]
	return ok
}

// ResetCrawledAt resets all changes to the "crawled_at" field.
func (m *HPMemberMutation) ResetCrawledAt() {
	m.crawled_at = nil
	delete(m.clearedFields, hpmember.FieldCrawledAt)
}

// SetErrorCount sets the "error_count" field.
func (m *HPMemberMutation) SetErrorCount(i int) {
	m.error_count = &i
	m.adderror_count = nil
}

// ErrorCount returns the value of the "error_count" field in the mutation.
func (m *HPMemberMutation) ErrorCount() (r int, exists bool) {
	v := m.error_count
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCount returns the old "error_count" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldErrorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCount: %w", err)
	}
	return oldValue.ErrorCount, nil
}

// AddErrorCount adds i to the "error_count" field.
func (m *HPMemberMutation) AddErrorCount(i int) {
	if m.adderror_count != nil {
		*m.adderror_count += i
	} else {
		m.adderror_count = &i
	}
}

// AddedErrorCount returns the value that was added to the "error_count" field in this mutation.
func (m *HPMemberMutation) AddedErrorCount() (r int, exists bool) {
	v := m.adderror_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrorCount resets all changes to the "error_count" field.
func (m *HPMemberMutation) ResetErrorCount() {
	m.error_count = nil
	m.adderror_count = nil
}

// SetManuallyModified sets the "manually_modified" field.
func (m *HPMemberMutation) SetManuallyModified(jm *jsonfields.ManuallyModified) {
	m.manually_modified = &jm
}

// ManuallyModified returns the value of the "manually_modified" field in the mutation.
func (m *HPMemberMutation) ManuallyModified() (r *jsonfields.ManuallyModified, exists bool) {
	v := m.manually_modified
	if v == nil {
		return
	}
	return *v, true
}

// OldManuallyModified returns the old "manually_modified" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldManuallyModified(ctx context.Context) (v *jsonfields.ManuallyModified, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManuallyModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManuallyModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManuallyModified: %w", err)
	}
	return oldValue.ManuallyModified, nil
}

// ClearManuallyModified clears the value of the "manually_modified" field.
func (m *HPMemberMutation) ClearManuallyModified() {
	m.manually_modified = nil
	m.clearedFields[hpmember.FieldManuallyModified] = struct{}{}
}

// ManuallyModifiedCleared returns if the "manually_modified" field was cleared in this mutation.
func (m *HPMemberMutation) ManuallyModifiedCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldManuallyModified]
	return ok
}

// ResetManuallyModified resets all changes to the "manually_modified" field.
func (m *HPMemberMutation) ResetManuallyModified() {
	m.manually_modified = nil
	delete(m.clearedFields, hpmember.FieldManuallyModified)
}

// SetLastErrorMessage sets the "last_error_message" field.
func (m *HPMemberMutation) SetLastErrorMessage(s string) {
	m.last_error_message = &s
}

// LastErrorMessage returns the value of the "last_error_message" field in the mutation.
func (m *HPMemberMutation) LastErrorMessage() (r string, exists bool) {
	v := m.last_error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLastErrorMessage returns the old "last_error_message" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldLastErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastErrorMessage: %w", err)
	}
	return oldValue.LastErrorMessage, nil
}

// ClearLastErrorMessage clears the value of the "last_error_message" field.
func (m *HPMemberMutation) ClearLastErrorMessage() {
	m.last_error_message = nil
	m.clearedFields[hpmember.FieldLastErrorMessage] = struct{}{}
}

// LastErrorMessageCleared returns if the "last_error_message" field was cleared in this mutation.
func (m *HPMemberMutation) LastErrorMessageCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldLastErrorMessage]
	return ok
}

// ResetLastErrorMessage resets all changes to the "last_error_message" field.
func (m *HPMemberMutation) ResetLastErrorMessage() {
	m.last_error_message = nil
	delete(m.clearedFields, hpmember.FieldLastErrorMessage)
}

// SetRecrawlRequired sets the "recrawl_required" field.
func (m *HPMemberMutation) SetRecrawlRequired(b bool) {
	m.recrawl_required = &b
}

// RecrawlRequired returns the value of the "recrawl_required" field in the mutation.
func (m *HPMemberMutation) RecrawlRequired() (r bool, exists bool) {
	v := m.recrawl_required
	if v == nil {
		return
	}
	return *v, true
}

// OldRecrawlRequired returns the old "recrawl_required" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldRecrawlRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecrawlRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecrawlRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecrawlRequired: %w", err)
	}
	return oldValue.RecrawlRequired, nil
}

// ClearRecrawlRequired clears the value of the "recrawl_required" field.
func (m *HPMemberMutation) ClearRecrawlRequired() {
	m.recrawl_required = nil
	m.clearedFields[hpmember.FieldRecrawlRequired] = struct{}{}
}

// RecrawlRequiredCleared returns if the "recrawl_required" field was cleared in this mutation.
func (m *HPMemberMutation) RecrawlRequiredCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldRecrawlRequired]
	return ok
}

// ResetRecrawlRequired resets all changes to the "recrawl_required" field.
func (m *HPMemberMutation) ResetRecrawlRequired() {
	m.recrawl_required = nil
	delete(m.clearedFields, hpmember.FieldRecrawlRequired)
}

// SetCreatedAt sets the "created_at" field.
func (m *HPMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPMemberMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpmember.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPMemberMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPMemberMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpmember.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPMemberMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpmember.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPMemberMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpmember.FieldUpdatedAt)
}

// SetKey sets the "key" field.
func (m *HPMemberMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *HPMemberMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *HPMemberMutation) ResetKey() {
	m.key = nil
}

// SetArtistKey sets the "artist_key" field.
func (m *HPMemberMutation) SetArtistKey(s string) {
	m.artist_key = &s
}

// ArtistKey returns the value of the "artist_key" field in the mutation.
func (m *HPMemberMutation) ArtistKey() (r string, exists bool) {
	v := m.artist_key
	if v == nil {
		return
	}
	return *v, true
}

// OldArtistKey returns the old "artist_key" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldArtistKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtistKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtistKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtistKey: %w", err)
	}
	return oldValue.ArtistKey, nil
}

// ResetArtistKey resets all changes to the "artist_key" field.
func (m *HPMemberMutation) ResetArtistKey() {
	m.artist_key = nil
}

// SetName sets the "name" field.
func (m *HPMemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HPMemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HPMemberMutation) ResetName() {
	m.name = nil
}

// SetNameKana sets the "name_kana" field.
func (m *HPMemberMutation) SetNameKana(s string) {
	m.name_kana = &s
}

// NameKana returns the value of the "name_kana" field in the mutation.
func (m *HPMemberMutation) NameKana() (r string, exists bool) {
	v := m.name_kana
	if v == nil {
		return
	}
	return *v, true
}

// OldNameKana returns the old "name_kana" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldNameKana(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameKana is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameKana requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameKana: %w", err)
	}
	return oldValue.NameKana, nil
}

// ResetNameKana resets all changes to the "name_kana" field.
func (m *HPMemberMutation) ResetNameKana() {
	m.name_kana = nil
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *HPMemberMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *HPMemberMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *HPMemberMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *HPMemberMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *HPMemberMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *HPMemberMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
}

// SetBloodType sets the "blood_type" field.
func (m *HPMemberMutation) SetBloodType(s string) {
	m.blood_type = &s
}

// BloodType returns the value of the "blood_type" field in the mutation.
func (m *HPMemberMutation) BloodType() (r string, exists bool) {
	v := m.blood_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBloodType returns the old "blood_type" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldBloodType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBloodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBloodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBloodType: %w", err)
	}
	return oldValue.BloodType, nil
}

// ResetBloodType resets all changes to the "blood_type" field.
func (m *HPMemberMutation) ResetBloodType() {
	m.blood_type = nil
}

// SetHometown sets the "hometown" field.
func (m *HPMemberMutation) SetHometown(s string) {
	m.hometown = &s
}

// Hometown returns the value of the "hometown" field in the mutation.
func (m *HPMemberMutation) Hometown() (r string, exists bool) {
	v := m.hometown
	if v == nil {
		return
	}
	return *v, true
}

// OldHometown returns the old "hometown" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldHometown(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHometown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHometown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHometown: %w", err)
	}
	return oldValue.Hometown, nil
}

// ResetHometown resets all changes to the "hometown" field.
func (m *HPMemberMutation) ResetHometown() {
	m.hometown = nil
}

// SetJoinAt sets the "join_at" field.
func (m *HPMemberMutation) SetJoinAt(t time.Time) {
	m.join_at = &t
}

// JoinAt returns the value of the "join_at" field in the mutation.
func (m *HPMemberMutation) JoinAt() (r time.Time, exists bool) {
	v := m.join_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinAt returns the old "join_at" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldJoinAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinAt: %w", err)
	}
	return oldValue.JoinAt, nil
}

// ClearJoinAt clears the value of the "join_at" field.
func (m *HPMemberMutation) ClearJoinAt() {
	m.join_at = nil
	m.clearedFields[hpmember.FieldJoinAt] = struct{}{}
}

// JoinAtCleared returns if the "join_at" field was cleared in this mutation.
func (m *HPMemberMutation) JoinAtCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldJoinAt]
	return ok
}

// ResetJoinAt resets all changes to the "join_at" field.
func (m *HPMemberMutation) ResetJoinAt() {
	m.join_at = nil
	delete(m.clearedFields, hpmember.FieldJoinAt)
}

// SetGraduateAt sets the "graduate_at" field.
func (m *HPMemberMutation) SetGraduateAt(t time.Time) {
	m.graduate_at = &t
}

// GraduateAt returns the value of the "graduate_at" field in the mutation.
func (m *HPMemberMutation) GraduateAt() (r time.Time, exists bool) {
	v := m.graduate_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGraduateAt returns the old "graduate_at" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldGraduateAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGraduateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGraduateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGraduateAt: %w", err)
	}
	return oldValue.GraduateAt, nil
}

// ClearGraduateAt clears the value of the "graduate_at" field.
func (m *HPMemberMutation) ClearGraduateAt() {
	m.graduate_at = nil
	m.clearedFields[hpmember.FieldGraduateAt] = struct{}{}
}

// GraduateAtCleared returns if the "graduate_at" field was cleared in this mutation.
func (m *HPMemberMutation) GraduateAtCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldGraduateAt]
	return ok
}

// ResetGraduateAt resets all changes to the "graduate_at" field.
func (m *HPMemberMutation) ResetGraduateAt() {
	m.graduate_at = nil
	delete(m.clearedFields, hpmember.FieldGraduateAt)
}

// SetColorRgb sets the "color_rgb" field.
func (m *HPMemberMutation) SetColorRgb(s string) {
	m.color_rgb = &s
}

// ColorRgb returns the value of the "color_rgb" field in the mutation.
func (m *HPMemberMutation) ColorRgb() (r string, exists bool) {
	v := m.color_rgb
	if v == nil {
		return
	}
	return *v, true
}

// OldColorRgb returns the old "color_rgb" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldColorRgb(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorRgb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorRgb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorRgb: %w", err)
	}
	return oldValue.ColorRgb, nil
}

// ResetColorRgb resets all changes to the "color_rgb" field.
func (m *HPMemberMutation) ResetColorRgb() {
	m.color_rgb = nil
}

// SetColorName sets the "color_name" field.
func (m *HPMemberMutation) SetColorName(s string) {
	m.color_name = &s
}

// ColorName returns the value of the "color_name" field in the mutation.
func (m *HPMemberMutation) ColorName() (r string, exists bool) {
	v := m.color_name
	if v == nil {
		return
	}
	return *v, true
}

// OldColorName returns the old "color_name" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldColorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorName: %w", err)
	}
	return oldValue.ColorName, nil
}

// ResetColorName resets all changes to the "color_name" field.
func (m *HPMemberMutation) ResetColorName() {
	m.color_name = nil
}

// SetArtistID sets the "artist_id" field.
func (m *HPMemberMutation) SetArtistID(i int) {
	m.artist = &i
}

// ArtistID returns the value of the "artist_id" field in the mutation.
func (m *HPMemberMutation) ArtistID() (r int, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtistID returns the old "artist_id" field's value of the HPMember entity.
// If the HPMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPMemberMutation) OldArtistID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtistID: %w", err)
	}
	return oldValue.ArtistID, nil
}

// ClearArtistID clears the value of the "artist_id" field.
func (m *HPMemberMutation) ClearArtistID() {
	m.artist = nil
	m.clearedFields[hpmember.FieldArtistID] = struct{}{}
}

// ArtistIDCleared returns if the "artist_id" field was cleared in this mutation.
func (m *HPMemberMutation) ArtistIDCleared() bool {
	_, ok := m.clearedFields[hpmember.FieldArtistID]
	return ok
}

// ResetArtistID resets all changes to the "artist_id" field.
func (m *HPMemberMutation) ResetArtistID() {
	m.artist = nil
	delete(m.clearedFields, hpmember.FieldArtistID)
}

// AddAssetIDs adds the "assets" edge to the HPAsset entity by ids.
func (m *HPMemberMutation) AddAssetIDs(ids ...int) {
	if m.assets == nil {
		m.assets = make(map[int]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the HPAsset entity.
func (m *HPMemberMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the HPAsset entity was cleared.
func (m *HPMemberMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the HPAsset entity by IDs.
func (m *HPMemberMutation) RemoveAssetIDs(ids ...int) {
	if m.removedassets == nil {
		m.removedassets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the HPAsset entity.
func (m *HPMemberMutation) RemovedAssetsIDs() (ids []int) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *HPMemberMutation) AssetsIDs() (ids []int) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *HPMemberMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// ClearArtist clears the "artist" edge to the HPArtist entity.
func (m *HPMemberMutation) ClearArtist() {
	m.clearedartist = true
}

// ArtistCleared reports if the "artist" edge to the HPArtist entity was cleared.
func (m *HPMemberMutation) ArtistCleared() bool {
	return m.ArtistIDCleared() || m.clearedartist
}

// ArtistIDs returns the "artist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtistID instead. It exists only for internal usage by the builders.
func (m *HPMemberMutation) ArtistIDs() (ids []int) {
	if id := m.artist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtist resets all changes to the "artist" edge.
func (m *HPMemberMutation) ResetArtist() {
	m.artist = nil
	m.clearedartist = false
}

// AddOwningFeedIDs adds the "owning_feed" edge to the HPFeedItem entity by ids.
func (m *HPMemberMutation) AddOwningFeedIDs(ids ...int) {
	if m.owning_feed == nil {
		m.owning_feed = make(map[int]struct{})
	}
	for i := range ids {
		m.owning_feed[ids[i]] = struct{}{}
	}
}

// ClearOwningFeed clears the "owning_feed" edge to the HPFeedItem entity.
func (m *HPMemberMutation) ClearOwningFeed() {
	m.clearedowning_feed = true
}

// OwningFeedCleared reports if the "owning_feed" edge to the HPFeedItem entity was cleared.
func (m *HPMemberMutation) OwningFeedCleared() bool {
	return m.clearedowning_feed
}

// RemoveOwningFeedIDs removes the "owning_feed" edge to the HPFeedItem entity by IDs.
func (m *HPMemberMutation) RemoveOwningFeedIDs(ids ...int) {
	if m.removedowning_feed == nil {
		m.removedowning_feed = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owning_feed, ids[i])
		m.removedowning_feed[ids[i]] = struct{}{}
	}
}

// RemovedOwningFeed returns the removed IDs of the "owning_feed" edge to the HPFeedItem entity.
func (m *HPMemberMutation) RemovedOwningFeedIDs() (ids []int) {
	for id := range m.removedowning_feed {
		ids = append(ids, id)
	}
	return
}

// OwningFeedIDs returns the "owning_feed" edge IDs in the mutation.
func (m *HPMemberMutation) OwningFeedIDs() (ids []int) {
	for id := range m.owning_feed {
		ids = append(ids, id)
	}
	return
}

// ResetOwningFeed resets all changes to the "owning_feed" edge.
func (m *HPMemberMutation) ResetOwningFeed() {
	m.owning_feed = nil
	m.clearedowning_feed = false
	m.removedowning_feed = nil
}

// AddTaggedFeedIDs adds the "tagged_feed" edge to the HPFeedItem entity by ids.
func (m *HPMemberMutation) AddTaggedFeedIDs(ids ...int) {
	if m.tagged_feed == nil {
		m.tagged_feed = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_feed[ids[i]] = struct{}{}
	}
}

// ClearTaggedFeed clears the "tagged_feed" edge to the HPFeedItem entity.
func (m *HPMemberMutation) ClearTaggedFeed() {
	m.clearedtagged_feed = true
}

// TaggedFeedCleared reports if the "tagged_feed" edge to the HPFeedItem entity was cleared.
func (m *HPMemberMutation) TaggedFeedCleared() bool {
	return m.clearedtagged_feed
}

// RemoveTaggedFeedIDs removes the "tagged_feed" edge to the HPFeedItem entity by IDs.
func (m *HPMemberMutation) RemoveTaggedFeedIDs(ids ...int) {
	if m.removedtagged_feed == nil {
		m.removedtagged_feed = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_feed, ids[i])
		m.removedtagged_feed[ids[i]] = struct{}{}
	}
}

// RemovedTaggedFeed returns the removed IDs of the "tagged_feed" edge to the HPFeedItem entity.
func (m *HPMemberMutation) RemovedTaggedFeedIDs() (ids []int) {
	for id := range m.removedtagged_feed {
		ids = append(ids, id)
	}
	return
}

// TaggedFeedIDs returns the "tagged_feed" edge IDs in the mutation.
func (m *HPMemberMutation) TaggedFeedIDs() (ids []int) {
	for id := range m.tagged_feed {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedFeed resets all changes to the "tagged_feed" edge.
func (m *HPMemberMutation) ResetTaggedFeed() {
	m.tagged_feed = nil
	m.clearedtagged_feed = false
	m.removedtagged_feed = nil
}

// AddOwningIgPostIDs adds the "owning_ig_posts" edge to the HPIgPost entity by ids.
func (m *HPMemberMutation) AddOwningIgPostIDs(ids ...int) {
	if m.owning_ig_posts == nil {
		m.owning_ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.owning_ig_posts[ids[i]] = struct{}{}
	}
}

// ClearOwningIgPosts clears the "owning_ig_posts" edge to the HPIgPost entity.
func (m *HPMemberMutation) ClearOwningIgPosts() {
	m.clearedowning_ig_posts = true
}

// OwningIgPostsCleared reports if the "owning_ig_posts" edge to the HPIgPost entity was cleared.
func (m *HPMemberMutation) OwningIgPostsCleared() bool {
	return m.clearedowning_ig_posts
}

// RemoveOwningIgPostIDs removes the "owning_ig_posts" edge to the HPIgPost entity by IDs.
func (m *HPMemberMutation) RemoveOwningIgPostIDs(ids ...int) {
	if m.removedowning_ig_posts == nil {
		m.removedowning_ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owning_ig_posts, ids[i])
		m.removedowning_ig_posts[ids[i]] = struct{}{}
	}
}

// RemovedOwningIgPosts returns the removed IDs of the "owning_ig_posts" edge to the HPIgPost entity.
func (m *HPMemberMutation) RemovedOwningIgPostsIDs() (ids []int) {
	for id := range m.removedowning_ig_posts {
		ids = append(ids, id)
	}
	return
}

// OwningIgPostsIDs returns the "owning_ig_posts" edge IDs in the mutation.
func (m *HPMemberMutation) OwningIgPostsIDs() (ids []int) {
	for id := range m.owning_ig_posts {
		ids = append(ids, id)
	}
	return
}

// ResetOwningIgPosts resets all changes to the "owning_ig_posts" edge.
func (m *HPMemberMutation) ResetOwningIgPosts() {
	m.owning_ig_posts = nil
	m.clearedowning_ig_posts = false
	m.removedowning_ig_posts = nil
}

// AddTaggedIgPostIDs adds the "tagged_ig_posts" edge to the HPIgPost entity by ids.
func (m *HPMemberMutation) AddTaggedIgPostIDs(ids ...int) {
	if m.tagged_ig_posts == nil {
		m.tagged_ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_ig_posts[ids[i]] = struct{}{}
	}
}

// ClearTaggedIgPosts clears the "tagged_ig_posts" edge to the HPIgPost entity.
func (m *HPMemberMutation) ClearTaggedIgPosts() {
	m.clearedtagged_ig_posts = true
}

// TaggedIgPostsCleared reports if the "tagged_ig_posts" edge to the HPIgPost entity was cleared.
func (m *HPMemberMutation) TaggedIgPostsCleared() bool {
	return m.clearedtagged_ig_posts
}

// RemoveTaggedIgPostIDs removes the "tagged_ig_posts" edge to the HPIgPost entity by IDs.
func (m *HPMemberMutation) RemoveTaggedIgPostIDs(ids ...int) {
	if m.removedtagged_ig_posts == nil {
		m.removedtagged_ig_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_ig_posts, ids[i])
		m.removedtagged_ig_posts[ids[i]] = struct{}{}
	}
}

// RemovedTaggedIgPosts returns the removed IDs of the "tagged_ig_posts" edge to the HPIgPost entity.
func (m *HPMemberMutation) RemovedTaggedIgPostsIDs() (ids []int) {
	for id := range m.removedtagged_ig_posts {
		ids = append(ids, id)
	}
	return
}

// TaggedIgPostsIDs returns the "tagged_ig_posts" edge IDs in the mutation.
func (m *HPMemberMutation) TaggedIgPostsIDs() (ids []int) {
	for id := range m.tagged_ig_posts {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedIgPosts resets all changes to the "tagged_ig_posts" edge.
func (m *HPMemberMutation) ResetTaggedIgPosts() {
	m.tagged_ig_posts = nil
	m.clearedtagged_ig_posts = false
	m.removedtagged_ig_posts = nil
}

// AddOwningAmebloPostIDs adds the "owning_ameblo_posts" edge to the HPAmebloPost entity by ids.
func (m *HPMemberMutation) AddOwningAmebloPostIDs(ids ...int) {
	if m.owning_ameblo_posts == nil {
		m.owning_ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.owning_ameblo_posts[ids[i]] = struct{}{}
	}
}

// ClearOwningAmebloPosts clears the "owning_ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPMemberMutation) ClearOwningAmebloPosts() {
	m.clearedowning_ameblo_posts = true
}

// OwningAmebloPostsCleared reports if the "owning_ameblo_posts" edge to the HPAmebloPost entity was cleared.
func (m *HPMemberMutation) OwningAmebloPostsCleared() bool {
	return m.clearedowning_ameblo_posts
}

// RemoveOwningAmebloPostIDs removes the "owning_ameblo_posts" edge to the HPAmebloPost entity by IDs.
func (m *HPMemberMutation) RemoveOwningAmebloPostIDs(ids ...int) {
	if m.removedowning_ameblo_posts == nil {
		m.removedowning_ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owning_ameblo_posts, ids[i])
		m.removedowning_ameblo_posts[ids[i]] = struct{}{}
	}
}

// RemovedOwningAmebloPosts returns the removed IDs of the "owning_ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPMemberMutation) RemovedOwningAmebloPostsIDs() (ids []int) {
	for id := range m.removedowning_ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// OwningAmebloPostsIDs returns the "owning_ameblo_posts" edge IDs in the mutation.
func (m *HPMemberMutation) OwningAmebloPostsIDs() (ids []int) {
	for id := range m.owning_ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// ResetOwningAmebloPosts resets all changes to the "owning_ameblo_posts" edge.
func (m *HPMemberMutation) ResetOwningAmebloPosts() {
	m.owning_ameblo_posts = nil
	m.clearedowning_ameblo_posts = false
	m.removedowning_ameblo_posts = nil
}

// AddTaggedAmebloPostIDs adds the "tagged_ameblo_posts" edge to the HPAmebloPost entity by ids.
func (m *HPMemberMutation) AddTaggedAmebloPostIDs(ids ...int) {
	if m.tagged_ameblo_posts == nil {
		m.tagged_ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_ameblo_posts[ids[i]] = struct{}{}
	}
}

// ClearTaggedAmebloPosts clears the "tagged_ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPMemberMutation) ClearTaggedAmebloPosts() {
	m.clearedtagged_ameblo_posts = true
}

// TaggedAmebloPostsCleared reports if the "tagged_ameblo_posts" edge to the HPAmebloPost entity was cleared.
func (m *HPMemberMutation) TaggedAmebloPostsCleared() bool {
	return m.clearedtagged_ameblo_posts
}

// RemoveTaggedAmebloPostIDs removes the "tagged_ameblo_posts" edge to the HPAmebloPost entity by IDs.
func (m *HPMemberMutation) RemoveTaggedAmebloPostIDs(ids ...int) {
	if m.removedtagged_ameblo_posts == nil {
		m.removedtagged_ameblo_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_ameblo_posts, ids[i])
		m.removedtagged_ameblo_posts[ids[i]] = struct{}{}
	}
}

// RemovedTaggedAmebloPosts returns the removed IDs of the "tagged_ameblo_posts" edge to the HPAmebloPost entity.
func (m *HPMemberMutation) RemovedTaggedAmebloPostsIDs() (ids []int) {
	for id := range m.removedtagged_ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// TaggedAmebloPostsIDs returns the "tagged_ameblo_posts" edge IDs in the mutation.
func (m *HPMemberMutation) TaggedAmebloPostsIDs() (ids []int) {
	for id := range m.tagged_ameblo_posts {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedAmebloPosts resets all changes to the "tagged_ameblo_posts" edge.
func (m *HPMemberMutation) ResetTaggedAmebloPosts() {
	m.tagged_ameblo_posts = nil
	m.clearedtagged_ameblo_posts = false
	m.removedtagged_ameblo_posts = nil
}

// AddTaggedElineupMallItemIDs adds the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity by ids.
func (m *HPMemberMutation) AddTaggedElineupMallItemIDs(ids ...int) {
	if m.tagged_elineup_mall_items == nil {
		m.tagged_elineup_mall_items = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_elineup_mall_items[ids[i]] = struct{}{}
	}
}

// ClearTaggedElineupMallItems clears the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity.
func (m *HPMemberMutation) ClearTaggedElineupMallItems() {
	m.clearedtagged_elineup_mall_items = true
}

// TaggedElineupMallItemsCleared reports if the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity was cleared.
func (m *HPMemberMutation) TaggedElineupMallItemsCleared() bool {
	return m.clearedtagged_elineup_mall_items
}

// RemoveTaggedElineupMallItemIDs removes the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity by IDs.
func (m *HPMemberMutation) RemoveTaggedElineupMallItemIDs(ids ...int) {
	if m.removedtagged_elineup_mall_items == nil {
		m.removedtagged_elineup_mall_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_elineup_mall_items, ids[i])
		m.removedtagged_elineup_mall_items[ids[i]] = struct{}{}
	}
}

// RemovedTaggedElineupMallItems returns the removed IDs of the "tagged_elineup_mall_items" edge to the HPElineupMallItem entity.
func (m *HPMemberMutation) RemovedTaggedElineupMallItemsIDs() (ids []int) {
	for id := range m.removedtagged_elineup_mall_items {
		ids = append(ids, id)
	}
	return
}

// TaggedElineupMallItemsIDs returns the "tagged_elineup_mall_items" edge IDs in the mutation.
func (m *HPMemberMutation) TaggedElineupMallItemsIDs() (ids []int) {
	for id := range m.tagged_elineup_mall_items {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedElineupMallItems resets all changes to the "tagged_elineup_mall_items" edge.
func (m *HPMemberMutation) ResetTaggedElineupMallItems() {
	m.tagged_elineup_mall_items = nil
	m.clearedtagged_elineup_mall_items = false
	m.removedtagged_elineup_mall_items = nil
}

// AddFollowedByIDs adds the "followed_by" edge to the HPFollow entity by ids.
func (m *HPMemberMutation) AddFollowedByIDs(ids ...int) {
	if m.followed_by == nil {
		m.followed_by = make(map[int]struct{})
	}
	for i := range ids {
		m.followed_by[ids[i]] = struct{}{}
	}
}

// ClearFollowedBy clears the "followed_by" edge to the HPFollow entity.
func (m *HPMemberMutation) ClearFollowedBy() {
	m.clearedfollowed_by = true
}

// FollowedByCleared reports if the "followed_by" edge to the HPFollow entity was cleared.
func (m *HPMemberMutation) FollowedByCleared() bool {
	return m.clearedfollowed_by
}

// RemoveFollowedByIDs removes the "followed_by" edge to the HPFollow entity by IDs.
func (m *HPMemberMutation) RemoveFollowedByIDs(ids ...int) {
	if m.removedfollowed_by == nil {
		m.removedfollowed_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.followed_by, ids[i])
		m.removedfollowed_by[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBy returns the removed IDs of the "followed_by" edge to the HPFollow entity.
func (m *HPMemberMutation) RemovedFollowedByIDs() (ids []int) {
	for id := range m.removedfollowed_by {
		ids = append(ids, id)
	}
	return
}

// FollowedByIDs returns the "followed_by" edge IDs in the mutation.
func (m *HPMemberMutation) FollowedByIDs() (ids []int) {
	for id := range m.followed_by {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBy resets all changes to the "followed_by" edge.
func (m *HPMemberMutation) ResetFollowedBy() {
	m.followed_by = nil
	m.clearedfollowed_by = false
	m.removedfollowed_by = nil
}

// Where appends a list predicates to the HPMemberMutation builder.
func (m *HPMemberMutation) Where(ps ...predicate.HPMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPMember).
func (m *HPMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPMemberMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.crawled_at != nil {
		fields = append(fields, hpmember.FieldCrawledAt)
	}
	if m.error_count != nil {
		fields = append(fields, hpmember.FieldErrorCount)
	}
	if m.manually_modified != nil {
		fields = append(fields, hpmember.FieldManuallyModified)
	}
	if m.last_error_message != nil {
		fields = append(fields, hpmember.FieldLastErrorMessage)
	}
	if m.recrawl_required != nil {
		fields = append(fields, hpmember.FieldRecrawlRequired)
	}
	if m.created_at != nil {
		fields = append(fields, hpmember.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpmember.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, hpmember.FieldKey)
	}
	if m.artist_key != nil {
		fields = append(fields, hpmember.FieldArtistKey)
	}
	if m.name != nil {
		fields = append(fields, hpmember.FieldName)
	}
	if m.name_kana != nil {
		fields = append(fields, hpmember.FieldNameKana)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, hpmember.FieldThumbnailURL)
	}
	if m.date_of_birth != nil {
		fields = append(fields, hpmember.FieldDateOfBirth)
	}
	if m.blood_type != nil {
		fields = append(fields, hpmember.FieldBloodType)
	}
	if m.hometown != nil {
		fields = append(fields, hpmember.FieldHometown)
	}
	if m.join_at != nil {
		fields = append(fields, hpmember.FieldJoinAt)
	}
	if m.graduate_at != nil {
		fields = append(fields, hpmember.FieldGraduateAt)
	}
	if m.color_rgb != nil {
		fields = append(fields, hpmember.FieldColorRgb)
	}
	if m.color_name != nil {
		fields = append(fields, hpmember.FieldColorName)
	}
	if m.artist != nil {
		fields = append(fields, hpmember.FieldArtistID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpmember.FieldCrawledAt:
		return m.CrawledAt()
	case hpmember.FieldErrorCount:
		return m.ErrorCount()
	case hpmember.FieldManuallyModified:
		return m.ManuallyModified()
	case hpmember.FieldLastErrorMessage:
		return m.LastErrorMessage()
	case hpmember.FieldRecrawlRequired:
		return m.RecrawlRequired()
	case hpmember.FieldCreatedAt:
		return m.CreatedAt()
	case hpmember.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpmember.FieldKey:
		return m.Key()
	case hpmember.FieldArtistKey:
		return m.ArtistKey()
	case hpmember.FieldName:
		return m.Name()
	case hpmember.FieldNameKana:
		return m.NameKana()
	case hpmember.FieldThumbnailURL:
		return m.ThumbnailURL()
	case hpmember.FieldDateOfBirth:
		return m.DateOfBirth()
	case hpmember.FieldBloodType:
		return m.BloodType()
	case hpmember.FieldHometown:
		return m.Hometown()
	case hpmember.FieldJoinAt:
		return m.JoinAt()
	case hpmember.FieldGraduateAt:
		return m.GraduateAt()
	case hpmember.FieldColorRgb:
		return m.ColorRgb()
	case hpmember.FieldColorName:
		return m.ColorName()
	case hpmember.FieldArtistID:
		return m.ArtistID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpmember.FieldCrawledAt:
		return m.OldCrawledAt(ctx)
	case hpmember.FieldErrorCount:
		return m.OldErrorCount(ctx)
	case hpmember.FieldManuallyModified:
		return m.OldManuallyModified(ctx)
	case hpmember.FieldLastErrorMessage:
		return m.OldLastErrorMessage(ctx)
	case hpmember.FieldRecrawlRequired:
		return m.OldRecrawlRequired(ctx)
	case hpmember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpmember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpmember.FieldKey:
		return m.OldKey(ctx)
	case hpmember.FieldArtistKey:
		return m.OldArtistKey(ctx)
	case hpmember.FieldName:
		return m.OldName(ctx)
	case hpmember.FieldNameKana:
		return m.OldNameKana(ctx)
	case hpmember.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case hpmember.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case hpmember.FieldBloodType:
		return m.OldBloodType(ctx)
	case hpmember.FieldHometown:
		return m.OldHometown(ctx)
	case hpmember.FieldJoinAt:
		return m.OldJoinAt(ctx)
	case hpmember.FieldGraduateAt:
		return m.OldGraduateAt(ctx)
	case hpmember.FieldColorRgb:
		return m.OldColorRgb(ctx)
	case hpmember.FieldColorName:
		return m.OldColorName(ctx)
	case hpmember.FieldArtistID:
		return m.OldArtistID(ctx)
	}
	return nil, fmt.Errorf("unknown HPMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpmember.FieldCrawledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrawledAt(v)
		return nil
	case hpmember.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCount(v)
		return nil
	case hpmember.FieldManuallyModified:
		v, ok := value.(*jsonfields.ManuallyModified)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManuallyModified(v)
		return nil
	case hpmember.FieldLastErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastErrorMessage(v)
		return nil
	case hpmember.FieldRecrawlRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecrawlRequired(v)
		return nil
	case hpmember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpmember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpmember.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case hpmember.FieldArtistKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtistKey(v)
		return nil
	case hpmember.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hpmember.FieldNameKana:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameKana(v)
		return nil
	case hpmember.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case hpmember.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case hpmember.FieldBloodType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBloodType(v)
		return nil
	case hpmember.FieldHometown:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHometown(v)
		return nil
	case hpmember.FieldJoinAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinAt(v)
		return nil
	case hpmember.FieldGraduateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGraduateAt(v)
		return nil
	case hpmember.FieldColorRgb:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorRgb(v)
		return nil
	case hpmember.FieldColorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorName(v)
		return nil
	case hpmember.FieldArtistID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtistID(v)
		return nil
	}
	return fmt.Errorf("unknown HPMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPMemberMutation) AddedFields() []string {
	var fields []string
	if m.adderror_count != nil {
		fields = append(fields, hpmember.FieldErrorCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpmember.FieldErrorCount:
		return m.AddedErrorCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpmember.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCount(v)
		return nil
	}
	return fmt.Errorf("unknown HPMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpmember.FieldCrawledAt) {
		fields = append(fields, hpmember.FieldCrawledAt)
	}
	if m.FieldCleared(hpmember.FieldManuallyModified) {
		fields = append(fields, hpmember.FieldManuallyModified)
	}
	if m.FieldCleared(hpmember.FieldLastErrorMessage) {
		fields = append(fields, hpmember.FieldLastErrorMessage)
	}
	if m.FieldCleared(hpmember.FieldRecrawlRequired) {
		fields = append(fields, hpmember.FieldRecrawlRequired)
	}
	if m.FieldCleared(hpmember.FieldCreatedAt) {
		fields = append(fields, hpmember.FieldCreatedAt)
	}
	if m.FieldCleared(hpmember.FieldUpdatedAt) {
		fields = append(fields, hpmember.FieldUpdatedAt)
	}
	if m.FieldCleared(hpmember.FieldJoinAt) {
		fields = append(fields, hpmember.FieldJoinAt)
	}
	if m.FieldCleared(hpmember.FieldGraduateAt) {
		fields = append(fields, hpmember.FieldGraduateAt)
	}
	if m.FieldCleared(hpmember.FieldArtistID) {
		fields = append(fields, hpmember.FieldArtistID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPMemberMutation) ClearField(name string) error {
	switch name {
	case hpmember.FieldCrawledAt:
		m.ClearCrawledAt()
		return nil
	case hpmember.FieldManuallyModified:
		m.ClearManuallyModified()
		return nil
	case hpmember.FieldLastErrorMessage:
		m.ClearLastErrorMessage()
		return nil
	case hpmember.FieldRecrawlRequired:
		m.ClearRecrawlRequired()
		return nil
	case hpmember.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpmember.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpmember.FieldJoinAt:
		m.ClearJoinAt()
		return nil
	case hpmember.FieldGraduateAt:
		m.ClearGraduateAt()
		return nil
	case hpmember.FieldArtistID:
		m.ClearArtistID()
		return nil
	}
	return fmt.Errorf("unknown HPMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPMemberMutation) ResetField(name string) error {
	switch name {
	case hpmember.FieldCrawledAt:
		m.ResetCrawledAt()
		return nil
	case hpmember.FieldErrorCount:
		m.ResetErrorCount()
		return nil
	case hpmember.FieldManuallyModified:
		m.ResetManuallyModified()
		return nil
	case hpmember.FieldLastErrorMessage:
		m.ResetLastErrorMessage()
		return nil
	case hpmember.FieldRecrawlRequired:
		m.ResetRecrawlRequired()
		return nil
	case hpmember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpmember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpmember.FieldKey:
		m.ResetKey()
		return nil
	case hpmember.FieldArtistKey:
		m.ResetArtistKey()
		return nil
	case hpmember.FieldName:
		m.ResetName()
		return nil
	case hpmember.FieldNameKana:
		m.ResetNameKana()
		return nil
	case hpmember.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case hpmember.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case hpmember.FieldBloodType:
		m.ResetBloodType()
		return nil
	case hpmember.FieldHometown:
		m.ResetHometown()
		return nil
	case hpmember.FieldJoinAt:
		m.ResetJoinAt()
		return nil
	case hpmember.FieldGraduateAt:
		m.ResetGraduateAt()
		return nil
	case hpmember.FieldColorRgb:
		m.ResetColorRgb()
		return nil
	case hpmember.FieldColorName:
		m.ResetColorName()
		return nil
	case hpmember.FieldArtistID:
		m.ResetArtistID()
		return nil
	}
	return fmt.Errorf("unknown HPMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.assets != nil {
		edges = append(edges, hpmember.EdgeAssets)
	}
	if m.artist != nil {
		edges = append(edges, hpmember.EdgeArtist)
	}
	if m.owning_feed != nil {
		edges = append(edges, hpmember.EdgeOwningFeed)
	}
	if m.tagged_feed != nil {
		edges = append(edges, hpmember.EdgeTaggedFeed)
	}
	if m.owning_ig_posts != nil {
		edges = append(edges, hpmember.EdgeOwningIgPosts)
	}
	if m.tagged_ig_posts != nil {
		edges = append(edges, hpmember.EdgeTaggedIgPosts)
	}
	if m.owning_ameblo_posts != nil {
		edges = append(edges, hpmember.EdgeOwningAmebloPosts)
	}
	if m.tagged_ameblo_posts != nil {
		edges = append(edges, hpmember.EdgeTaggedAmebloPosts)
	}
	if m.tagged_elineup_mall_items != nil {
		edges = append(edges, hpmember.EdgeTaggedElineupMallItems)
	}
	if m.followed_by != nil {
		edges = append(edges, hpmember.EdgeFollowedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpmember.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeArtist:
		if id := m.artist; id != nil {
			return []ent.Value{*id}
		}
	case hpmember.EdgeOwningFeed:
		ids := make([]ent.Value, 0, len(m.owning_feed))
		for id := range m.owning_feed {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeTaggedFeed:
		ids := make([]ent.Value, 0, len(m.tagged_feed))
		for id := range m.tagged_feed {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeOwningIgPosts:
		ids := make([]ent.Value, 0, len(m.owning_ig_posts))
		for id := range m.owning_ig_posts {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeTaggedIgPosts:
		ids := make([]ent.Value, 0, len(m.tagged_ig_posts))
		for id := range m.tagged_ig_posts {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeOwningAmebloPosts:
		ids := make([]ent.Value, 0, len(m.owning_ameblo_posts))
		for id := range m.owning_ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeTaggedAmebloPosts:
		ids := make([]ent.Value, 0, len(m.tagged_ameblo_posts))
		for id := range m.tagged_ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeTaggedElineupMallItems:
		ids := make([]ent.Value, 0, len(m.tagged_elineup_mall_items))
		for id := range m.tagged_elineup_mall_items {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.followed_by))
		for id := range m.followed_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedassets != nil {
		edges = append(edges, hpmember.EdgeAssets)
	}
	if m.removedowning_feed != nil {
		edges = append(edges, hpmember.EdgeOwningFeed)
	}
	if m.removedtagged_feed != nil {
		edges = append(edges, hpmember.EdgeTaggedFeed)
	}
	if m.removedowning_ig_posts != nil {
		edges = append(edges, hpmember.EdgeOwningIgPosts)
	}
	if m.removedtagged_ig_posts != nil {
		edges = append(edges, hpmember.EdgeTaggedIgPosts)
	}
	if m.removedowning_ameblo_posts != nil {
		edges = append(edges, hpmember.EdgeOwningAmebloPosts)
	}
	if m.removedtagged_ameblo_posts != nil {
		edges = append(edges, hpmember.EdgeTaggedAmebloPosts)
	}
	if m.removedtagged_elineup_mall_items != nil {
		edges = append(edges, hpmember.EdgeTaggedElineupMallItems)
	}
	if m.removedfollowed_by != nil {
		edges = append(edges, hpmember.EdgeFollowedBy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPMemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hpmember.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeOwningFeed:
		ids := make([]ent.Value, 0, len(m.removedowning_feed))
		for id := range m.removedowning_feed {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeTaggedFeed:
		ids := make([]ent.Value, 0, len(m.removedtagged_feed))
		for id := range m.removedtagged_feed {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeOwningIgPosts:
		ids := make([]ent.Value, 0, len(m.removedowning_ig_posts))
		for id := range m.removedowning_ig_posts {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeTaggedIgPosts:
		ids := make([]ent.Value, 0, len(m.removedtagged_ig_posts))
		for id := range m.removedtagged_ig_posts {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeOwningAmebloPosts:
		ids := make([]ent.Value, 0, len(m.removedowning_ameblo_posts))
		for id := range m.removedowning_ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeTaggedAmebloPosts:
		ids := make([]ent.Value, 0, len(m.removedtagged_ameblo_posts))
		for id := range m.removedtagged_ameblo_posts {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeTaggedElineupMallItems:
		ids := make([]ent.Value, 0, len(m.removedtagged_elineup_mall_items))
		for id := range m.removedtagged_elineup_mall_items {
			ids = append(ids, id)
		}
		return ids
	case hpmember.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.removedfollowed_by))
		for id := range m.removedfollowed_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedassets {
		edges = append(edges, hpmember.EdgeAssets)
	}
	if m.clearedartist {
		edges = append(edges, hpmember.EdgeArtist)
	}
	if m.clearedowning_feed {
		edges = append(edges, hpmember.EdgeOwningFeed)
	}
	if m.clearedtagged_feed {
		edges = append(edges, hpmember.EdgeTaggedFeed)
	}
	if m.clearedowning_ig_posts {
		edges = append(edges, hpmember.EdgeOwningIgPosts)
	}
	if m.clearedtagged_ig_posts {
		edges = append(edges, hpmember.EdgeTaggedIgPosts)
	}
	if m.clearedowning_ameblo_posts {
		edges = append(edges, hpmember.EdgeOwningAmebloPosts)
	}
	if m.clearedtagged_ameblo_posts {
		edges = append(edges, hpmember.EdgeTaggedAmebloPosts)
	}
	if m.clearedtagged_elineup_mall_items {
		edges = append(edges, hpmember.EdgeTaggedElineupMallItems)
	}
	if m.clearedfollowed_by {
		edges = append(edges, hpmember.EdgeFollowedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case hpmember.EdgeAssets:
		return m.clearedassets
	case hpmember.EdgeArtist:
		return m.clearedartist
	case hpmember.EdgeOwningFeed:
		return m.clearedowning_feed
	case hpmember.EdgeTaggedFeed:
		return m.clearedtagged_feed
	case hpmember.EdgeOwningIgPosts:
		return m.clearedowning_ig_posts
	case hpmember.EdgeTaggedIgPosts:
		return m.clearedtagged_ig_posts
	case hpmember.EdgeOwningAmebloPosts:
		return m.clearedowning_ameblo_posts
	case hpmember.EdgeTaggedAmebloPosts:
		return m.clearedtagged_ameblo_posts
	case hpmember.EdgeTaggedElineupMallItems:
		return m.clearedtagged_elineup_mall_items
	case hpmember.EdgeFollowedBy:
		return m.clearedfollowed_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPMemberMutation) ClearEdge(name string) error {
	switch name {
	case hpmember.EdgeArtist:
		m.ClearArtist()
		return nil
	}
	return fmt.Errorf("unknown HPMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPMemberMutation) ResetEdge(name string) error {
	switch name {
	case hpmember.EdgeAssets:
		m.ResetAssets()
		return nil
	case hpmember.EdgeArtist:
		m.ResetArtist()
		return nil
	case hpmember.EdgeOwningFeed:
		m.ResetOwningFeed()
		return nil
	case hpmember.EdgeTaggedFeed:
		m.ResetTaggedFeed()
		return nil
	case hpmember.EdgeOwningIgPosts:
		m.ResetOwningIgPosts()
		return nil
	case hpmember.EdgeTaggedIgPosts:
		m.ResetTaggedIgPosts()
		return nil
	case hpmember.EdgeOwningAmebloPosts:
		m.ResetOwningAmebloPosts()
		return nil
	case hpmember.EdgeTaggedAmebloPosts:
		m.ResetTaggedAmebloPosts()
		return nil
	case hpmember.EdgeTaggedElineupMallItems:
		m.ResetTaggedElineupMallItems()
		return nil
	case hpmember.EdgeFollowedBy:
		m.ResetFollowedBy()
		return nil
	}
	return fmt.Errorf("unknown HPMember edge %s", name)
}

// HPSortHistoryMutation represents an operation that mutates the HPSortHistory nodes in the graph.
type HPSortHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	sort_result   *jsonfields.HPSortResult
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*HPSortHistory, error)
	predicates    []predicate.HPSortHistory
}

var _ ent.Mutation = (*HPSortHistoryMutation)(nil)

// hpsorthistoryOption allows management of the mutation configuration using functional options.
type hpsorthistoryOption func(*HPSortHistoryMutation)

// newHPSortHistoryMutation creates new mutation for the HPSortHistory entity.
func newHPSortHistoryMutation(c config, op Op, opts ...hpsorthistoryOption) *HPSortHistoryMutation {
	m := &HPSortHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHPSortHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPSortHistoryID sets the ID field of the mutation.
func withHPSortHistoryID(id int) hpsorthistoryOption {
	return func(m *HPSortHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *HPSortHistory
		)
		m.oldValue = func(ctx context.Context) (*HPSortHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPSortHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPSortHistory sets the old HPSortHistory of the mutation.
func withHPSortHistory(node *HPSortHistory) hpsorthistoryOption {
	return func(m *HPSortHistoryMutation) {
		m.oldValue = func(context.Context) (*HPSortHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPSortHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPSortHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPSortHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPSortHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPSortHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HPSortHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPSortHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPSortHistory entity.
// If the HPSortHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPSortHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPSortHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpsorthistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPSortHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpsorthistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPSortHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpsorthistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPSortHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPSortHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPSortHistory entity.
// If the HPSortHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPSortHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPSortHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpsorthistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPSortHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpsorthistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPSortHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpsorthistory.FieldUpdatedAt)
}

// SetSortResult sets the "sort_result" field.
func (m *HPSortHistoryMutation) SetSortResult(jsr jsonfields.HPSortResult) {
	m.sort_result = &jsr
}

// SortResult returns the value of the "sort_result" field in the mutation.
func (m *HPSortHistoryMutation) SortResult() (r jsonfields.HPSortResult, exists bool) {
	v := m.sort_result
	if v == nil {
		return
	}
	return *v, true
}

// OldSortResult returns the old "sort_result" field's value of the HPSortHistory entity.
// If the HPSortHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPSortHistoryMutation) OldSortResult(ctx context.Context) (v jsonfields.HPSortResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortResult: %w", err)
	}
	return oldValue.SortResult, nil
}

// ResetSortResult resets all changes to the "sort_result" field.
func (m *HPSortHistoryMutation) ResetSortResult() {
	m.sort_result = nil
}

// SetOwnerUserID sets the "owner_user_id" field.
func (m *HPSortHistoryMutation) SetOwnerUserID(i int) {
	m.owner = &i
}

// OwnerUserID returns the value of the "owner_user_id" field in the mutation.
func (m *HPSortHistoryMutation) OwnerUserID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerUserID returns the old "owner_user_id" field's value of the HPSortHistory entity.
// If the HPSortHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPSortHistoryMutation) OldOwnerUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerUserID: %w", err)
	}
	return oldValue.OwnerUserID, nil
}

// ClearOwnerUserID clears the value of the "owner_user_id" field.
func (m *HPSortHistoryMutation) ClearOwnerUserID() {
	m.owner = nil
	m.clearedFields[hpsorthistory.FieldOwnerUserID] = struct{}{}
}

// OwnerUserIDCleared returns if the "owner_user_id" field was cleared in this mutation.
func (m *HPSortHistoryMutation) OwnerUserIDCleared() bool {
	_, ok := m.clearedFields[hpsorthistory.FieldOwnerUserID]
	return ok
}

// ResetOwnerUserID resets all changes to the "owner_user_id" field.
func (m *HPSortHistoryMutation) ResetOwnerUserID() {
	m.owner = nil
	delete(m.clearedFields, hpsorthistory.FieldOwnerUserID)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *HPSortHistoryMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *HPSortHistoryMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *HPSortHistoryMutation) OwnerCleared() bool {
	return m.OwnerUserIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *HPSortHistoryMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *HPSortHistoryMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *HPSortHistoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the HPSortHistoryMutation builder.
func (m *HPSortHistoryMutation) Where(ps ...predicate.HPSortHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPSortHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPSortHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPSortHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPSortHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPSortHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPSortHistory).
func (m *HPSortHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPSortHistoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, hpsorthistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpsorthistory.FieldUpdatedAt)
	}
	if m.sort_result != nil {
		fields = append(fields, hpsorthistory.FieldSortResult)
	}
	if m.owner != nil {
		fields = append(fields, hpsorthistory.FieldOwnerUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPSortHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpsorthistory.FieldCreatedAt:
		return m.CreatedAt()
	case hpsorthistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpsorthistory.FieldSortResult:
		return m.SortResult()
	case hpsorthistory.FieldOwnerUserID:
		return m.OwnerUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPSortHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpsorthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpsorthistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpsorthistory.FieldSortResult:
		return m.OldSortResult(ctx)
	case hpsorthistory.FieldOwnerUserID:
		return m.OldOwnerUserID(ctx)
	}
	return nil, fmt.Errorf("unknown HPSortHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPSortHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpsorthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpsorthistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpsorthistory.FieldSortResult:
		v, ok := value.(jsonfields.HPSortResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortResult(v)
		return nil
	case hpsorthistory.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown HPSortHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPSortHistoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPSortHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPSortHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HPSortHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPSortHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpsorthistory.FieldCreatedAt) {
		fields = append(fields, hpsorthistory.FieldCreatedAt)
	}
	if m.FieldCleared(hpsorthistory.FieldUpdatedAt) {
		fields = append(fields, hpsorthistory.FieldUpdatedAt)
	}
	if m.FieldCleared(hpsorthistory.FieldOwnerUserID) {
		fields = append(fields, hpsorthistory.FieldOwnerUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPSortHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPSortHistoryMutation) ClearField(name string) error {
	switch name {
	case hpsorthistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpsorthistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hpsorthistory.FieldOwnerUserID:
		m.ClearOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown HPSortHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPSortHistoryMutation) ResetField(name string) error {
	switch name {
	case hpsorthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpsorthistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpsorthistory.FieldSortResult:
		m.ResetSortResult()
		return nil
	case hpsorthistory.FieldOwnerUserID:
		m.ResetOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown HPSortHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPSortHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, hpsorthistory.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPSortHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpsorthistory.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPSortHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPSortHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPSortHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, hpsorthistory.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPSortHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case hpsorthistory.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPSortHistoryMutation) ClearEdge(name string) error {
	switch name {
	case hpsorthistory.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown HPSortHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPSortHistoryMutation) ResetEdge(name string) error {
	switch name {
	case hpsorthistory.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown HPSortHistory edge %s", name)
}

// HPViewHistoryMutation represents an operation that mutates the HPViewHistory nodes in the graph.
type HPViewHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	content_id      *int
	addcontent_id   *int
	content_post_at *time.Time
	asset_type      *enums.HPAssetType
	is_favorite     *bool
	clearedFields   map[string]struct{}
	feed            *int
	clearedfeed     bool
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*HPViewHistory, error)
	predicates      []predicate.HPViewHistory
}

var _ ent.Mutation = (*HPViewHistoryMutation)(nil)

// hpviewhistoryOption allows management of the mutation configuration using functional options.
type hpviewhistoryOption func(*HPViewHistoryMutation)

// newHPViewHistoryMutation creates new mutation for the HPViewHistory entity.
func newHPViewHistoryMutation(c config, op Op, opts ...hpviewhistoryOption) *HPViewHistoryMutation {
	m := &HPViewHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHPViewHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHPViewHistoryID sets the ID field of the mutation.
func withHPViewHistoryID(id int) hpviewhistoryOption {
	return func(m *HPViewHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *HPViewHistory
		)
		m.oldValue = func(ctx context.Context) (*HPViewHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HPViewHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHPViewHistory sets the old HPViewHistory of the mutation.
func withHPViewHistory(node *HPViewHistory) hpviewhistoryOption {
	return func(m *HPViewHistoryMutation) {
		m.oldValue = func(context.Context) (*HPViewHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HPViewHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HPViewHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HPViewHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HPViewHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HPViewHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HPViewHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HPViewHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HPViewHistory entity.
// If the HPViewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPViewHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HPViewHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hpviewhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HPViewHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hpviewhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HPViewHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hpviewhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HPViewHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HPViewHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HPViewHistory entity.
// If the HPViewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPViewHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HPViewHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hpviewhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HPViewHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hpviewhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HPViewHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hpviewhistory.FieldUpdatedAt)
}

// SetContentID sets the "content_id" field.
func (m *HPViewHistoryMutation) SetContentID(i int) {
	m.content_id = &i
	m.addcontent_id = nil
}

// ContentID returns the value of the "content_id" field in the mutation.
func (m *HPViewHistoryMutation) ContentID() (r int, exists bool) {
	v := m.content_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContentID returns the old "content_id" field's value of the HPViewHistory entity.
// If the HPViewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPViewHistoryMutation) OldContentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentID: %w", err)
	}
	return oldValue.ContentID, nil
}

// AddContentID adds i to the "content_id" field.
func (m *HPViewHistoryMutation) AddContentID(i int) {
	if m.addcontent_id != nil {
		*m.addcontent_id += i
	} else {
		m.addcontent_id = &i
	}
}

// AddedContentID returns the value that was added to the "content_id" field in this mutation.
func (m *HPViewHistoryMutation) AddedContentID() (r int, exists bool) {
	v := m.addcontent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetContentID resets all changes to the "content_id" field.
func (m *HPViewHistoryMutation) ResetContentID() {
	m.content_id = nil
	m.addcontent_id = nil
}

// SetContentPostAt sets the "content_post_at" field.
func (m *HPViewHistoryMutation) SetContentPostAt(t time.Time) {
	m.content_post_at = &t
}

// ContentPostAt returns the value of the "content_post_at" field in the mutation.
func (m *HPViewHistoryMutation) ContentPostAt() (r time.Time, exists bool) {
	v := m.content_post_at
	if v == nil {
		return
	}
	return *v, true
}

// OldContentPostAt returns the old "content_post_at" field's value of the HPViewHistory entity.
// If the HPViewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPViewHistoryMutation) OldContentPostAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentPostAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentPostAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentPostAt: %w", err)
	}
	return oldValue.ContentPostAt, nil
}

// ResetContentPostAt resets all changes to the "content_post_at" field.
func (m *HPViewHistoryMutation) ResetContentPostAt() {
	m.content_post_at = nil
}

// SetAssetType sets the "asset_type" field.
func (m *HPViewHistoryMutation) SetAssetType(eat enums.HPAssetType) {
	m.asset_type = &eat
}

// AssetType returns the value of the "asset_type" field in the mutation.
func (m *HPViewHistoryMutation) AssetType() (r enums.HPAssetType, exists bool) {
	v := m.asset_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetType returns the old "asset_type" field's value of the HPViewHistory entity.
// If the HPViewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPViewHistoryMutation) OldAssetType(ctx context.Context) (v enums.HPAssetType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetType: %w", err)
	}
	return oldValue.AssetType, nil
}

// ResetAssetType resets all changes to the "asset_type" field.
func (m *HPViewHistoryMutation) ResetAssetType() {
	m.asset_type = nil
}

// SetIsFavorite sets the "is_favorite" field.
func (m *HPViewHistoryMutation) SetIsFavorite(b bool) {
	m.is_favorite = &b
}

// IsFavorite returns the value of the "is_favorite" field in the mutation.
func (m *HPViewHistoryMutation) IsFavorite() (r bool, exists bool) {
	v := m.is_favorite
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFavorite returns the old "is_favorite" field's value of the HPViewHistory entity.
// If the HPViewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPViewHistoryMutation) OldIsFavorite(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFavorite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFavorite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFavorite: %w", err)
	}
	return oldValue.IsFavorite, nil
}

// ResetIsFavorite resets all changes to the "is_favorite" field.
func (m *HPViewHistoryMutation) ResetIsFavorite() {
	m.is_favorite = nil
}

// SetOwnerUserID sets the "owner_user_id" field.
func (m *HPViewHistoryMutation) SetOwnerUserID(i int) {
	m.user = &i
}

// OwnerUserID returns the value of the "owner_user_id" field in the mutation.
func (m *HPViewHistoryMutation) OwnerUserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerUserID returns the old "owner_user_id" field's value of the HPViewHistory entity.
// If the HPViewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HPViewHistoryMutation) OldOwnerUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerUserID: %w", err)
	}
	return oldValue.OwnerUserID, nil
}

// ResetOwnerUserID resets all changes to the "owner_user_id" field.
func (m *HPViewHistoryMutation) ResetOwnerUserID() {
	m.user = nil
}

// SetFeedID sets the "feed" edge to the HPFeedItem entity by id.
func (m *HPViewHistoryMutation) SetFeedID(id int) {
	m.feed = &id
}

// ClearFeed clears the "feed" edge to the HPFeedItem entity.
func (m *HPViewHistoryMutation) ClearFeed() {
	m.clearedfeed = true
}

// FeedCleared reports if the "feed" edge to the HPFeedItem entity was cleared.
func (m *HPViewHistoryMutation) FeedCleared() bool {
	return m.clearedfeed
}

// FeedID returns the "feed" edge ID in the mutation.
func (m *HPViewHistoryMutation) FeedID() (id int, exists bool) {
	if m.feed != nil {
		return *m.feed, true
	}
	return
}

// FeedIDs returns the "feed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedID instead. It exists only for internal usage by the builders.
func (m *HPViewHistoryMutation) FeedIDs() (ids []int) {
	if id := m.feed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeed resets all changes to the "feed" edge.
func (m *HPViewHistoryMutation) ResetFeed() {
	m.feed = nil
	m.clearedfeed = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *HPViewHistoryMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *HPViewHistoryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *HPViewHistoryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *HPViewHistoryMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *HPViewHistoryMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *HPViewHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the HPViewHistoryMutation builder.
func (m *HPViewHistoryMutation) Where(ps ...predicate.HPViewHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HPViewHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HPViewHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HPViewHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HPViewHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HPViewHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HPViewHistory).
func (m *HPViewHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HPViewHistoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, hpviewhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hpviewhistory.FieldUpdatedAt)
	}
	if m.content_id != nil {
		fields = append(fields, hpviewhistory.FieldContentID)
	}
	if m.content_post_at != nil {
		fields = append(fields, hpviewhistory.FieldContentPostAt)
	}
	if m.asset_type != nil {
		fields = append(fields, hpviewhistory.FieldAssetType)
	}
	if m.is_favorite != nil {
		fields = append(fields, hpviewhistory.FieldIsFavorite)
	}
	if m.user != nil {
		fields = append(fields, hpviewhistory.FieldOwnerUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HPViewHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hpviewhistory.FieldCreatedAt:
		return m.CreatedAt()
	case hpviewhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case hpviewhistory.FieldContentID:
		return m.ContentID()
	case hpviewhistory.FieldContentPostAt:
		return m.ContentPostAt()
	case hpviewhistory.FieldAssetType:
		return m.AssetType()
	case hpviewhistory.FieldIsFavorite:
		return m.IsFavorite()
	case hpviewhistory.FieldOwnerUserID:
		return m.OwnerUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HPViewHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hpviewhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hpviewhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hpviewhistory.FieldContentID:
		return m.OldContentID(ctx)
	case hpviewhistory.FieldContentPostAt:
		return m.OldContentPostAt(ctx)
	case hpviewhistory.FieldAssetType:
		return m.OldAssetType(ctx)
	case hpviewhistory.FieldIsFavorite:
		return m.OldIsFavorite(ctx)
	case hpviewhistory.FieldOwnerUserID:
		return m.OldOwnerUserID(ctx)
	}
	return nil, fmt.Errorf("unknown HPViewHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPViewHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hpviewhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hpviewhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hpviewhistory.FieldContentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentID(v)
		return nil
	case hpviewhistory.FieldContentPostAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentPostAt(v)
		return nil
	case hpviewhistory.FieldAssetType:
		v, ok := value.(enums.HPAssetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetType(v)
		return nil
	case hpviewhistory.FieldIsFavorite:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFavorite(v)
		return nil
	case hpviewhistory.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown HPViewHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HPViewHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcontent_id != nil {
		fields = append(fields, hpviewhistory.FieldContentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HPViewHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hpviewhistory.FieldContentID:
		return m.AddedContentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HPViewHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hpviewhistory.FieldContentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContentID(v)
		return nil
	}
	return fmt.Errorf("unknown HPViewHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HPViewHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hpviewhistory.FieldCreatedAt) {
		fields = append(fields, hpviewhistory.FieldCreatedAt)
	}
	if m.FieldCleared(hpviewhistory.FieldUpdatedAt) {
		fields = append(fields, hpviewhistory.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HPViewHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HPViewHistoryMutation) ClearField(name string) error {
	switch name {
	case hpviewhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hpviewhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown HPViewHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HPViewHistoryMutation) ResetField(name string) error {
	switch name {
	case hpviewhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hpviewhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hpviewhistory.FieldContentID:
		m.ResetContentID()
		return nil
	case hpviewhistory.FieldContentPostAt:
		m.ResetContentPostAt()
		return nil
	case hpviewhistory.FieldAssetType:
		m.ResetAssetType()
		return nil
	case hpviewhistory.FieldIsFavorite:
		m.ResetIsFavorite()
		return nil
	case hpviewhistory.FieldOwnerUserID:
		m.ResetOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown HPViewHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HPViewHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.feed != nil {
		edges = append(edges, hpviewhistory.EdgeFeed)
	}
	if m.user != nil {
		edges = append(edges, hpviewhistory.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HPViewHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hpviewhistory.EdgeFeed:
		if id := m.feed; id != nil {
			return []ent.Value{*id}
		}
	case hpviewhistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HPViewHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HPViewHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HPViewHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeed {
		edges = append(edges, hpviewhistory.EdgeFeed)
	}
	if m.cleareduser {
		edges = append(edges, hpviewhistory.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HPViewHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case hpviewhistory.EdgeFeed:
		return m.clearedfeed
	case hpviewhistory.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HPViewHistoryMutation) ClearEdge(name string) error {
	switch name {
	case hpviewhistory.EdgeFeed:
		m.ClearFeed()
		return nil
	case hpviewhistory.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown HPViewHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HPViewHistoryMutation) ResetEdge(name string) error {
	switch name {
	case hpviewhistory.EdgeFeed:
		m.ResetFeed()
		return nil
	case hpviewhistory.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown HPViewHistory edge %s", name)
}

// MetricMutation represents an operation that mutates the Metric nodes in the graph.
type MetricMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	metric_name   *string
	date          *string
	value         *float64
	addvalue      *float64
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Metric, error)
	predicates    []predicate.Metric
}

var _ ent.Mutation = (*MetricMutation)(nil)

// metricOption allows management of the mutation configuration using functional options.
type metricOption func(*MetricMutation)

// newMetricMutation creates new mutation for the Metric entity.
func newMetricMutation(c config, op Op, opts ...metricOption) *MetricMutation {
	m := &MetricMutation{
		config:        c,
		op:            op,
		typ:           TypeMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricID sets the ID field of the mutation.
func withMetricID(id int) metricOption {
	return func(m *MetricMutation) {
		var (
			err   error
			once  sync.Once
			value *Metric
		)
		m.oldValue = func(ctx context.Context) (*Metric, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetric sets the old Metric of the mutation.
func withMetric(node *Metric) metricOption {
	return func(m *MetricMutation) {
		m.oldValue = func(context.Context) (*Metric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetricMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metric.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MetricMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[metric.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MetricMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[metric.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetricMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, metric.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetricMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetricMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MetricMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[metric.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MetricMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[metric.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetricMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, metric.FieldUpdatedAt)
}

// SetMetricName sets the "metric_name" field.
func (m *MetricMutation) SetMetricName(s string) {
	m.metric_name = &s
}

// MetricName returns the value of the "metric_name" field in the mutation.
func (m *MetricMutation) MetricName() (r string, exists bool) {
	v := m.metric_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricName returns the old "metric_name" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldMetricName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricName: %w", err)
	}
	return oldValue.MetricName, nil
}

// ResetMetricName resets all changes to the "metric_name" field.
func (m *MetricMutation) ResetMetricName() {
	m.metric_name = nil
}

// SetDate sets the "date" field.
func (m *MetricMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *MetricMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *MetricMutation) ResetDate() {
	m.date = nil
}

// SetValue sets the "value" field.
func (m *MetricMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *MetricMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *MetricMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *MetricMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *MetricMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetOwnerUserID sets the "owner_user_id" field.
func (m *MetricMutation) SetOwnerUserID(i int) {
	m.user = &i
}

// OwnerUserID returns the value of the "owner_user_id" field in the mutation.
func (m *MetricMutation) OwnerUserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerUserID returns the old "owner_user_id" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldOwnerUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerUserID: %w", err)
	}
	return oldValue.OwnerUserID, nil
}

// ClearOwnerUserID clears the value of the "owner_user_id" field.
func (m *MetricMutation) ClearOwnerUserID() {
	m.user = nil
	m.clearedFields[metric.FieldOwnerUserID] = struct{}{}
}

// OwnerUserIDCleared returns if the "owner_user_id" field was cleared in this mutation.
func (m *MetricMutation) OwnerUserIDCleared() bool {
	_, ok := m.clearedFields[metric.FieldOwnerUserID]
	return ok
}

// ResetOwnerUserID resets all changes to the "owner_user_id" field.
func (m *MetricMutation) ResetOwnerUserID() {
	m.user = nil
	delete(m.clearedFields, metric.FieldOwnerUserID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MetricMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MetricMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MetricMutation) UserCleared() bool {
	return m.OwnerUserIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MetricMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MetricMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MetricMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MetricMutation builder.
func (m *MetricMutation) Where(ps ...predicate.Metric) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetricMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetricMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metric, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetricMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetricMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metric).
func (m *MetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, metric.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metric.FieldUpdatedAt)
	}
	if m.metric_name != nil {
		fields = append(fields, metric.FieldMetricName)
	}
	if m.date != nil {
		fields = append(fields, metric.FieldDate)
	}
	if m.value != nil {
		fields = append(fields, metric.FieldValue)
	}
	if m.user != nil {
		fields = append(fields, metric.FieldOwnerUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metric.FieldCreatedAt:
		return m.CreatedAt()
	case metric.FieldUpdatedAt:
		return m.UpdatedAt()
	case metric.FieldMetricName:
		return m.MetricName()
	case metric.FieldDate:
		return m.Date()
	case metric.FieldValue:
		return m.Value()
	case metric.FieldOwnerUserID:
		return m.OwnerUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metric.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metric.FieldMetricName:
		return m.OldMetricName(ctx)
	case metric.FieldDate:
		return m.OldDate(ctx)
	case metric.FieldValue:
		return m.OldValue(ctx)
	case metric.FieldOwnerUserID:
		return m.OldOwnerUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Metric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metric.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metric.FieldMetricName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricName(v)
		return nil
	case metric.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case metric.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case metric.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Metric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, metric.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case metric.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	case metric.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Metric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metric.FieldCreatedAt) {
		fields = append(fields, metric.FieldCreatedAt)
	}
	if m.FieldCleared(metric.FieldUpdatedAt) {
		fields = append(fields, metric.FieldUpdatedAt)
	}
	if m.FieldCleared(metric.FieldOwnerUserID) {
		fields = append(fields, metric.FieldOwnerUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricMutation) ClearField(name string) error {
	switch name {
	case metric.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case metric.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case metric.FieldOwnerUserID:
		m.ClearOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown Metric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricMutation) ResetField(name string) error {
	switch name {
	case metric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metric.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metric.FieldMetricName:
		m.ResetMetricName()
		return nil
	case metric.FieldDate:
		m.ResetDate()
		return nil
	case metric.FieldValue:
		m.ResetValue()
		return nil
	case metric.FieldOwnerUserID:
		m.ResetOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown Metric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, metric.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metric.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, metric.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricMutation) EdgeCleared(name string) bool {
	switch name {
	case metric.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricMutation) ClearEdge(name string) error {
	switch name {
	case metric.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Metric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricMutation) ResetEdge(name string) error {
	switch name {
	case metric.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Metric edge %s", name)
}

// MetricDryRunMutation represents an operation that mutates the MetricDryRun nodes in the graph.
type MetricDryRunMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	metric_name      *string
	date             *string
	value            *float64
	addvalue         *float64
	owner_user_id    *int
	addowner_user_id *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*MetricDryRun, error)
	predicates       []predicate.MetricDryRun
}

var _ ent.Mutation = (*MetricDryRunMutation)(nil)

// metricdryrunOption allows management of the mutation configuration using functional options.
type metricdryrunOption func(*MetricDryRunMutation)

// newMetricDryRunMutation creates new mutation for the MetricDryRun entity.
func newMetricDryRunMutation(c config, op Op, opts ...metricdryrunOption) *MetricDryRunMutation {
	m := &MetricDryRunMutation{
		config:        c,
		op:            op,
		typ:           TypeMetricDryRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricDryRunID sets the ID field of the mutation.
func withMetricDryRunID(id int) metricdryrunOption {
	return func(m *MetricDryRunMutation) {
		var (
			err   error
			once  sync.Once
			value *MetricDryRun
		)
		m.oldValue = func(ctx context.Context) (*MetricDryRun, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetricDryRun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetricDryRun sets the old MetricDryRun of the mutation.
func withMetricDryRun(node *MetricDryRun) metricdryrunOption {
	return func(m *MetricDryRunMutation) {
		m.oldValue = func(context.Context) (*MetricDryRun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricDryRunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricDryRunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricDryRunMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetricDryRunMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MetricDryRun.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MetricDryRunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetricDryRunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MetricDryRun entity.
// If the MetricDryRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricDryRunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MetricDryRunMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[metricdryrun.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MetricDryRunMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[metricdryrun.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetricDryRunMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, metricdryrun.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetricDryRunMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetricDryRunMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MetricDryRun entity.
// If the MetricDryRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricDryRunMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MetricDryRunMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[metricdryrun.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MetricDryRunMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[metricdryrun.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetricDryRunMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, metricdryrun.FieldUpdatedAt)
}

// SetMetricName sets the "metric_name" field.
func (m *MetricDryRunMutation) SetMetricName(s string) {
	m.metric_name = &s
}

// MetricName returns the value of the "metric_name" field in the mutation.
func (m *MetricDryRunMutation) MetricName() (r string, exists bool) {
	v := m.metric_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricName returns the old "metric_name" field's value of the MetricDryRun entity.
// If the MetricDryRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricDryRunMutation) OldMetricName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricName: %w", err)
	}
	return oldValue.MetricName, nil
}

// ResetMetricName resets all changes to the "metric_name" field.
func (m *MetricDryRunMutation) ResetMetricName() {
	m.metric_name = nil
}

// SetDate sets the "date" field.
func (m *MetricDryRunMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *MetricDryRunMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the MetricDryRun entity.
// If the MetricDryRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricDryRunMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *MetricDryRunMutation) ResetDate() {
	m.date = nil
}

// SetValue sets the "value" field.
func (m *MetricDryRunMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *MetricDryRunMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the MetricDryRun entity.
// If the MetricDryRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricDryRunMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *MetricDryRunMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *MetricDryRunMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *MetricDryRunMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetOwnerUserID sets the "owner_user_id" field.
func (m *MetricDryRunMutation) SetOwnerUserID(i int) {
	m.owner_user_id = &i
	m.addowner_user_id = nil
}

// OwnerUserID returns the value of the "owner_user_id" field in the mutation.
func (m *MetricDryRunMutation) OwnerUserID() (r int, exists bool) {
	v := m.owner_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerUserID returns the old "owner_user_id" field's value of the MetricDryRun entity.
// If the MetricDryRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricDryRunMutation) OldOwnerUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerUserID: %w", err)
	}
	return oldValue.OwnerUserID, nil
}

// AddOwnerUserID adds i to the "owner_user_id" field.
func (m *MetricDryRunMutation) AddOwnerUserID(i int) {
	if m.addowner_user_id != nil {
		*m.addowner_user_id += i
	} else {
		m.addowner_user_id = &i
	}
}

// AddedOwnerUserID returns the value that was added to the "owner_user_id" field in this mutation.
func (m *MetricDryRunMutation) AddedOwnerUserID() (r int, exists bool) {
	v := m.addowner_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerUserID clears the value of the "owner_user_id" field.
func (m *MetricDryRunMutation) ClearOwnerUserID() {
	m.owner_user_id = nil
	m.addowner_user_id = nil
	m.clearedFields[metricdryrun.FieldOwnerUserID] = struct{}{}
}

// OwnerUserIDCleared returns if the "owner_user_id" field was cleared in this mutation.
func (m *MetricDryRunMutation) OwnerUserIDCleared() bool {
	_, ok := m.clearedFields[metricdryrun.FieldOwnerUserID]
	return ok
}

// ResetOwnerUserID resets all changes to the "owner_user_id" field.
func (m *MetricDryRunMutation) ResetOwnerUserID() {
	m.owner_user_id = nil
	m.addowner_user_id = nil
	delete(m.clearedFields, metricdryrun.FieldOwnerUserID)
}

// Where appends a list predicates to the MetricDryRunMutation builder.
func (m *MetricDryRunMutation) Where(ps ...predicate.MetricDryRun) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetricDryRunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetricDryRunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MetricDryRun, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetricDryRunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetricDryRunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MetricDryRun).
func (m *MetricDryRunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricDryRunMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, metricdryrun.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metricdryrun.FieldUpdatedAt)
	}
	if m.metric_name != nil {
		fields = append(fields, metricdryrun.FieldMetricName)
	}
	if m.date != nil {
		fields = append(fields, metricdryrun.FieldDate)
	}
	if m.value != nil {
		fields = append(fields, metricdryrun.FieldValue)
	}
	if m.owner_user_id != nil {
		fields = append(fields, metricdryrun.FieldOwnerUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricDryRunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metricdryrun.FieldCreatedAt:
		return m.CreatedAt()
	case metricdryrun.FieldUpdatedAt:
		return m.UpdatedAt()
	case metricdryrun.FieldMetricName:
		return m.MetricName()
	case metricdryrun.FieldDate:
		return m.Date()
	case metricdryrun.FieldValue:
		return m.Value()
	case metricdryrun.FieldOwnerUserID:
		return m.OwnerUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricDryRunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metricdryrun.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metricdryrun.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metricdryrun.FieldMetricName:
		return m.OldMetricName(ctx)
	case metricdryrun.FieldDate:
		return m.OldDate(ctx)
	case metricdryrun.FieldValue:
		return m.OldValue(ctx)
	case metricdryrun.FieldOwnerUserID:
		return m.OldOwnerUserID(ctx)
	}
	return nil, fmt.Errorf("unknown MetricDryRun field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricDryRunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metricdryrun.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metricdryrun.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metricdryrun.FieldMetricName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricName(v)
		return nil
	case metricdryrun.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case metricdryrun.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case metricdryrun.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown MetricDryRun field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricDryRunMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, metricdryrun.FieldValue)
	}
	if m.addowner_user_id != nil {
		fields = append(fields, metricdryrun.FieldOwnerUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricDryRunMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case metricdryrun.FieldValue:
		return m.AddedValue()
	case metricdryrun.FieldOwnerUserID:
		return m.AddedOwnerUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricDryRunMutation) AddField(name string, value ent.Value) error {
	switch name {
	case metricdryrun.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case metricdryrun.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown MetricDryRun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricDryRunMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metricdryrun.FieldCreatedAt) {
		fields = append(fields, metricdryrun.FieldCreatedAt)
	}
	if m.FieldCleared(metricdryrun.FieldUpdatedAt) {
		fields = append(fields, metricdryrun.FieldUpdatedAt)
	}
	if m.FieldCleared(metricdryrun.FieldOwnerUserID) {
		fields = append(fields, metricdryrun.FieldOwnerUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricDryRunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricDryRunMutation) ClearField(name string) error {
	switch name {
	case metricdryrun.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case metricdryrun.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case metricdryrun.FieldOwnerUserID:
		m.ClearOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown MetricDryRun nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricDryRunMutation) ResetField(name string) error {
	switch name {
	case metricdryrun.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metricdryrun.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metricdryrun.FieldMetricName:
		m.ResetMetricName()
		return nil
	case metricdryrun.FieldDate:
		m.ResetDate()
		return nil
	case metricdryrun.FieldValue:
		m.ResetValue()
		return nil
	case metricdryrun.FieldOwnerUserID:
		m.ResetOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown MetricDryRun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricDryRunMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricDryRunMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricDryRunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricDryRunMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricDryRunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricDryRunMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricDryRunMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MetricDryRun unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricDryRunMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MetricDryRun edge %s", name)
}

// TestEntMutation represents an operation that mutates the TestEnt nodes in the graph.
type TestEntMutation struct {
	config
	op             Op
	typ            string
	id             *int
	string_field   *string
	text_field     *string
	bytes_field    *[]byte
	bool_field     *bool
	time_field     *time.Time
	int_field      *int
	addint_field   *int
	int64_field    *int64
	addint64_field *int64
	float_field    *float64
	addfloat_field *float64
	json_field     **jsonfields.TestJSON
	enum_field     *enums.TestEnum
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*TestEnt, error)
	predicates     []predicate.TestEnt
}

var _ ent.Mutation = (*TestEntMutation)(nil)

// testentOption allows management of the mutation configuration using functional options.
type testentOption func(*TestEntMutation)

// newTestEntMutation creates new mutation for the TestEnt entity.
func newTestEntMutation(c config, op Op, opts ...testentOption) *TestEntMutation {
	m := &TestEntMutation{
		config:        c,
		op:            op,
		typ:           TypeTestEnt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestEntID sets the ID field of the mutation.
func withTestEntID(id int) testentOption {
	return func(m *TestEntMutation) {
		var (
			err   error
			once  sync.Once
			value *TestEnt
		)
		m.oldValue = func(ctx context.Context) (*TestEnt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestEnt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestEnt sets the old TestEnt of the mutation.
func withTestEnt(node *TestEnt) testentOption {
	return func(m *TestEntMutation) {
		m.oldValue = func(context.Context) (*TestEnt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestEntMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestEntMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestEntMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestEntMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestEnt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStringField sets the "string_field" field.
func (m *TestEntMutation) SetStringField(s string) {
	m.string_field = &s
}

// StringField returns the value of the "string_field" field in the mutation.
func (m *TestEntMutation) StringField() (r string, exists bool) {
	v := m.string_field
	if v == nil {
		return
	}
	return *v, true
}

// OldStringField returns the old "string_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldStringField(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStringField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStringField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringField: %w", err)
	}
	return oldValue.StringField, nil
}

// ClearStringField clears the value of the "string_field" field.
func (m *TestEntMutation) ClearStringField() {
	m.string_field = nil
	m.clearedFields[testent.FieldStringField] = struct{}{}
}

// StringFieldCleared returns if the "string_field" field was cleared in this mutation.
func (m *TestEntMutation) StringFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldStringField]
	return ok
}

// ResetStringField resets all changes to the "string_field" field.
func (m *TestEntMutation) ResetStringField() {
	m.string_field = nil
	delete(m.clearedFields, testent.FieldStringField)
}

// SetTextField sets the "text_field" field.
func (m *TestEntMutation) SetTextField(s string) {
	m.text_field = &s
}

// TextField returns the value of the "text_field" field in the mutation.
func (m *TestEntMutation) TextField() (r string, exists bool) {
	v := m.text_field
	if v == nil {
		return
	}
	return *v, true
}

// OldTextField returns the old "text_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldTextField(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextField: %w", err)
	}
	return oldValue.TextField, nil
}

// ClearTextField clears the value of the "text_field" field.
func (m *TestEntMutation) ClearTextField() {
	m.text_field = nil
	m.clearedFields[testent.FieldTextField] = struct{}{}
}

// TextFieldCleared returns if the "text_field" field was cleared in this mutation.
func (m *TestEntMutation) TextFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldTextField]
	return ok
}

// ResetTextField resets all changes to the "text_field" field.
func (m *TestEntMutation) ResetTextField() {
	m.text_field = nil
	delete(m.clearedFields, testent.FieldTextField)
}

// SetBytesField sets the "bytes_field" field.
func (m *TestEntMutation) SetBytesField(b []byte) {
	m.bytes_field = &b
}

// BytesField returns the value of the "bytes_field" field in the mutation.
func (m *TestEntMutation) BytesField() (r []byte, exists bool) {
	v := m.bytes_field
	if v == nil {
		return
	}
	return *v, true
}

// OldBytesField returns the old "bytes_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldBytesField(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytesField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytesField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytesField: %w", err)
	}
	return oldValue.BytesField, nil
}

// ClearBytesField clears the value of the "bytes_field" field.
func (m *TestEntMutation) ClearBytesField() {
	m.bytes_field = nil
	m.clearedFields[testent.FieldBytesField] = struct{}{}
}

// BytesFieldCleared returns if the "bytes_field" field was cleared in this mutation.
func (m *TestEntMutation) BytesFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldBytesField]
	return ok
}

// ResetBytesField resets all changes to the "bytes_field" field.
func (m *TestEntMutation) ResetBytesField() {
	m.bytes_field = nil
	delete(m.clearedFields, testent.FieldBytesField)
}

// SetBoolField sets the "bool_field" field.
func (m *TestEntMutation) SetBoolField(b bool) {
	m.bool_field = &b
}

// BoolField returns the value of the "bool_field" field in the mutation.
func (m *TestEntMutation) BoolField() (r bool, exists bool) {
	v := m.bool_field
	if v == nil {
		return
	}
	return *v, true
}

// OldBoolField returns the old "bool_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldBoolField(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoolField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoolField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoolField: %w", err)
	}
	return oldValue.BoolField, nil
}

// ClearBoolField clears the value of the "bool_field" field.
func (m *TestEntMutation) ClearBoolField() {
	m.bool_field = nil
	m.clearedFields[testent.FieldBoolField] = struct{}{}
}

// BoolFieldCleared returns if the "bool_field" field was cleared in this mutation.
func (m *TestEntMutation) BoolFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldBoolField]
	return ok
}

// ResetBoolField resets all changes to the "bool_field" field.
func (m *TestEntMutation) ResetBoolField() {
	m.bool_field = nil
	delete(m.clearedFields, testent.FieldBoolField)
}

// SetTimeField sets the "time_field" field.
func (m *TestEntMutation) SetTimeField(t time.Time) {
	m.time_field = &t
}

// TimeField returns the value of the "time_field" field in the mutation.
func (m *TestEntMutation) TimeField() (r time.Time, exists bool) {
	v := m.time_field
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeField returns the old "time_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldTimeField(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeField: %w", err)
	}
	return oldValue.TimeField, nil
}

// ClearTimeField clears the value of the "time_field" field.
func (m *TestEntMutation) ClearTimeField() {
	m.time_field = nil
	m.clearedFields[testent.FieldTimeField] = struct{}{}
}

// TimeFieldCleared returns if the "time_field" field was cleared in this mutation.
func (m *TestEntMutation) TimeFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldTimeField]
	return ok
}

// ResetTimeField resets all changes to the "time_field" field.
func (m *TestEntMutation) ResetTimeField() {
	m.time_field = nil
	delete(m.clearedFields, testent.FieldTimeField)
}

// SetIntField sets the "int_field" field.
func (m *TestEntMutation) SetIntField(i int) {
	m.int_field = &i
	m.addint_field = nil
}

// IntField returns the value of the "int_field" field in the mutation.
func (m *TestEntMutation) IntField() (r int, exists bool) {
	v := m.int_field
	if v == nil {
		return
	}
	return *v, true
}

// OldIntField returns the old "int_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldIntField(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntField: %w", err)
	}
	return oldValue.IntField, nil
}

// AddIntField adds i to the "int_field" field.
func (m *TestEntMutation) AddIntField(i int) {
	if m.addint_field != nil {
		*m.addint_field += i
	} else {
		m.addint_field = &i
	}
}

// AddedIntField returns the value that was added to the "int_field" field in this mutation.
func (m *TestEntMutation) AddedIntField() (r int, exists bool) {
	v := m.addint_field
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntField clears the value of the "int_field" field.
func (m *TestEntMutation) ClearIntField() {
	m.int_field = nil
	m.addint_field = nil
	m.clearedFields[testent.FieldIntField] = struct{}{}
}

// IntFieldCleared returns if the "int_field" field was cleared in this mutation.
func (m *TestEntMutation) IntFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldIntField]
	return ok
}

// ResetIntField resets all changes to the "int_field" field.
func (m *TestEntMutation) ResetIntField() {
	m.int_field = nil
	m.addint_field = nil
	delete(m.clearedFields, testent.FieldIntField)
}

// SetInt64Field sets the "int64_field" field.
func (m *TestEntMutation) SetInt64Field(i int64) {
	m.int64_field = &i
	m.addint64_field = nil
}

// Int64Field returns the value of the "int64_field" field in the mutation.
func (m *TestEntMutation) Int64Field() (r int64, exists bool) {
	v := m.int64_field
	if v == nil {
		return
	}
	return *v, true
}

// OldInt64Field returns the old "int64_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldInt64Field(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInt64Field is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInt64Field requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInt64Field: %w", err)
	}
	return oldValue.Int64Field, nil
}

// AddInt64Field adds i to the "int64_field" field.
func (m *TestEntMutation) AddInt64Field(i int64) {
	if m.addint64_field != nil {
		*m.addint64_field += i
	} else {
		m.addint64_field = &i
	}
}

// AddedInt64Field returns the value that was added to the "int64_field" field in this mutation.
func (m *TestEntMutation) AddedInt64Field() (r int64, exists bool) {
	v := m.addint64_field
	if v == nil {
		return
	}
	return *v, true
}

// ClearInt64Field clears the value of the "int64_field" field.
func (m *TestEntMutation) ClearInt64Field() {
	m.int64_field = nil
	m.addint64_field = nil
	m.clearedFields[testent.FieldInt64Field] = struct{}{}
}

// Int64FieldCleared returns if the "int64_field" field was cleared in this mutation.
func (m *TestEntMutation) Int64FieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldInt64Field]
	return ok
}

// ResetInt64Field resets all changes to the "int64_field" field.
func (m *TestEntMutation) ResetInt64Field() {
	m.int64_field = nil
	m.addint64_field = nil
	delete(m.clearedFields, testent.FieldInt64Field)
}

// SetFloatField sets the "float_field" field.
func (m *TestEntMutation) SetFloatField(f float64) {
	m.float_field = &f
	m.addfloat_field = nil
}

// FloatField returns the value of the "float_field" field in the mutation.
func (m *TestEntMutation) FloatField() (r float64, exists bool) {
	v := m.float_field
	if v == nil {
		return
	}
	return *v, true
}

// OldFloatField returns the old "float_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldFloatField(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloatField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloatField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloatField: %w", err)
	}
	return oldValue.FloatField, nil
}

// AddFloatField adds f to the "float_field" field.
func (m *TestEntMutation) AddFloatField(f float64) {
	if m.addfloat_field != nil {
		*m.addfloat_field += f
	} else {
		m.addfloat_field = &f
	}
}

// AddedFloatField returns the value that was added to the "float_field" field in this mutation.
func (m *TestEntMutation) AddedFloatField() (r float64, exists bool) {
	v := m.addfloat_field
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloatField clears the value of the "float_field" field.
func (m *TestEntMutation) ClearFloatField() {
	m.float_field = nil
	m.addfloat_field = nil
	m.clearedFields[testent.FieldFloatField] = struct{}{}
}

// FloatFieldCleared returns if the "float_field" field was cleared in this mutation.
func (m *TestEntMutation) FloatFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldFloatField]
	return ok
}

// ResetFloatField resets all changes to the "float_field" field.
func (m *TestEntMutation) ResetFloatField() {
	m.float_field = nil
	m.addfloat_field = nil
	delete(m.clearedFields, testent.FieldFloatField)
}

// SetJSONField sets the "json_field" field.
func (m *TestEntMutation) SetJSONField(jj *jsonfields.TestJSON) {
	m.json_field = &jj
}

// JSONField returns the value of the "json_field" field in the mutation.
func (m *TestEntMutation) JSONField() (r *jsonfields.TestJSON, exists bool) {
	v := m.json_field
	if v == nil {
		return
	}
	return *v, true
}

// OldJSONField returns the old "json_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldJSONField(ctx context.Context) (v *jsonfields.TestJSON, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJSONField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJSONField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJSONField: %w", err)
	}
	return oldValue.JSONField, nil
}

// ClearJSONField clears the value of the "json_field" field.
func (m *TestEntMutation) ClearJSONField() {
	m.json_field = nil
	m.clearedFields[testent.FieldJSONField] = struct{}{}
}

// JSONFieldCleared returns if the "json_field" field was cleared in this mutation.
func (m *TestEntMutation) JSONFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldJSONField]
	return ok
}

// ResetJSONField resets all changes to the "json_field" field.
func (m *TestEntMutation) ResetJSONField() {
	m.json_field = nil
	delete(m.clearedFields, testent.FieldJSONField)
}

// SetEnumField sets the "enum_field" field.
func (m *TestEntMutation) SetEnumField(ee enums.TestEnum) {
	m.enum_field = &ee
}

// EnumField returns the value of the "enum_field" field in the mutation.
func (m *TestEntMutation) EnumField() (r enums.TestEnum, exists bool) {
	v := m.enum_field
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumField returns the old "enum_field" field's value of the TestEnt entity.
// If the TestEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestEntMutation) OldEnumField(ctx context.Context) (v enums.TestEnum, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnumField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnumField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumField: %w", err)
	}
	return oldValue.EnumField, nil
}

// ClearEnumField clears the value of the "enum_field" field.
func (m *TestEntMutation) ClearEnumField() {
	m.enum_field = nil
	m.clearedFields[testent.FieldEnumField] = struct{}{}
}

// EnumFieldCleared returns if the "enum_field" field was cleared in this mutation.
func (m *TestEntMutation) EnumFieldCleared() bool {
	_, ok := m.clearedFields[testent.FieldEnumField]
	return ok
}

// ResetEnumField resets all changes to the "enum_field" field.
func (m *TestEntMutation) ResetEnumField() {
	m.enum_field = nil
	delete(m.clearedFields, testent.FieldEnumField)
}

// Where appends a list predicates to the TestEntMutation builder.
func (m *TestEntMutation) Where(ps ...predicate.TestEnt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestEntMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestEntMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestEnt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestEntMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestEntMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestEnt).
func (m *TestEntMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestEntMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.string_field != nil {
		fields = append(fields, testent.FieldStringField)
	}
	if m.text_field != nil {
		fields = append(fields, testent.FieldTextField)
	}
	if m.bytes_field != nil {
		fields = append(fields, testent.FieldBytesField)
	}
	if m.bool_field != nil {
		fields = append(fields, testent.FieldBoolField)
	}
	if m.time_field != nil {
		fields = append(fields, testent.FieldTimeField)
	}
	if m.int_field != nil {
		fields = append(fields, testent.FieldIntField)
	}
	if m.int64_field != nil {
		fields = append(fields, testent.FieldInt64Field)
	}
	if m.float_field != nil {
		fields = append(fields, testent.FieldFloatField)
	}
	if m.json_field != nil {
		fields = append(fields, testent.FieldJSONField)
	}
	if m.enum_field != nil {
		fields = append(fields, testent.FieldEnumField)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestEntMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testent.FieldStringField:
		return m.StringField()
	case testent.FieldTextField:
		return m.TextField()
	case testent.FieldBytesField:
		return m.BytesField()
	case testent.FieldBoolField:
		return m.BoolField()
	case testent.FieldTimeField:
		return m.TimeField()
	case testent.FieldIntField:
		return m.IntField()
	case testent.FieldInt64Field:
		return m.Int64Field()
	case testent.FieldFloatField:
		return m.FloatField()
	case testent.FieldJSONField:
		return m.JSONField()
	case testent.FieldEnumField:
		return m.EnumField()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestEntMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testent.FieldStringField:
		return m.OldStringField(ctx)
	case testent.FieldTextField:
		return m.OldTextField(ctx)
	case testent.FieldBytesField:
		return m.OldBytesField(ctx)
	case testent.FieldBoolField:
		return m.OldBoolField(ctx)
	case testent.FieldTimeField:
		return m.OldTimeField(ctx)
	case testent.FieldIntField:
		return m.OldIntField(ctx)
	case testent.FieldInt64Field:
		return m.OldInt64Field(ctx)
	case testent.FieldFloatField:
		return m.OldFloatField(ctx)
	case testent.FieldJSONField:
		return m.OldJSONField(ctx)
	case testent.FieldEnumField:
		return m.OldEnumField(ctx)
	}
	return nil, fmt.Errorf("unknown TestEnt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestEntMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testent.FieldStringField:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringField(v)
		return nil
	case testent.FieldTextField:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextField(v)
		return nil
	case testent.FieldBytesField:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytesField(v)
		return nil
	case testent.FieldBoolField:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoolField(v)
		return nil
	case testent.FieldTimeField:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeField(v)
		return nil
	case testent.FieldIntField:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntField(v)
		return nil
	case testent.FieldInt64Field:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInt64Field(v)
		return nil
	case testent.FieldFloatField:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloatField(v)
		return nil
	case testent.FieldJSONField:
		v, ok := value.(*jsonfields.TestJSON)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJSONField(v)
		return nil
	case testent.FieldEnumField:
		v, ok := value.(enums.TestEnum)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumField(v)
		return nil
	}
	return fmt.Errorf("unknown TestEnt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestEntMutation) AddedFields() []string {
	var fields []string
	if m.addint_field != nil {
		fields = append(fields, testent.FieldIntField)
	}
	if m.addint64_field != nil {
		fields = append(fields, testent.FieldInt64Field)
	}
	if m.addfloat_field != nil {
		fields = append(fields, testent.FieldFloatField)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestEntMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testent.FieldIntField:
		return m.AddedIntField()
	case testent.FieldInt64Field:
		return m.AddedInt64Field()
	case testent.FieldFloatField:
		return m.AddedFloatField()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestEntMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testent.FieldIntField:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntField(v)
		return nil
	case testent.FieldInt64Field:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInt64Field(v)
		return nil
	case testent.FieldFloatField:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloatField(v)
		return nil
	}
	return fmt.Errorf("unknown TestEnt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestEntMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testent.FieldStringField) {
		fields = append(fields, testent.FieldStringField)
	}
	if m.FieldCleared(testent.FieldTextField) {
		fields = append(fields, testent.FieldTextField)
	}
	if m.FieldCleared(testent.FieldBytesField) {
		fields = append(fields, testent.FieldBytesField)
	}
	if m.FieldCleared(testent.FieldBoolField) {
		fields = append(fields, testent.FieldBoolField)
	}
	if m.FieldCleared(testent.FieldTimeField) {
		fields = append(fields, testent.FieldTimeField)
	}
	if m.FieldCleared(testent.FieldIntField) {
		fields = append(fields, testent.FieldIntField)
	}
	if m.FieldCleared(testent.FieldInt64Field) {
		fields = append(fields, testent.FieldInt64Field)
	}
	if m.FieldCleared(testent.FieldFloatField) {
		fields = append(fields, testent.FieldFloatField)
	}
	if m.FieldCleared(testent.FieldJSONField) {
		fields = append(fields, testent.FieldJSONField)
	}
	if m.FieldCleared(testent.FieldEnumField) {
		fields = append(fields, testent.FieldEnumField)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestEntMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestEntMutation) ClearField(name string) error {
	switch name {
	case testent.FieldStringField:
		m.ClearStringField()
		return nil
	case testent.FieldTextField:
		m.ClearTextField()
		return nil
	case testent.FieldBytesField:
		m.ClearBytesField()
		return nil
	case testent.FieldBoolField:
		m.ClearBoolField()
		return nil
	case testent.FieldTimeField:
		m.ClearTimeField()
		return nil
	case testent.FieldIntField:
		m.ClearIntField()
		return nil
	case testent.FieldInt64Field:
		m.ClearInt64Field()
		return nil
	case testent.FieldFloatField:
		m.ClearFloatField()
		return nil
	case testent.FieldJSONField:
		m.ClearJSONField()
		return nil
	case testent.FieldEnumField:
		m.ClearEnumField()
		return nil
	}
	return fmt.Errorf("unknown TestEnt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestEntMutation) ResetField(name string) error {
	switch name {
	case testent.FieldStringField:
		m.ResetStringField()
		return nil
	case testent.FieldTextField:
		m.ResetTextField()
		return nil
	case testent.FieldBytesField:
		m.ResetBytesField()
		return nil
	case testent.FieldBoolField:
		m.ResetBoolField()
		return nil
	case testent.FieldTimeField:
		m.ResetTimeField()
		return nil
	case testent.FieldIntField:
		m.ResetIntField()
		return nil
	case testent.FieldInt64Field:
		m.ResetInt64Field()
		return nil
	case testent.FieldFloatField:
		m.ResetFloatField()
		return nil
	case testent.FieldJSONField:
		m.ResetJSONField()
		return nil
	case testent.FieldEnumField:
		m.ResetEnumField()
		return nil
	}
	return fmt.Errorf("unknown TestEnt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestEntMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestEntMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestEntMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestEntMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestEntMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestEntMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestEntMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TestEnt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestEntMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TestEnt edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	created_at                             *time.Time
	updated_at                             *time.Time
	username                               *string
	access_token                           *string
	clearedFields                          map[string]struct{}
	auth                                   map[int]struct{}
	removedauth                            map[int]struct{}
	clearedauth                            bool
	notification_settings                  map[int]struct{}
	removednotification_settings           map[int]struct{}
	clearednotification_settings           bool
	hpview_history                         map[int]struct{}
	removedhpview_history                  map[int]struct{}
	clearedhpview_history                  bool
	hpfollow                               map[int]struct{}
	removedhpfollow                        map[int]struct{}
	clearedhpfollow                        bool
	hpsort_history                         map[int]struct{}
	removedhpsort_history                  map[int]struct{}
	clearedhpsort_history                  bool
	hpfc_event_tickets                     map[int]struct{}
	removedhpfc_event_tickets              map[int]struct{}
	clearedhpfc_event_tickets              bool
	elineup_mall_purchase_histories        map[int]struct{}
	removedelineup_mall_purchase_histories map[int]struct{}
	clearedelineup_mall_purchase_histories bool
	metrics                                map[int]struct{}
	removedmetrics                         map[int]struct{}
	clearedmetrics                         bool
	done                                   bool
	oldValue                               func(context.Context) (*User, error)
	predicates                             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetAccessToken sets the "access_token" field.
func (m *UserMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *UserMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *UserMutation) ResetAccessToken() {
	m.access_token = nil
}

// AddAuthIDs adds the "auth" edge to the Auth entity by ids.
func (m *UserMutation) AddAuthIDs(ids ...int) {
	if m.auth == nil {
		m.auth = make(map[int]struct{})
	}
	for i := range ids {
		m.auth[ids[i]] = struct{}{}
	}
}

// ClearAuth clears the "auth" edge to the Auth entity.
func (m *UserMutation) ClearAuth() {
	m.clearedauth = true
}

// AuthCleared reports if the "auth" edge to the Auth entity was cleared.
func (m *UserMutation) AuthCleared() bool {
	return m.clearedauth
}

// RemoveAuthIDs removes the "auth" edge to the Auth entity by IDs.
func (m *UserMutation) RemoveAuthIDs(ids ...int) {
	if m.removedauth == nil {
		m.removedauth = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.auth, ids[i])
		m.removedauth[ids[i]] = struct{}{}
	}
}

// RemovedAuth returns the removed IDs of the "auth" edge to the Auth entity.
func (m *UserMutation) RemovedAuthIDs() (ids []int) {
	for id := range m.removedauth {
		ids = append(ids, id)
	}
	return
}

// AuthIDs returns the "auth" edge IDs in the mutation.
func (m *UserMutation) AuthIDs() (ids []int) {
	for id := range m.auth {
		ids = append(ids, id)
	}
	return
}

// ResetAuth resets all changes to the "auth" edge.
func (m *UserMutation) ResetAuth() {
	m.auth = nil
	m.clearedauth = false
	m.removedauth = nil
}

// AddNotificationSettingIDs adds the "notification_settings" edge to the UserNotificationSetting entity by ids.
func (m *UserMutation) AddNotificationSettingIDs(ids ...int) {
	if m.notification_settings == nil {
		m.notification_settings = make(map[int]struct{})
	}
	for i := range ids {
		m.notification_settings[ids[i]] = struct{}{}
	}
}

// ClearNotificationSettings clears the "notification_settings" edge to the UserNotificationSetting entity.
func (m *UserMutation) ClearNotificationSettings() {
	m.clearednotification_settings = true
}

// NotificationSettingsCleared reports if the "notification_settings" edge to the UserNotificationSetting entity was cleared.
func (m *UserMutation) NotificationSettingsCleared() bool {
	return m.clearednotification_settings
}

// RemoveNotificationSettingIDs removes the "notification_settings" edge to the UserNotificationSetting entity by IDs.
func (m *UserMutation) RemoveNotificationSettingIDs(ids ...int) {
	if m.removednotification_settings == nil {
		m.removednotification_settings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notification_settings, ids[i])
		m.removednotification_settings[ids[i]] = struct{}{}
	}
}

// RemovedNotificationSettings returns the removed IDs of the "notification_settings" edge to the UserNotificationSetting entity.
func (m *UserMutation) RemovedNotificationSettingsIDs() (ids []int) {
	for id := range m.removednotification_settings {
		ids = append(ids, id)
	}
	return
}

// NotificationSettingsIDs returns the "notification_settings" edge IDs in the mutation.
func (m *UserMutation) NotificationSettingsIDs() (ids []int) {
	for id := range m.notification_settings {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationSettings resets all changes to the "notification_settings" edge.
func (m *UserMutation) ResetNotificationSettings() {
	m.notification_settings = nil
	m.clearednotification_settings = false
	m.removednotification_settings = nil
}

// AddHpviewHistoryIDs adds the "hpview_history" edge to the HPViewHistory entity by ids.
func (m *UserMutation) AddHpviewHistoryIDs(ids ...int) {
	if m.hpview_history == nil {
		m.hpview_history = make(map[int]struct{})
	}
	for i := range ids {
		m.hpview_history[ids[i]] = struct{}{}
	}
}

// ClearHpviewHistory clears the "hpview_history" edge to the HPViewHistory entity.
func (m *UserMutation) ClearHpviewHistory() {
	m.clearedhpview_history = true
}

// HpviewHistoryCleared reports if the "hpview_history" edge to the HPViewHistory entity was cleared.
func (m *UserMutation) HpviewHistoryCleared() bool {
	return m.clearedhpview_history
}

// RemoveHpviewHistoryIDs removes the "hpview_history" edge to the HPViewHistory entity by IDs.
func (m *UserMutation) RemoveHpviewHistoryIDs(ids ...int) {
	if m.removedhpview_history == nil {
		m.removedhpview_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hpview_history, ids[i])
		m.removedhpview_history[ids[i]] = struct{}{}
	}
}

// RemovedHpviewHistory returns the removed IDs of the "hpview_history" edge to the HPViewHistory entity.
func (m *UserMutation) RemovedHpviewHistoryIDs() (ids []int) {
	for id := range m.removedhpview_history {
		ids = append(ids, id)
	}
	return
}

// HpviewHistoryIDs returns the "hpview_history" edge IDs in the mutation.
func (m *UserMutation) HpviewHistoryIDs() (ids []int) {
	for id := range m.hpview_history {
		ids = append(ids, id)
	}
	return
}

// ResetHpviewHistory resets all changes to the "hpview_history" edge.
func (m *UserMutation) ResetHpviewHistory() {
	m.hpview_history = nil
	m.clearedhpview_history = false
	m.removedhpview_history = nil
}

// AddHpfollowIDs adds the "hpfollow" edge to the HPFollow entity by ids.
func (m *UserMutation) AddHpfollowIDs(ids ...int) {
	if m.hpfollow == nil {
		m.hpfollow = make(map[int]struct{})
	}
	for i := range ids {
		m.hpfollow[ids[i]] = struct{}{}
	}
}

// ClearHpfollow clears the "hpfollow" edge to the HPFollow entity.
func (m *UserMutation) ClearHpfollow() {
	m.clearedhpfollow = true
}

// HpfollowCleared reports if the "hpfollow" edge to the HPFollow entity was cleared.
func (m *UserMutation) HpfollowCleared() bool {
	return m.clearedhpfollow
}

// RemoveHpfollowIDs removes the "hpfollow" edge to the HPFollow entity by IDs.
func (m *UserMutation) RemoveHpfollowIDs(ids ...int) {
	if m.removedhpfollow == nil {
		m.removedhpfollow = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hpfollow, ids[i])
		m.removedhpfollow[ids[i]] = struct{}{}
	}
}

// RemovedHpfollow returns the removed IDs of the "hpfollow" edge to the HPFollow entity.
func (m *UserMutation) RemovedHpfollowIDs() (ids []int) {
	for id := range m.removedhpfollow {
		ids = append(ids, id)
	}
	return
}

// HpfollowIDs returns the "hpfollow" edge IDs in the mutation.
func (m *UserMutation) HpfollowIDs() (ids []int) {
	for id := range m.hpfollow {
		ids = append(ids, id)
	}
	return
}

// ResetHpfollow resets all changes to the "hpfollow" edge.
func (m *UserMutation) ResetHpfollow() {
	m.hpfollow = nil
	m.clearedhpfollow = false
	m.removedhpfollow = nil
}

// AddHpsortHistoryIDs adds the "hpsort_history" edge to the HPSortHistory entity by ids.
func (m *UserMutation) AddHpsortHistoryIDs(ids ...int) {
	if m.hpsort_history == nil {
		m.hpsort_history = make(map[int]struct{})
	}
	for i := range ids {
		m.hpsort_history[ids[i]] = struct{}{}
	}
}

// ClearHpsortHistory clears the "hpsort_history" edge to the HPSortHistory entity.
func (m *UserMutation) ClearHpsortHistory() {
	m.clearedhpsort_history = true
}

// HpsortHistoryCleared reports if the "hpsort_history" edge to the HPSortHistory entity was cleared.
func (m *UserMutation) HpsortHistoryCleared() bool {
	return m.clearedhpsort_history
}

// RemoveHpsortHistoryIDs removes the "hpsort_history" edge to the HPSortHistory entity by IDs.
func (m *UserMutation) RemoveHpsortHistoryIDs(ids ...int) {
	if m.removedhpsort_history == nil {
		m.removedhpsort_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hpsort_history, ids[i])
		m.removedhpsort_history[ids[i]] = struct{}{}
	}
}

// RemovedHpsortHistory returns the removed IDs of the "hpsort_history" edge to the HPSortHistory entity.
func (m *UserMutation) RemovedHpsortHistoryIDs() (ids []int) {
	for id := range m.removedhpsort_history {
		ids = append(ids, id)
	}
	return
}

// HpsortHistoryIDs returns the "hpsort_history" edge IDs in the mutation.
func (m *UserMutation) HpsortHistoryIDs() (ids []int) {
	for id := range m.hpsort_history {
		ids = append(ids, id)
	}
	return
}

// ResetHpsortHistory resets all changes to the "hpsort_history" edge.
func (m *UserMutation) ResetHpsortHistory() {
	m.hpsort_history = nil
	m.clearedhpsort_history = false
	m.removedhpsort_history = nil
}

// AddHpfcEventTicketIDs adds the "hpfc_event_tickets" edge to the HPFCEventTicket entity by ids.
func (m *UserMutation) AddHpfcEventTicketIDs(ids ...int) {
	if m.hpfc_event_tickets == nil {
		m.hpfc_event_tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.hpfc_event_tickets[ids[i]] = struct{}{}
	}
}

// ClearHpfcEventTickets clears the "hpfc_event_tickets" edge to the HPFCEventTicket entity.
func (m *UserMutation) ClearHpfcEventTickets() {
	m.clearedhpfc_event_tickets = true
}

// HpfcEventTicketsCleared reports if the "hpfc_event_tickets" edge to the HPFCEventTicket entity was cleared.
func (m *UserMutation) HpfcEventTicketsCleared() bool {
	return m.clearedhpfc_event_tickets
}

// RemoveHpfcEventTicketIDs removes the "hpfc_event_tickets" edge to the HPFCEventTicket entity by IDs.
func (m *UserMutation) RemoveHpfcEventTicketIDs(ids ...int) {
	if m.removedhpfc_event_tickets == nil {
		m.removedhpfc_event_tickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hpfc_event_tickets, ids[i])
		m.removedhpfc_event_tickets[ids[i]] = struct{}{}
	}
}

// RemovedHpfcEventTickets returns the removed IDs of the "hpfc_event_tickets" edge to the HPFCEventTicket entity.
func (m *UserMutation) RemovedHpfcEventTicketsIDs() (ids []int) {
	for id := range m.removedhpfc_event_tickets {
		ids = append(ids, id)
	}
	return
}

// HpfcEventTicketsIDs returns the "hpfc_event_tickets" edge IDs in the mutation.
func (m *UserMutation) HpfcEventTicketsIDs() (ids []int) {
	for id := range m.hpfc_event_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetHpfcEventTickets resets all changes to the "hpfc_event_tickets" edge.
func (m *UserMutation) ResetHpfcEventTickets() {
	m.hpfc_event_tickets = nil
	m.clearedhpfc_event_tickets = false
	m.removedhpfc_event_tickets = nil
}

// AddElineupMallPurchaseHistoryIDs adds the "elineup_mall_purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity by ids.
func (m *UserMutation) AddElineupMallPurchaseHistoryIDs(ids ...int) {
	if m.elineup_mall_purchase_histories == nil {
		m.elineup_mall_purchase_histories = make(map[int]struct{})
	}
	for i := range ids {
		m.elineup_mall_purchase_histories[ids[i]] = struct{}{}
	}
}

// ClearElineupMallPurchaseHistories clears the "elineup_mall_purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity.
func (m *UserMutation) ClearElineupMallPurchaseHistories() {
	m.clearedelineup_mall_purchase_histories = true
}

// ElineupMallPurchaseHistoriesCleared reports if the "elineup_mall_purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity was cleared.
func (m *UserMutation) ElineupMallPurchaseHistoriesCleared() bool {
	return m.clearedelineup_mall_purchase_histories
}

// RemoveElineupMallPurchaseHistoryIDs removes the "elineup_mall_purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity by IDs.
func (m *UserMutation) RemoveElineupMallPurchaseHistoryIDs(ids ...int) {
	if m.removedelineup_mall_purchase_histories == nil {
		m.removedelineup_mall_purchase_histories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.elineup_mall_purchase_histories, ids[i])
		m.removedelineup_mall_purchase_histories[ids[i]] = struct{}{}
	}
}

// RemovedElineupMallPurchaseHistories returns the removed IDs of the "elineup_mall_purchase_histories" edge to the HPElineupMallItemPurchaseHistory entity.
func (m *UserMutation) RemovedElineupMallPurchaseHistoriesIDs() (ids []int) {
	for id := range m.removedelineup_mall_purchase_histories {
		ids = append(ids, id)
	}
	return
}

// ElineupMallPurchaseHistoriesIDs returns the "elineup_mall_purchase_histories" edge IDs in the mutation.
func (m *UserMutation) ElineupMallPurchaseHistoriesIDs() (ids []int) {
	for id := range m.elineup_mall_purchase_histories {
		ids = append(ids, id)
	}
	return
}

// ResetElineupMallPurchaseHistories resets all changes to the "elineup_mall_purchase_histories" edge.
func (m *UserMutation) ResetElineupMallPurchaseHistories() {
	m.elineup_mall_purchase_histories = nil
	m.clearedelineup_mall_purchase_histories = false
	m.removedelineup_mall_purchase_histories = nil
}

// AddMetricIDs adds the "metrics" edge to the Metric entity by ids.
func (m *UserMutation) AddMetricIDs(ids ...int) {
	if m.metrics == nil {
		m.metrics = make(map[int]struct{})
	}
	for i := range ids {
		m.metrics[ids[i]] = struct{}{}
	}
}

// ClearMetrics clears the "metrics" edge to the Metric entity.
func (m *UserMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metric entity was cleared.
func (m *UserMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// RemoveMetricIDs removes the "metrics" edge to the Metric entity by IDs.
func (m *UserMutation) RemoveMetricIDs(ids ...int) {
	if m.removedmetrics == nil {
		m.removedmetrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metrics, ids[i])
		m.removedmetrics[ids[i]] = struct{}{}
	}
}

// RemovedMetrics returns the removed IDs of the "metrics" edge to the Metric entity.
func (m *UserMutation) RemovedMetricsIDs() (ids []int) {
	for id := range m.removedmetrics {
		ids = append(ids, id)
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
func (m *UserMutation) MetricsIDs() (ids []int) {
	for id := range m.metrics {
		ids = append(ids, id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *UserMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
	m.removedmetrics = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.access_token != nil {
		fields = append(fields, user.FieldAccessToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldAccessToken:
		return m.AccessToken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldAccessToken:
		return m.OldAccessToken(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.auth != nil {
		edges = append(edges, user.EdgeAuth)
	}
	if m.notification_settings != nil {
		edges = append(edges, user.EdgeNotificationSettings)
	}
	if m.hpview_history != nil {
		edges = append(edges, user.EdgeHpviewHistory)
	}
	if m.hpfollow != nil {
		edges = append(edges, user.EdgeHpfollow)
	}
	if m.hpsort_history != nil {
		edges = append(edges, user.EdgeHpsortHistory)
	}
	if m.hpfc_event_tickets != nil {
		edges = append(edges, user.EdgeHpfcEventTickets)
	}
	if m.elineup_mall_purchase_histories != nil {
		edges = append(edges, user.EdgeElineupMallPurchaseHistories)
	}
	if m.metrics != nil {
		edges = append(edges, user.EdgeMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuth:
		ids := make([]ent.Value, 0, len(m.auth))
		for id := range m.auth {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationSettings:
		ids := make([]ent.Value, 0, len(m.notification_settings))
		for id := range m.notification_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHpviewHistory:
		ids := make([]ent.Value, 0, len(m.hpview_history))
		for id := range m.hpview_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHpfollow:
		ids := make([]ent.Value, 0, len(m.hpfollow))
		for id := range m.hpfollow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHpsortHistory:
		ids := make([]ent.Value, 0, len(m.hpsort_history))
		for id := range m.hpsort_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHpfcEventTickets:
		ids := make([]ent.Value, 0, len(m.hpfc_event_tickets))
		for id := range m.hpfc_event_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeElineupMallPurchaseHistories:
		ids := make([]ent.Value, 0, len(m.elineup_mall_purchase_histories))
		for id := range m.elineup_mall_purchase_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.metrics))
		for id := range m.metrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedauth != nil {
		edges = append(edges, user.EdgeAuth)
	}
	if m.removednotification_settings != nil {
		edges = append(edges, user.EdgeNotificationSettings)
	}
	if m.removedhpview_history != nil {
		edges = append(edges, user.EdgeHpviewHistory)
	}
	if m.removedhpfollow != nil {
		edges = append(edges, user.EdgeHpfollow)
	}
	if m.removedhpsort_history != nil {
		edges = append(edges, user.EdgeHpsortHistory)
	}
	if m.removedhpfc_event_tickets != nil {
		edges = append(edges, user.EdgeHpfcEventTickets)
	}
	if m.removedelineup_mall_purchase_histories != nil {
		edges = append(edges, user.EdgeElineupMallPurchaseHistories)
	}
	if m.removedmetrics != nil {
		edges = append(edges, user.EdgeMetrics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuth:
		ids := make([]ent.Value, 0, len(m.removedauth))
		for id := range m.removedauth {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationSettings:
		ids := make([]ent.Value, 0, len(m.removednotification_settings))
		for id := range m.removednotification_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHpviewHistory:
		ids := make([]ent.Value, 0, len(m.removedhpview_history))
		for id := range m.removedhpview_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHpfollow:
		ids := make([]ent.Value, 0, len(m.removedhpfollow))
		for id := range m.removedhpfollow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHpsortHistory:
		ids := make([]ent.Value, 0, len(m.removedhpsort_history))
		for id := range m.removedhpsort_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHpfcEventTickets:
		ids := make([]ent.Value, 0, len(m.removedhpfc_event_tickets))
		for id := range m.removedhpfc_event_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeElineupMallPurchaseHistories:
		ids := make([]ent.Value, 0, len(m.removedelineup_mall_purchase_histories))
		for id := range m.removedelineup_mall_purchase_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.removedmetrics))
		for id := range m.removedmetrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedauth {
		edges = append(edges, user.EdgeAuth)
	}
	if m.clearednotification_settings {
		edges = append(edges, user.EdgeNotificationSettings)
	}
	if m.clearedhpview_history {
		edges = append(edges, user.EdgeHpviewHistory)
	}
	if m.clearedhpfollow {
		edges = append(edges, user.EdgeHpfollow)
	}
	if m.clearedhpsort_history {
		edges = append(edges, user.EdgeHpsortHistory)
	}
	if m.clearedhpfc_event_tickets {
		edges = append(edges, user.EdgeHpfcEventTickets)
	}
	if m.clearedelineup_mall_purchase_histories {
		edges = append(edges, user.EdgeElineupMallPurchaseHistories)
	}
	if m.clearedmetrics {
		edges = append(edges, user.EdgeMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAuth:
		return m.clearedauth
	case user.EdgeNotificationSettings:
		return m.clearednotification_settings
	case user.EdgeHpviewHistory:
		return m.clearedhpview_history
	case user.EdgeHpfollow:
		return m.clearedhpfollow
	case user.EdgeHpsortHistory:
		return m.clearedhpsort_history
	case user.EdgeHpfcEventTickets:
		return m.clearedhpfc_event_tickets
	case user.EdgeElineupMallPurchaseHistories:
		return m.clearedelineup_mall_purchase_histories
	case user.EdgeMetrics:
		return m.clearedmetrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAuth:
		m.ResetAuth()
		return nil
	case user.EdgeNotificationSettings:
		m.ResetNotificationSettings()
		return nil
	case user.EdgeHpviewHistory:
		m.ResetHpviewHistory()
		return nil
	case user.EdgeHpfollow:
		m.ResetHpfollow()
		return nil
	case user.EdgeHpsortHistory:
		m.ResetHpsortHistory()
		return nil
	case user.EdgeHpfcEventTickets:
		m.ResetHpfcEventTickets()
		return nil
	case user.EdgeElineupMallPurchaseHistories:
		m.ResetElineupMallPurchaseHistories()
		return nil
	case user.EdgeMetrics:
		m.ResetMetrics()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserNotificationLogMutation represents an operation that mutates the UserNotificationLog nodes in the graph.
type UserNotificationLogMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	key                      *string
	trigger                  *string
	is_test                  *bool
	react_navigation_message *jsonfields.ReactNavigationPush
	expected_delivery_time   *time.Time
	status                   *enums.UserNotificationStatus
	status_message           *string
	clearedFields            map[string]struct{}
	receivers                map[int]struct{}
	removedreceivers         map[int]struct{}
	clearedreceivers         bool
	done                     bool
	oldValue                 func(context.Context) (*UserNotificationLog, error)
	predicates               []predicate.UserNotificationLog
}

var _ ent.Mutation = (*UserNotificationLogMutation)(nil)

// usernotificationlogOption allows management of the mutation configuration using functional options.
type usernotificationlogOption func(*UserNotificationLogMutation)

// newUserNotificationLogMutation creates new mutation for the UserNotificationLog entity.
func newUserNotificationLogMutation(c config, op Op, opts ...usernotificationlogOption) *UserNotificationLogMutation {
	m := &UserNotificationLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNotificationLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNotificationLogID sets the ID field of the mutation.
func withUserNotificationLogID(id int) usernotificationlogOption {
	return func(m *UserNotificationLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNotificationLog
		)
		m.oldValue = func(ctx context.Context) (*UserNotificationLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNotificationLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNotificationLog sets the old UserNotificationLog of the mutation.
func withUserNotificationLog(node *UserNotificationLog) usernotificationlogOption {
	return func(m *UserNotificationLogMutation) {
		m.oldValue = func(context.Context) (*UserNotificationLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNotificationLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNotificationLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNotificationLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNotificationLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNotificationLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserNotificationLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserNotificationLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserNotificationLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usernotificationlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserNotificationLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usernotificationlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserNotificationLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usernotificationlog.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserNotificationLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserNotificationLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserNotificationLogMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usernotificationlog.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserNotificationLogMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usernotificationlog.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserNotificationLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usernotificationlog.FieldUpdatedAt)
}

// SetKey sets the "key" field.
func (m *UserNotificationLogMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserNotificationLogMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserNotificationLogMutation) ResetKey() {
	m.key = nil
}

// SetTrigger sets the "trigger" field.
func (m *UserNotificationLogMutation) SetTrigger(s string) {
	m.trigger = &s
}

// Trigger returns the value of the "trigger" field in the mutation.
func (m *UserNotificationLogMutation) Trigger() (r string, exists bool) {
	v := m.trigger
	if v == nil {
		return
	}
	return *v, true
}

// OldTrigger returns the old "trigger" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldTrigger(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrigger is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrigger requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrigger: %w", err)
	}
	return oldValue.Trigger, nil
}

// ResetTrigger resets all changes to the "trigger" field.
func (m *UserNotificationLogMutation) ResetTrigger() {
	m.trigger = nil
}

// SetIsTest sets the "is_test" field.
func (m *UserNotificationLogMutation) SetIsTest(b bool) {
	m.is_test = &b
}

// IsTest returns the value of the "is_test" field in the mutation.
func (m *UserNotificationLogMutation) IsTest() (r bool, exists bool) {
	v := m.is_test
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTest returns the old "is_test" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldIsTest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTest: %w", err)
	}
	return oldValue.IsTest, nil
}

// ResetIsTest resets all changes to the "is_test" field.
func (m *UserNotificationLogMutation) ResetIsTest() {
	m.is_test = nil
}

// SetReactNavigationMessage sets the "react_navigation_message" field.
func (m *UserNotificationLogMutation) SetReactNavigationMessage(jnp jsonfields.ReactNavigationPush) {
	m.react_navigation_message = &jnp
}

// ReactNavigationMessage returns the value of the "react_navigation_message" field in the mutation.
func (m *UserNotificationLogMutation) ReactNavigationMessage() (r jsonfields.ReactNavigationPush, exists bool) {
	v := m.react_navigation_message
	if v == nil {
		return
	}
	return *v, true
}

// OldReactNavigationMessage returns the old "react_navigation_message" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldReactNavigationMessage(ctx context.Context) (v jsonfields.ReactNavigationPush, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReactNavigationMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReactNavigationMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReactNavigationMessage: %w", err)
	}
	return oldValue.ReactNavigationMessage, nil
}

// ResetReactNavigationMessage resets all changes to the "react_navigation_message" field.
func (m *UserNotificationLogMutation) ResetReactNavigationMessage() {
	m.react_navigation_message = nil
}

// SetExpectedDeliveryTime sets the "expected_delivery_time" field.
func (m *UserNotificationLogMutation) SetExpectedDeliveryTime(t time.Time) {
	m.expected_delivery_time = &t
}

// ExpectedDeliveryTime returns the value of the "expected_delivery_time" field in the mutation.
func (m *UserNotificationLogMutation) ExpectedDeliveryTime() (r time.Time, exists bool) {
	v := m.expected_delivery_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedDeliveryTime returns the old "expected_delivery_time" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldExpectedDeliveryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedDeliveryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedDeliveryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedDeliveryTime: %w", err)
	}
	return oldValue.ExpectedDeliveryTime, nil
}

// ResetExpectedDeliveryTime resets all changes to the "expected_delivery_time" field.
func (m *UserNotificationLogMutation) ResetExpectedDeliveryTime() {
	m.expected_delivery_time = nil
}

// SetStatus sets the "status" field.
func (m *UserNotificationLogMutation) SetStatus(ens enums.UserNotificationStatus) {
	m.status = &ens
}

// Status returns the value of the "status" field in the mutation.
func (m *UserNotificationLogMutation) Status() (r enums.UserNotificationStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldStatus(ctx context.Context) (v enums.UserNotificationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserNotificationLogMutation) ResetStatus() {
	m.status = nil
}

// SetStatusMessage sets the "status_message" field.
func (m *UserNotificationLogMutation) SetStatusMessage(s string) {
	m.status_message = &s
}

// StatusMessage returns the value of the "status_message" field in the mutation.
func (m *UserNotificationLogMutation) StatusMessage() (r string, exists bool) {
	v := m.status_message
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusMessage returns the old "status_message" field's value of the UserNotificationLog entity.
// If the UserNotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationLogMutation) OldStatusMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusMessage: %w", err)
	}
	return oldValue.StatusMessage, nil
}

// ResetStatusMessage resets all changes to the "status_message" field.
func (m *UserNotificationLogMutation) ResetStatusMessage() {
	m.status_message = nil
}

// AddReceiverIDs adds the "receivers" edge to the UserNotificationSetting entity by ids.
func (m *UserNotificationLogMutation) AddReceiverIDs(ids ...int) {
	if m.receivers == nil {
		m.receivers = make(map[int]struct{})
	}
	for i := range ids {
		m.receivers[ids[i]] = struct{}{}
	}
}

// ClearReceivers clears the "receivers" edge to the UserNotificationSetting entity.
func (m *UserNotificationLogMutation) ClearReceivers() {
	m.clearedreceivers = true
}

// ReceiversCleared reports if the "receivers" edge to the UserNotificationSetting entity was cleared.
func (m *UserNotificationLogMutation) ReceiversCleared() bool {
	return m.clearedreceivers
}

// RemoveReceiverIDs removes the "receivers" edge to the UserNotificationSetting entity by IDs.
func (m *UserNotificationLogMutation) RemoveReceiverIDs(ids ...int) {
	if m.removedreceivers == nil {
		m.removedreceivers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.receivers, ids[i])
		m.removedreceivers[ids[i]] = struct{}{}
	}
}

// RemovedReceivers returns the removed IDs of the "receivers" edge to the UserNotificationSetting entity.
func (m *UserNotificationLogMutation) RemovedReceiversIDs() (ids []int) {
	for id := range m.removedreceivers {
		ids = append(ids, id)
	}
	return
}

// ReceiversIDs returns the "receivers" edge IDs in the mutation.
func (m *UserNotificationLogMutation) ReceiversIDs() (ids []int) {
	for id := range m.receivers {
		ids = append(ids, id)
	}
	return
}

// ResetReceivers resets all changes to the "receivers" edge.
func (m *UserNotificationLogMutation) ResetReceivers() {
	m.receivers = nil
	m.clearedreceivers = false
	m.removedreceivers = nil
}

// Where appends a list predicates to the UserNotificationLogMutation builder.
func (m *UserNotificationLogMutation) Where(ps ...predicate.UserNotificationLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserNotificationLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserNotificationLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserNotificationLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserNotificationLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserNotificationLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserNotificationLog).
func (m *UserNotificationLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNotificationLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, usernotificationlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usernotificationlog.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, usernotificationlog.FieldKey)
	}
	if m.trigger != nil {
		fields = append(fields, usernotificationlog.FieldTrigger)
	}
	if m.is_test != nil {
		fields = append(fields, usernotificationlog.FieldIsTest)
	}
	if m.react_navigation_message != nil {
		fields = append(fields, usernotificationlog.FieldReactNavigationMessage)
	}
	if m.expected_delivery_time != nil {
		fields = append(fields, usernotificationlog.FieldExpectedDeliveryTime)
	}
	if m.status != nil {
		fields = append(fields, usernotificationlog.FieldStatus)
	}
	if m.status_message != nil {
		fields = append(fields, usernotificationlog.FieldStatusMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNotificationLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernotificationlog.FieldCreatedAt:
		return m.CreatedAt()
	case usernotificationlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case usernotificationlog.FieldKey:
		return m.Key()
	case usernotificationlog.FieldTrigger:
		return m.Trigger()
	case usernotificationlog.FieldIsTest:
		return m.IsTest()
	case usernotificationlog.FieldReactNavigationMessage:
		return m.ReactNavigationMessage()
	case usernotificationlog.FieldExpectedDeliveryTime:
		return m.ExpectedDeliveryTime()
	case usernotificationlog.FieldStatus:
		return m.Status()
	case usernotificationlog.FieldStatusMessage:
		return m.StatusMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNotificationLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernotificationlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usernotificationlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usernotificationlog.FieldKey:
		return m.OldKey(ctx)
	case usernotificationlog.FieldTrigger:
		return m.OldTrigger(ctx)
	case usernotificationlog.FieldIsTest:
		return m.OldIsTest(ctx)
	case usernotificationlog.FieldReactNavigationMessage:
		return m.OldReactNavigationMessage(ctx)
	case usernotificationlog.FieldExpectedDeliveryTime:
		return m.OldExpectedDeliveryTime(ctx)
	case usernotificationlog.FieldStatus:
		return m.OldStatus(ctx)
	case usernotificationlog.FieldStatusMessage:
		return m.OldStatusMessage(ctx)
	}
	return nil, fmt.Errorf("unknown UserNotificationLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernotificationlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usernotificationlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usernotificationlog.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case usernotificationlog.FieldTrigger:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrigger(v)
		return nil
	case usernotificationlog.FieldIsTest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTest(v)
		return nil
	case usernotificationlog.FieldReactNavigationMessage:
		v, ok := value.(jsonfields.ReactNavigationPush)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReactNavigationMessage(v)
		return nil
	case usernotificationlog.FieldExpectedDeliveryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedDeliveryTime(v)
		return nil
	case usernotificationlog.FieldStatus:
		v, ok := value.(enums.UserNotificationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usernotificationlog.FieldStatusMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusMessage(v)
		return nil
	}
	return fmt.Errorf("unknown UserNotificationLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNotificationLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNotificationLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNotificationLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNotificationLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usernotificationlog.FieldCreatedAt) {
		fields = append(fields, usernotificationlog.FieldCreatedAt)
	}
	if m.FieldCleared(usernotificationlog.FieldUpdatedAt) {
		fields = append(fields, usernotificationlog.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNotificationLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNotificationLogMutation) ClearField(name string) error {
	switch name {
	case usernotificationlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usernotificationlog.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNotificationLogMutation) ResetField(name string) error {
	switch name {
	case usernotificationlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usernotificationlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usernotificationlog.FieldKey:
		m.ResetKey()
		return nil
	case usernotificationlog.FieldTrigger:
		m.ResetTrigger()
		return nil
	case usernotificationlog.FieldIsTest:
		m.ResetIsTest()
		return nil
	case usernotificationlog.FieldReactNavigationMessage:
		m.ResetReactNavigationMessage()
		return nil
	case usernotificationlog.FieldExpectedDeliveryTime:
		m.ResetExpectedDeliveryTime()
		return nil
	case usernotificationlog.FieldStatus:
		m.ResetStatus()
		return nil
	case usernotificationlog.FieldStatusMessage:
		m.ResetStatusMessage()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNotificationLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.receivers != nil {
		edges = append(edges, usernotificationlog.EdgeReceivers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNotificationLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usernotificationlog.EdgeReceivers:
		ids := make([]ent.Value, 0, len(m.receivers))
		for id := range m.receivers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNotificationLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedreceivers != nil {
		edges = append(edges, usernotificationlog.EdgeReceivers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNotificationLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usernotificationlog.EdgeReceivers:
		ids := make([]ent.Value, 0, len(m.removedreceivers))
		for id := range m.removedreceivers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNotificationLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreceivers {
		edges = append(edges, usernotificationlog.EdgeReceivers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNotificationLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usernotificationlog.EdgeReceivers:
		return m.clearedreceivers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNotificationLogMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNotificationLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNotificationLogMutation) ResetEdge(name string) error {
	switch name {
	case usernotificationlog.EdgeReceivers:
		m.ResetReceivers()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationLog edge %s", name)
}

// UserNotificationSettingMutation represents an operation that mutates the UserNotificationSetting nodes in the graph.
type UserNotificationSettingMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	token                    *string
	slug                     *string
	name                     *string
	enable_new_posts         *bool
	enable_payment_start     *bool
	enable_payment_due       *bool
	clearedFields            map[string]struct{}
	user                     *int
	cleareduser              bool
	notification_logs        map[int]struct{}
	removednotification_logs map[int]struct{}
	clearednotification_logs bool
	done                     bool
	oldValue                 func(context.Context) (*UserNotificationSetting, error)
	predicates               []predicate.UserNotificationSetting
}

var _ ent.Mutation = (*UserNotificationSettingMutation)(nil)

// usernotificationsettingOption allows management of the mutation configuration using functional options.
type usernotificationsettingOption func(*UserNotificationSettingMutation)

// newUserNotificationSettingMutation creates new mutation for the UserNotificationSetting entity.
func newUserNotificationSettingMutation(c config, op Op, opts ...usernotificationsettingOption) *UserNotificationSettingMutation {
	m := &UserNotificationSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNotificationSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNotificationSettingID sets the ID field of the mutation.
func withUserNotificationSettingID(id int) usernotificationsettingOption {
	return func(m *UserNotificationSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNotificationSetting
		)
		m.oldValue = func(ctx context.Context) (*UserNotificationSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNotificationSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNotificationSetting sets the old UserNotificationSetting of the mutation.
func withUserNotificationSetting(node *UserNotificationSetting) usernotificationsettingOption {
	return func(m *UserNotificationSettingMutation) {
		m.oldValue = func(context.Context) (*UserNotificationSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNotificationSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNotificationSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNotificationSettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNotificationSettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNotificationSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserNotificationSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserNotificationSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserNotificationSettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usernotificationsetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserNotificationSettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usernotificationsetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserNotificationSettingMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usernotificationsetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserNotificationSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserNotificationSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserNotificationSettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usernotificationsetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserNotificationSettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usernotificationsetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserNotificationSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usernotificationsetting.FieldUpdatedAt)
}

// SetToken sets the "token" field.
func (m *UserNotificationSettingMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *UserNotificationSettingMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *UserNotificationSettingMutation) ResetToken() {
	m.token = nil
}

// SetSlug sets the "slug" field.
func (m *UserNotificationSettingMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *UserNotificationSettingMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *UserNotificationSettingMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *UserNotificationSettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserNotificationSettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserNotificationSettingMutation) ResetName() {
	m.name = nil
}

// SetEnableNewPosts sets the "enable_new_posts" field.
func (m *UserNotificationSettingMutation) SetEnableNewPosts(b bool) {
	m.enable_new_posts = &b
}

// EnableNewPosts returns the value of the "enable_new_posts" field in the mutation.
func (m *UserNotificationSettingMutation) EnableNewPosts() (r bool, exists bool) {
	v := m.enable_new_posts
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableNewPosts returns the old "enable_new_posts" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldEnableNewPosts(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableNewPosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableNewPosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableNewPosts: %w", err)
	}
	return oldValue.EnableNewPosts, nil
}

// ResetEnableNewPosts resets all changes to the "enable_new_posts" field.
func (m *UserNotificationSettingMutation) ResetEnableNewPosts() {
	m.enable_new_posts = nil
}

// SetEnablePaymentStart sets the "enable_payment_start" field.
func (m *UserNotificationSettingMutation) SetEnablePaymentStart(b bool) {
	m.enable_payment_start = &b
}

// EnablePaymentStart returns the value of the "enable_payment_start" field in the mutation.
func (m *UserNotificationSettingMutation) EnablePaymentStart() (r bool, exists bool) {
	v := m.enable_payment_start
	if v == nil {
		return
	}
	return *v, true
}

// OldEnablePaymentStart returns the old "enable_payment_start" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldEnablePaymentStart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnablePaymentStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnablePaymentStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnablePaymentStart: %w", err)
	}
	return oldValue.EnablePaymentStart, nil
}

// ResetEnablePaymentStart resets all changes to the "enable_payment_start" field.
func (m *UserNotificationSettingMutation) ResetEnablePaymentStart() {
	m.enable_payment_start = nil
}

// SetEnablePaymentDue sets the "enable_payment_due" field.
func (m *UserNotificationSettingMutation) SetEnablePaymentDue(b bool) {
	m.enable_payment_due = &b
}

// EnablePaymentDue returns the value of the "enable_payment_due" field in the mutation.
func (m *UserNotificationSettingMutation) EnablePaymentDue() (r bool, exists bool) {
	v := m.enable_payment_due
	if v == nil {
		return
	}
	return *v, true
}

// OldEnablePaymentDue returns the old "enable_payment_due" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldEnablePaymentDue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnablePaymentDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnablePaymentDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnablePaymentDue: %w", err)
	}
	return oldValue.EnablePaymentDue, nil
}

// ResetEnablePaymentDue resets all changes to the "enable_payment_due" field.
func (m *UserNotificationSettingMutation) ResetEnablePaymentDue() {
	m.enable_payment_due = nil
}

// SetOwnerUserID sets the "owner_user_id" field.
func (m *UserNotificationSettingMutation) SetOwnerUserID(i int) {
	m.user = &i
}

// OwnerUserID returns the value of the "owner_user_id" field in the mutation.
func (m *UserNotificationSettingMutation) OwnerUserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerUserID returns the old "owner_user_id" field's value of the UserNotificationSetting entity.
// If the UserNotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationSettingMutation) OldOwnerUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerUserID: %w", err)
	}
	return oldValue.OwnerUserID, nil
}

// ClearOwnerUserID clears the value of the "owner_user_id" field.
func (m *UserNotificationSettingMutation) ClearOwnerUserID() {
	m.user = nil
	m.clearedFields[usernotificationsetting.FieldOwnerUserID] = struct{}{}
}

// OwnerUserIDCleared returns if the "owner_user_id" field was cleared in this mutation.
func (m *UserNotificationSettingMutation) OwnerUserIDCleared() bool {
	_, ok := m.clearedFields[usernotificationsetting.FieldOwnerUserID]
	return ok
}

// ResetOwnerUserID resets all changes to the "owner_user_id" field.
func (m *UserNotificationSettingMutation) ResetOwnerUserID() {
	m.user = nil
	delete(m.clearedFields, usernotificationsetting.FieldOwnerUserID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserNotificationSettingMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserNotificationSettingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserNotificationSettingMutation) UserCleared() bool {
	return m.OwnerUserIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserNotificationSettingMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserNotificationSettingMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserNotificationSettingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddNotificationLogIDs adds the "notification_logs" edge to the UserNotificationLog entity by ids.
func (m *UserNotificationSettingMutation) AddNotificationLogIDs(ids ...int) {
	if m.notification_logs == nil {
		m.notification_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.notification_logs[ids[i]] = struct{}{}
	}
}

// ClearNotificationLogs clears the "notification_logs" edge to the UserNotificationLog entity.
func (m *UserNotificationSettingMutation) ClearNotificationLogs() {
	m.clearednotification_logs = true
}

// NotificationLogsCleared reports if the "notification_logs" edge to the UserNotificationLog entity was cleared.
func (m *UserNotificationSettingMutation) NotificationLogsCleared() bool {
	return m.clearednotification_logs
}

// RemoveNotificationLogIDs removes the "notification_logs" edge to the UserNotificationLog entity by IDs.
func (m *UserNotificationSettingMutation) RemoveNotificationLogIDs(ids ...int) {
	if m.removednotification_logs == nil {
		m.removednotification_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notification_logs, ids[i])
		m.removednotification_logs[ids[i]] = struct{}{}
	}
}

// RemovedNotificationLogs returns the removed IDs of the "notification_logs" edge to the UserNotificationLog entity.
func (m *UserNotificationSettingMutation) RemovedNotificationLogsIDs() (ids []int) {
	for id := range m.removednotification_logs {
		ids = append(ids, id)
	}
	return
}

// NotificationLogsIDs returns the "notification_logs" edge IDs in the mutation.
func (m *UserNotificationSettingMutation) NotificationLogsIDs() (ids []int) {
	for id := range m.notification_logs {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationLogs resets all changes to the "notification_logs" edge.
func (m *UserNotificationSettingMutation) ResetNotificationLogs() {
	m.notification_logs = nil
	m.clearednotification_logs = false
	m.removednotification_logs = nil
}

// Where appends a list predicates to the UserNotificationSettingMutation builder.
func (m *UserNotificationSettingMutation) Where(ps ...predicate.UserNotificationSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserNotificationSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserNotificationSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserNotificationSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserNotificationSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserNotificationSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserNotificationSetting).
func (m *UserNotificationSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNotificationSettingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, usernotificationsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usernotificationsetting.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, usernotificationsetting.FieldToken)
	}
	if m.slug != nil {
		fields = append(fields, usernotificationsetting.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, usernotificationsetting.FieldName)
	}
	if m.enable_new_posts != nil {
		fields = append(fields, usernotificationsetting.FieldEnableNewPosts)
	}
	if m.enable_payment_start != nil {
		fields = append(fields, usernotificationsetting.FieldEnablePaymentStart)
	}
	if m.enable_payment_due != nil {
		fields = append(fields, usernotificationsetting.FieldEnablePaymentDue)
	}
	if m.user != nil {
		fields = append(fields, usernotificationsetting.FieldOwnerUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNotificationSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernotificationsetting.FieldCreatedAt:
		return m.CreatedAt()
	case usernotificationsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case usernotificationsetting.FieldToken:
		return m.Token()
	case usernotificationsetting.FieldSlug:
		return m.Slug()
	case usernotificationsetting.FieldName:
		return m.Name()
	case usernotificationsetting.FieldEnableNewPosts:
		return m.EnableNewPosts()
	case usernotificationsetting.FieldEnablePaymentStart:
		return m.EnablePaymentStart()
	case usernotificationsetting.FieldEnablePaymentDue:
		return m.EnablePaymentDue()
	case usernotificationsetting.FieldOwnerUserID:
		return m.OwnerUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNotificationSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernotificationsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usernotificationsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usernotificationsetting.FieldToken:
		return m.OldToken(ctx)
	case usernotificationsetting.FieldSlug:
		return m.OldSlug(ctx)
	case usernotificationsetting.FieldName:
		return m.OldName(ctx)
	case usernotificationsetting.FieldEnableNewPosts:
		return m.OldEnableNewPosts(ctx)
	case usernotificationsetting.FieldEnablePaymentStart:
		return m.OldEnablePaymentStart(ctx)
	case usernotificationsetting.FieldEnablePaymentDue:
		return m.OldEnablePaymentDue(ctx)
	case usernotificationsetting.FieldOwnerUserID:
		return m.OldOwnerUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UserNotificationSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernotificationsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usernotificationsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usernotificationsetting.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case usernotificationsetting.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case usernotificationsetting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usernotificationsetting.FieldEnableNewPosts:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableNewPosts(v)
		return nil
	case usernotificationsetting.FieldEnablePaymentStart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnablePaymentStart(v)
		return nil
	case usernotificationsetting.FieldEnablePaymentDue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnablePaymentDue(v)
		return nil
	case usernotificationsetting.FieldOwnerUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserNotificationSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNotificationSettingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNotificationSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNotificationSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNotificationSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usernotificationsetting.FieldCreatedAt) {
		fields = append(fields, usernotificationsetting.FieldCreatedAt)
	}
	if m.FieldCleared(usernotificationsetting.FieldUpdatedAt) {
		fields = append(fields, usernotificationsetting.FieldUpdatedAt)
	}
	if m.FieldCleared(usernotificationsetting.FieldOwnerUserID) {
		fields = append(fields, usernotificationsetting.FieldOwnerUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNotificationSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNotificationSettingMutation) ClearField(name string) error {
	switch name {
	case usernotificationsetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usernotificationsetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case usernotificationsetting.FieldOwnerUserID:
		m.ClearOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNotificationSettingMutation) ResetField(name string) error {
	switch name {
	case usernotificationsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usernotificationsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usernotificationsetting.FieldToken:
		m.ResetToken()
		return nil
	case usernotificationsetting.FieldSlug:
		m.ResetSlug()
		return nil
	case usernotificationsetting.FieldName:
		m.ResetName()
		return nil
	case usernotificationsetting.FieldEnableNewPosts:
		m.ResetEnableNewPosts()
		return nil
	case usernotificationsetting.FieldEnablePaymentStart:
		m.ResetEnablePaymentStart()
		return nil
	case usernotificationsetting.FieldEnablePaymentDue:
		m.ResetEnablePaymentDue()
		return nil
	case usernotificationsetting.FieldOwnerUserID:
		m.ResetOwnerUserID()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNotificationSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usernotificationsetting.EdgeUser)
	}
	if m.notification_logs != nil {
		edges = append(edges, usernotificationsetting.EdgeNotificationLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNotificationSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usernotificationsetting.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usernotificationsetting.EdgeNotificationLogs:
		ids := make([]ent.Value, 0, len(m.notification_logs))
		for id := range m.notification_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNotificationSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednotification_logs != nil {
		edges = append(edges, usernotificationsetting.EdgeNotificationLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNotificationSettingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usernotificationsetting.EdgeNotificationLogs:
		ids := make([]ent.Value, 0, len(m.removednotification_logs))
		for id := range m.removednotification_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNotificationSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usernotificationsetting.EdgeUser)
	}
	if m.clearednotification_logs {
		edges = append(edges, usernotificationsetting.EdgeNotificationLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNotificationSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case usernotificationsetting.EdgeUser:
		return m.cleareduser
	case usernotificationsetting.EdgeNotificationLogs:
		return m.clearednotification_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNotificationSettingMutation) ClearEdge(name string) error {
	switch name {
	case usernotificationsetting.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNotificationSettingMutation) ResetEdge(name string) error {
	switch name {
	case usernotificationsetting.EdgeUser:
		m.ResetUser()
		return nil
	case usernotificationsetting.EdgeNotificationLogs:
		m.ResetNotificationLogs()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationSetting edge %s", name)
}
