// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/yssk22/hpapp/go/service/ent/auth"
	"github.com/yssk22/hpapp/go/service/ent/hpameblopost"
	"github.com/yssk22/hpapp/go/service/ent/hpartist"
	"github.com/yssk22/hpapp/go/service/ent/hpblob"
	"github.com/yssk22/hpapp/go/service/ent/hpelineupmallitem"
	"github.com/yssk22/hpapp/go/service/ent/hpelineupmallitempurchasehistory"
	"github.com/yssk22/hpapp/go/service/ent/hpevent"
	"github.com/yssk22/hpapp/go/service/ent/hpfceventticket"
	"github.com/yssk22/hpapp/go/service/ent/hpfeeditem"
	"github.com/yssk22/hpapp/go/service/ent/hpfollow"
	"github.com/yssk22/hpapp/go/service/ent/hpigpost"
	"github.com/yssk22/hpapp/go/service/ent/hpmember"
	"github.com/yssk22/hpapp/go/service/ent/hpsorthistory"
	"github.com/yssk22/hpapp/go/service/ent/hpviewhistory"
	"github.com/yssk22/hpapp/go/service/ent/user"
	"github.com/yssk22/hpapp/go/service/ent/usernotificationsetting"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AuthQuery) CollectFields(ctx context.Context, satisfies ...string) (*AuthQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *AuthQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(auth.Columns))
		selectedFields = []string{auth.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[auth.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, auth.FieldCreatedAt)
				fieldSeen[auth.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[auth.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, auth.FieldUpdatedAt)
				fieldSeen[auth.FieldUpdatedAt] = struct{}{}
			}
		case "providerName":
			if _, ok := fieldSeen[auth.FieldProviderName]; !ok {
				selectedFields = append(selectedFields, auth.FieldProviderName)
				fieldSeen[auth.FieldProviderName] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type authPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AuthPaginateOption
}

func newAuthPaginateArgs(rv map[string]interface{}) *authPaginateArgs {
	args := &authPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &AuthOrder{Field: &AuthOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithAuthOrder(order))
			}
		case *AuthOrder:
			if v != nil {
				args.opts = append(args.opts, WithAuthOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hap *HPAmebloPostQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPAmebloPostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hap, nil
	}
	if err := hap.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hap, nil
}

func (hap *HPAmebloPostQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpameblopost.Columns))
		selectedFields = []string{hpameblopost.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "ownerArtist":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hap.withOwnerArtist = query
			if _, ok := fieldSeen[hpameblopost.FieldOwnerArtistID]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldOwnerArtistID)
				fieldSeen[hpameblopost.FieldOwnerArtistID] = struct{}{}
			}
		case "ownerMember":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hap.withOwnerMember = query
			if _, ok := fieldSeen[hpameblopost.FieldOwnerMemberID]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldOwnerMemberID)
				fieldSeen[hpameblopost.FieldOwnerMemberID] = struct{}{}
			}
		case "taggedArtists":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hap.WithNamedTaggedArtists(alias, func(wq *HPArtistQuery) {
				*wq = *query
			})
		case "taggedMembers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hap.WithNamedTaggedMembers(alias, func(wq *HPMemberQuery) {
				*wq = *query
			})
		case "blobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPBlobClient{config: hap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hap.WithNamedBlobs(alias, func(wq *HPBlobQuery) {
				*wq = *query
			})
		case "crawledAt":
			if _, ok := fieldSeen[hpameblopost.FieldCrawledAt]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldCrawledAt)
				fieldSeen[hpameblopost.FieldCrawledAt] = struct{}{}
			}
		case "errorCount":
			if _, ok := fieldSeen[hpameblopost.FieldErrorCount]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldErrorCount)
				fieldSeen[hpameblopost.FieldErrorCount] = struct{}{}
			}
		case "lastErrorMessage":
			if _, ok := fieldSeen[hpameblopost.FieldLastErrorMessage]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldLastErrorMessage)
				fieldSeen[hpameblopost.FieldLastErrorMessage] = struct{}{}
			}
		case "recrawlRequired":
			if _, ok := fieldSeen[hpameblopost.FieldRecrawlRequired]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldRecrawlRequired)
				fieldSeen[hpameblopost.FieldRecrawlRequired] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hpameblopost.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldCreatedAt)
				fieldSeen[hpameblopost.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpameblopost.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldUpdatedAt)
				fieldSeen[hpameblopost.FieldUpdatedAt] = struct{}{}
			}
		case "path":
			if _, ok := fieldSeen[hpameblopost.FieldPath]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldPath)
				fieldSeen[hpameblopost.FieldPath] = struct{}{}
			}
		case "nextPath":
			if _, ok := fieldSeen[hpameblopost.FieldNextPath]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldNextPath)
				fieldSeen[hpameblopost.FieldNextPath] = struct{}{}
			}
		case "prevPath":
			if _, ok := fieldSeen[hpameblopost.FieldPrevPath]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldPrevPath)
				fieldSeen[hpameblopost.FieldPrevPath] = struct{}{}
			}
		case "artistKey":
			if _, ok := fieldSeen[hpameblopost.FieldArtistKey]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldArtistKey)
				fieldSeen[hpameblopost.FieldArtistKey] = struct{}{}
			}
		case "memberKey":
			if _, ok := fieldSeen[hpameblopost.FieldMemberKey]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldMemberKey)
				fieldSeen[hpameblopost.FieldMemberKey] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[hpameblopost.FieldTitle]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldTitle)
				fieldSeen[hpameblopost.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[hpameblopost.FieldDescription]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldDescription)
				fieldSeen[hpameblopost.FieldDescription] = struct{}{}
			}
		case "theme":
			if _, ok := fieldSeen[hpameblopost.FieldTheme]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldTheme)
				fieldSeen[hpameblopost.FieldTheme] = struct{}{}
			}
		case "postAt":
			if _, ok := fieldSeen[hpameblopost.FieldPostAt]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldPostAt)
				fieldSeen[hpameblopost.FieldPostAt] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[hpameblopost.FieldSource]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldSource)
				fieldSeen[hpameblopost.FieldSource] = struct{}{}
			}
		case "images":
			if _, ok := fieldSeen[hpameblopost.FieldImages]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldImages)
				fieldSeen[hpameblopost.FieldImages] = struct{}{}
			}
		case "likes":
			if _, ok := fieldSeen[hpameblopost.FieldLikes]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldLikes)
				fieldSeen[hpameblopost.FieldLikes] = struct{}{}
			}
		case "comments":
			if _, ok := fieldSeen[hpameblopost.FieldComments]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldComments)
				fieldSeen[hpameblopost.FieldComments] = struct{}{}
			}
		case "reblogs":
			if _, ok := fieldSeen[hpameblopost.FieldReblogs]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldReblogs)
				fieldSeen[hpameblopost.FieldReblogs] = struct{}{}
			}
		case "ownerArtistID":
			if _, ok := fieldSeen[hpameblopost.FieldOwnerArtistID]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldOwnerArtistID)
				fieldSeen[hpameblopost.FieldOwnerArtistID] = struct{}{}
			}
		case "ownerMemberID":
			if _, ok := fieldSeen[hpameblopost.FieldOwnerMemberID]; !ok {
				selectedFields = append(selectedFields, hpameblopost.FieldOwnerMemberID)
				fieldSeen[hpameblopost.FieldOwnerMemberID] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hap.Select(selectedFields...)
	}
	return nil
}

type hpameblopostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPAmebloPostPaginateOption
}

func newHPAmebloPostPaginateArgs(rv map[string]interface{}) *hpameblopostPaginateArgs {
	args := &hpameblopostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPAmebloPostOrder{Field: &HPAmebloPostOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPAmebloPostOrder(order))
			}
		case *HPAmebloPostOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPAmebloPostOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ha *HPArtistQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPArtistQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ha, nil
	}
	if err := ha.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ha, nil
}

func (ha *HPArtistQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpartist.Columns))
		selectedFields = []string{hpartist.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "members":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: ha.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ha.WithNamedMembers(alias, func(wq *HPMemberQuery) {
				*wq = *query
			})
		case "crawledAt":
			if _, ok := fieldSeen[hpartist.FieldCrawledAt]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldCrawledAt)
				fieldSeen[hpartist.FieldCrawledAt] = struct{}{}
			}
		case "errorCount":
			if _, ok := fieldSeen[hpartist.FieldErrorCount]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldErrorCount)
				fieldSeen[hpartist.FieldErrorCount] = struct{}{}
			}
		case "lastErrorMessage":
			if _, ok := fieldSeen[hpartist.FieldLastErrorMessage]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldLastErrorMessage)
				fieldSeen[hpartist.FieldLastErrorMessage] = struct{}{}
			}
		case "recrawlRequired":
			if _, ok := fieldSeen[hpartist.FieldRecrawlRequired]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldRecrawlRequired)
				fieldSeen[hpartist.FieldRecrawlRequired] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hpartist.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldCreatedAt)
				fieldSeen[hpartist.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpartist.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldUpdatedAt)
				fieldSeen[hpartist.FieldUpdatedAt] = struct{}{}
			}
		case "key":
			if _, ok := fieldSeen[hpartist.FieldKey]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldKey)
				fieldSeen[hpartist.FieldKey] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hpartist.FieldName]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldName)
				fieldSeen[hpartist.FieldName] = struct{}{}
			}
		case "thumbnailURL":
			if _, ok := fieldSeen[hpartist.FieldThumbnailURL]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldThumbnailURL)
				fieldSeen[hpartist.FieldThumbnailURL] = struct{}{}
			}
		case "index":
			if _, ok := fieldSeen[hpartist.FieldIndex]; !ok {
				selectedFields = append(selectedFields, hpartist.FieldIndex)
				fieldSeen[hpartist.FieldIndex] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ha.Select(selectedFields...)
	}
	return nil
}

type hpartistPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPArtistPaginateOption
}

func newHPArtistPaginateArgs(rv map[string]interface{}) *hpartistPaginateArgs {
	args := &hpartistPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPArtistOrder{Field: &HPArtistOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPArtistOrder(order))
			}
		case *HPArtistOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPArtistOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hb *HPBlobQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPBlobQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hb, nil
	}
	if err := hb.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hb, nil
}

func (hb *HPBlobQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpblob.Columns))
		selectedFields = []string{hpblob.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "ownerArtist":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hb.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hb.withOwnerArtist = query
			if _, ok := fieldSeen[hpblob.FieldOwnerArtistID]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldOwnerArtistID)
				fieldSeen[hpblob.FieldOwnerArtistID] = struct{}{}
			}
		case "ownerMember":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hb.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hb.withOwnerMember = query
			if _, ok := fieldSeen[hpblob.FieldOwnerMemberID]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldOwnerMemberID)
				fieldSeen[hpblob.FieldOwnerMemberID] = struct{}{}
			}
		case "amebloPosts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPAmebloPostClient{config: hb.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hb.WithNamedAmebloPosts(alias, func(wq *HPAmebloPostQuery) {
				*wq = *query
			})
		case "igPosts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPIgPostClient{config: hb.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hb.WithNamedIgPosts(alias, func(wq *HPIgPostQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[hpblob.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldCreatedAt)
				fieldSeen[hpblob.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpblob.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldUpdatedAt)
				fieldSeen[hpblob.FieldUpdatedAt] = struct{}{}
			}
		case "storagePath":
			if _, ok := fieldSeen[hpblob.FieldStoragePath]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldStoragePath)
				fieldSeen[hpblob.FieldStoragePath] = struct{}{}
			}
		case "sourceURL":
			if _, ok := fieldSeen[hpblob.FieldSourceURL]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldSourceURL)
				fieldSeen[hpblob.FieldSourceURL] = struct{}{}
			}
		case "sourceHTMLURL":
			if _, ok := fieldSeen[hpblob.FieldSourceHTMLURL]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldSourceHTMLURL)
				fieldSeen[hpblob.FieldSourceHTMLURL] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[hpblob.FieldStatus]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldStatus)
				fieldSeen[hpblob.FieldStatus] = struct{}{}
			}
		case "statusMessage":
			if _, ok := fieldSeen[hpblob.FieldStatusMessage]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldStatusMessage)
				fieldSeen[hpblob.FieldStatusMessage] = struct{}{}
			}
		case "statusErrorCount":
			if _, ok := fieldSeen[hpblob.FieldStatusErrorCount]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldStatusErrorCount)
				fieldSeen[hpblob.FieldStatusErrorCount] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[hpblob.FieldType]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldType)
				fieldSeen[hpblob.FieldType] = struct{}{}
			}
		case "subType":
			if _, ok := fieldSeen[hpblob.FieldSubType]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldSubType)
				fieldSeen[hpblob.FieldSubType] = struct{}{}
			}
		case "width":
			if _, ok := fieldSeen[hpblob.FieldWidth]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldWidth)
				fieldSeen[hpblob.FieldWidth] = struct{}{}
			}
		case "height":
			if _, ok := fieldSeen[hpblob.FieldHeight]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldHeight)
				fieldSeen[hpblob.FieldHeight] = struct{}{}
			}
		case "size":
			if _, ok := fieldSeen[hpblob.FieldSize]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldSize)
				fieldSeen[hpblob.FieldSize] = struct{}{}
			}
		case "ownerArtistID":
			if _, ok := fieldSeen[hpblob.FieldOwnerArtistID]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldOwnerArtistID)
				fieldSeen[hpblob.FieldOwnerArtistID] = struct{}{}
			}
		case "ownerMemberID":
			if _, ok := fieldSeen[hpblob.FieldOwnerMemberID]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldOwnerMemberID)
				fieldSeen[hpblob.FieldOwnerMemberID] = struct{}{}
			}
		case "numFaces":
			if _, ok := fieldSeen[hpblob.FieldNumFaces]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldNumFaces)
				fieldSeen[hpblob.FieldNumFaces] = struct{}{}
			}
		case "faceRecognitionStatus":
			if _, ok := fieldSeen[hpblob.FieldFaceRecognitionStatus]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldFaceRecognitionStatus)
				fieldSeen[hpblob.FieldFaceRecognitionStatus] = struct{}{}
			}
		case "thumbnail":
			if _, ok := fieldSeen[hpblob.FieldThumbnail]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldThumbnail)
				fieldSeen[hpblob.FieldThumbnail] = struct{}{}
			}
		case "durationSeconds":
			if _, ok := fieldSeen[hpblob.FieldDurationSeconds]; !ok {
				selectedFields = append(selectedFields, hpblob.FieldDurationSeconds)
				fieldSeen[hpblob.FieldDurationSeconds] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hb.Select(selectedFields...)
	}
	return nil
}

type hpblobPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPBlobPaginateOption
}

func newHPBlobPaginateArgs(rv map[string]interface{}) *hpblobPaginateArgs {
	args := &hpblobPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPBlobOrder{Field: &HPBlobOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPBlobOrder(order))
			}
		case *HPBlobOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPBlobOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hemi *HPElineupMallItemQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPElineupMallItemQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hemi, nil
	}
	if err := hemi.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hemi, nil
}

func (hemi *HPElineupMallItemQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpelineupmallitem.Columns))
		selectedFields = []string{hpelineupmallitem.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "taggedArtists":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hemi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hemi.WithNamedTaggedArtists(alias, func(wq *HPArtistQuery) {
				*wq = *query
			})
		case "taggedMembers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hemi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hemi.WithNamedTaggedMembers(alias, func(wq *HPMemberQuery) {
				*wq = *query
			})
		case "purchaseHistories":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPElineupMallItemPurchaseHistoryClient{config: hemi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hemi.WithNamedPurchaseHistories(alias, func(wq *HPElineupMallItemPurchaseHistoryQuery) {
				*wq = *query
			})
		case "crawledAt":
			if _, ok := fieldSeen[hpelineupmallitem.FieldCrawledAt]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldCrawledAt)
				fieldSeen[hpelineupmallitem.FieldCrawledAt] = struct{}{}
			}
		case "errorCount":
			if _, ok := fieldSeen[hpelineupmallitem.FieldErrorCount]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldErrorCount)
				fieldSeen[hpelineupmallitem.FieldErrorCount] = struct{}{}
			}
		case "lastErrorMessage":
			if _, ok := fieldSeen[hpelineupmallitem.FieldLastErrorMessage]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldLastErrorMessage)
				fieldSeen[hpelineupmallitem.FieldLastErrorMessage] = struct{}{}
			}
		case "recrawlRequired":
			if _, ok := fieldSeen[hpelineupmallitem.FieldRecrawlRequired]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldRecrawlRequired)
				fieldSeen[hpelineupmallitem.FieldRecrawlRequired] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hpelineupmallitem.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldCreatedAt)
				fieldSeen[hpelineupmallitem.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpelineupmallitem.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldUpdatedAt)
				fieldSeen[hpelineupmallitem.FieldUpdatedAt] = struct{}{}
			}
		case "permalink":
			if _, ok := fieldSeen[hpelineupmallitem.FieldPermalink]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldPermalink)
				fieldSeen[hpelineupmallitem.FieldPermalink] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hpelineupmallitem.FieldName]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldName)
				fieldSeen[hpelineupmallitem.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[hpelineupmallitem.FieldDescription]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldDescription)
				fieldSeen[hpelineupmallitem.FieldDescription] = struct{}{}
			}
		case "supplier":
			if _, ok := fieldSeen[hpelineupmallitem.FieldSupplier]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldSupplier)
				fieldSeen[hpelineupmallitem.FieldSupplier] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[hpelineupmallitem.FieldPrice]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldPrice)
				fieldSeen[hpelineupmallitem.FieldPrice] = struct{}{}
			}
		case "isLimitedToFc":
			if _, ok := fieldSeen[hpelineupmallitem.FieldIsLimitedToFc]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldIsLimitedToFc)
				fieldSeen[hpelineupmallitem.FieldIsLimitedToFc] = struct{}{}
			}
		case "isOutOfStock":
			if _, ok := fieldSeen[hpelineupmallitem.FieldIsOutOfStock]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldIsOutOfStock)
				fieldSeen[hpelineupmallitem.FieldIsOutOfStock] = struct{}{}
			}
		case "images":
			if _, ok := fieldSeen[hpelineupmallitem.FieldImages]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldImages)
				fieldSeen[hpelineupmallitem.FieldImages] = struct{}{}
			}
		case "category":
			if _, ok := fieldSeen[hpelineupmallitem.FieldCategory]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldCategory)
				fieldSeen[hpelineupmallitem.FieldCategory] = struct{}{}
			}
		case "orderStartAt":
			if _, ok := fieldSeen[hpelineupmallitem.FieldOrderStartAt]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldOrderStartAt)
				fieldSeen[hpelineupmallitem.FieldOrderStartAt] = struct{}{}
			}
		case "orderEndAt":
			if _, ok := fieldSeen[hpelineupmallitem.FieldOrderEndAt]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitem.FieldOrderEndAt)
				fieldSeen[hpelineupmallitem.FieldOrderEndAt] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hemi.Select(selectedFields...)
	}
	return nil
}

type hpelineupmallitemPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPElineupMallItemPaginateOption
}

func newHPElineupMallItemPaginateArgs(rv map[string]interface{}) *hpelineupmallitemPaginateArgs {
	args := &hpelineupmallitemPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPElineupMallItemOrder{Field: &HPElineupMallItemOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPElineupMallItemOrder(order))
			}
		case *HPElineupMallItemOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPElineupMallItemOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hemiph *HPElineupMallItemPurchaseHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPElineupMallItemPurchaseHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hemiph, nil
	}
	if err := hemiph.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hemiph, nil
}

func (hemiph *HPElineupMallItemPurchaseHistoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpelineupmallitempurchasehistory.Columns))
		selectedFields = []string{hpelineupmallitempurchasehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldCreatedAt)
				fieldSeen[hpelineupmallitempurchasehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldUpdatedAt)
				fieldSeen[hpelineupmallitempurchasehistory.FieldUpdatedAt] = struct{}{}
			}
		case "orderID":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldOrderID]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldOrderID)
				fieldSeen[hpelineupmallitempurchasehistory.FieldOrderID] = struct{}{}
			}
		case "num":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldNum]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldNum)
				fieldSeen[hpelineupmallitempurchasehistory.FieldNum] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldPrice]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldPrice)
				fieldSeen[hpelineupmallitempurchasehistory.FieldPrice] = struct{}{}
			}
		case "orderedAt":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldOrderedAt]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldOrderedAt)
				fieldSeen[hpelineupmallitempurchasehistory.FieldOrderedAt] = struct{}{}
			}
		case "permalink":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldPermalink]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldPermalink)
				fieldSeen[hpelineupmallitempurchasehistory.FieldPermalink] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldName)
				fieldSeen[hpelineupmallitempurchasehistory.FieldName] = struct{}{}
			}
		case "purchasedItemID":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldPurchasedItemID]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldPurchasedItemID)
				fieldSeen[hpelineupmallitempurchasehistory.FieldPurchasedItemID] = struct{}{}
			}
		case "ownerUserID":
			if _, ok := fieldSeen[hpelineupmallitempurchasehistory.FieldOwnerUserID]; !ok {
				selectedFields = append(selectedFields, hpelineupmallitempurchasehistory.FieldOwnerUserID)
				fieldSeen[hpelineupmallitempurchasehistory.FieldOwnerUserID] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hemiph.Select(selectedFields...)
	}
	return nil
}

type hpelineupmallitempurchasehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPElineupMallItemPurchaseHistoryPaginateOption
}

func newHPElineupMallItemPurchaseHistoryPaginateArgs(rv map[string]interface{}) *hpelineupmallitempurchasehistoryPaginateArgs {
	args := &hpelineupmallitempurchasehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPElineupMallItemPurchaseHistoryOrder{Field: &HPElineupMallItemPurchaseHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPElineupMallItemPurchaseHistoryOrder(order))
			}
		case *HPElineupMallItemPurchaseHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPElineupMallItemPurchaseHistoryOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (he *HPEventQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPEventQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return he, nil
	}
	if err := he.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return he, nil
}

func (he *HPEventQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpevent.Columns))
		selectedFields = []string{hpevent.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[hpevent.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldCreatedAt)
				fieldSeen[hpevent.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpevent.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldUpdatedAt)
				fieldSeen[hpevent.FieldUpdatedAt] = struct{}{}
			}
		case "key":
			if _, ok := fieldSeen[hpevent.FieldKey]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldKey)
				fieldSeen[hpevent.FieldKey] = struct{}{}
			}
		case "displayTitles":
			if _, ok := fieldSeen[hpevent.FieldDisplayTitles]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldDisplayTitles)
				fieldSeen[hpevent.FieldDisplayTitles] = struct{}{}
			}
		case "openAt":
			if _, ok := fieldSeen[hpevent.FieldOpenAt]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldOpenAt)
				fieldSeen[hpevent.FieldOpenAt] = struct{}{}
			}
		case "startAt":
			if _, ok := fieldSeen[hpevent.FieldStartAt]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldStartAt)
				fieldSeen[hpevent.FieldStartAt] = struct{}{}
			}
		case "venue":
			if _, ok := fieldSeen[hpevent.FieldVenue]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldVenue)
				fieldSeen[hpevent.FieldVenue] = struct{}{}
			}
		case "prefecture":
			if _, ok := fieldSeen[hpevent.FieldPrefecture]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldPrefecture)
				fieldSeen[hpevent.FieldPrefecture] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[hpevent.FieldSource]; !ok {
				selectedFields = append(selectedFields, hpevent.FieldSource)
				fieldSeen[hpevent.FieldSource] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		he.Select(selectedFields...)
	}
	return nil
}

type hpeventPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPEventPaginateOption
}

func newHPEventPaginateArgs(rv map[string]interface{}) *hpeventPaginateArgs {
	args := &hpeventPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPEventOrder{Field: &HPEventOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPEventOrder(order))
			}
		case *HPEventOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPEventOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (het *HPFCEventTicketQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPFCEventTicketQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return het, nil
	}
	if err := het.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return het, nil
}

func (het *HPFCEventTicketQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpfceventticket.Columns))
		selectedFields = []string{hpfceventticket.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[hpfceventticket.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldCreatedAt)
				fieldSeen[hpfceventticket.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpfceventticket.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldUpdatedAt)
				fieldSeen[hpfceventticket.FieldUpdatedAt] = struct{}{}
			}
		case "num":
			if _, ok := fieldSeen[hpfceventticket.FieldNum]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldNum)
				fieldSeen[hpfceventticket.FieldNum] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[hpfceventticket.FieldStatus]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldStatus)
				fieldSeen[hpfceventticket.FieldStatus] = struct{}{}
			}
		case "fcMemberSha256":
			if _, ok := fieldSeen[hpfceventticket.FieldFcMemberSha256]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldFcMemberSha256)
				fieldSeen[hpfceventticket.FieldFcMemberSha256] = struct{}{}
			}
		case "applicationTitle":
			if _, ok := fieldSeen[hpfceventticket.FieldApplicationTitle]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldApplicationTitle)
				fieldSeen[hpfceventticket.FieldApplicationTitle] = struct{}{}
			}
		case "applicationID":
			if _, ok := fieldSeen[hpfceventticket.FieldApplicationID]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldApplicationID)
				fieldSeen[hpfceventticket.FieldApplicationID] = struct{}{}
			}
		case "applicationSite":
			if _, ok := fieldSeen[hpfceventticket.FieldApplicationSite]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldApplicationSite)
				fieldSeen[hpfceventticket.FieldApplicationSite] = struct{}{}
			}
		case "applicationStartDate":
			if _, ok := fieldSeen[hpfceventticket.FieldApplicationStartDate]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldApplicationStartDate)
				fieldSeen[hpfceventticket.FieldApplicationStartDate] = struct{}{}
			}
		case "applicationDueDate":
			if _, ok := fieldSeen[hpfceventticket.FieldApplicationDueDate]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldApplicationDueDate)
				fieldSeen[hpfceventticket.FieldApplicationDueDate] = struct{}{}
			}
		case "paymentStartDate":
			if _, ok := fieldSeen[hpfceventticket.FieldPaymentStartDate]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldPaymentStartDate)
				fieldSeen[hpfceventticket.FieldPaymentStartDate] = struct{}{}
			}
		case "paymentDueDate":
			if _, ok := fieldSeen[hpfceventticket.FieldPaymentDueDate]; !ok {
				selectedFields = append(selectedFields, hpfceventticket.FieldPaymentDueDate)
				fieldSeen[hpfceventticket.FieldPaymentDueDate] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		het.Select(selectedFields...)
	}
	return nil
}

type hpfceventticketPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPFCEventTicketPaginateOption
}

func newHPFCEventTicketPaginateArgs(rv map[string]interface{}) *hpfceventticketPaginateArgs {
	args := &hpfceventticketPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPFCEventTicketOrder{Field: &HPFCEventTicketOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPFCEventTicketOrder(order))
			}
		case *HPFCEventTicketOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPFCEventTicketOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hfi *HPFeedItemQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPFeedItemQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hfi, nil
	}
	if err := hfi.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hfi, nil
}

func (hfi *HPFeedItemQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpfeeditem.Columns))
		selectedFields = []string{hpfeeditem.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "ownerArtist":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hfi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hfi.withOwnerArtist = query
			if _, ok := fieldSeen[hpfeeditem.FieldOwnerArtistID]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldOwnerArtistID)
				fieldSeen[hpfeeditem.FieldOwnerArtistID] = struct{}{}
			}
		case "ownerMember":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hfi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hfi.withOwnerMember = query
			if _, ok := fieldSeen[hpfeeditem.FieldOwnerMemberID]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldOwnerMemberID)
				fieldSeen[hpfeeditem.FieldOwnerMemberID] = struct{}{}
			}
		case "taggedArtists":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hfi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hfi.WithNamedTaggedArtists(alias, func(wq *HPArtistQuery) {
				*wq = *query
			})
		case "taggedMembers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hfi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hfi.WithNamedTaggedMembers(alias, func(wq *HPMemberQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[hpfeeditem.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldCreatedAt)
				fieldSeen[hpfeeditem.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpfeeditem.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldUpdatedAt)
				fieldSeen[hpfeeditem.FieldUpdatedAt] = struct{}{}
			}
		case "sourceID":
			if _, ok := fieldSeen[hpfeeditem.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldSourceID)
				fieldSeen[hpfeeditem.FieldSourceID] = struct{}{}
			}
		case "assetType":
			if _, ok := fieldSeen[hpfeeditem.FieldAssetType]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldAssetType)
				fieldSeen[hpfeeditem.FieldAssetType] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[hpfeeditem.FieldTitle]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldTitle)
				fieldSeen[hpfeeditem.FieldTitle] = struct{}{}
			}
		case "postAt":
			if _, ok := fieldSeen[hpfeeditem.FieldPostAt]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldPostAt)
				fieldSeen[hpfeeditem.FieldPostAt] = struct{}{}
			}
		case "sourceURL":
			if _, ok := fieldSeen[hpfeeditem.FieldSourceURL]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldSourceURL)
				fieldSeen[hpfeeditem.FieldSourceURL] = struct{}{}
			}
		case "imageURL":
			if _, ok := fieldSeen[hpfeeditem.FieldImageURL]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldImageURL)
				fieldSeen[hpfeeditem.FieldImageURL] = struct{}{}
			}
		case "media":
			if _, ok := fieldSeen[hpfeeditem.FieldMedia]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldMedia)
				fieldSeen[hpfeeditem.FieldMedia] = struct{}{}
			}
		case "ownerArtistID":
			if _, ok := fieldSeen[hpfeeditem.FieldOwnerArtistID]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldOwnerArtistID)
				fieldSeen[hpfeeditem.FieldOwnerArtistID] = struct{}{}
			}
		case "ownerMemberID":
			if _, ok := fieldSeen[hpfeeditem.FieldOwnerMemberID]; !ok {
				selectedFields = append(selectedFields, hpfeeditem.FieldOwnerMemberID)
				fieldSeen[hpfeeditem.FieldOwnerMemberID] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hfi.Select(selectedFields...)
	}
	return nil
}

type hpfeeditemPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPFeedItemPaginateOption
}

func newHPFeedItemPaginateArgs(rv map[string]interface{}) *hpfeeditemPaginateArgs {
	args := &hpfeeditemPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPFeedItemOrder{Field: &HPFeedItemOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPFeedItemOrder(order))
			}
		case *HPFeedItemOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPFeedItemOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hf *HPFollowQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPFollowQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hf, nil
	}
	if err := hf.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hf, nil
}

func (hf *HPFollowQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpfollow.Columns))
		selectedFields = []string{hpfollow.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: hf.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hf.withUser = query
		case "member":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hf.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hf.withMember = query
		case "createdAt":
			if _, ok := fieldSeen[hpfollow.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldCreatedAt)
				fieldSeen[hpfollow.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpfollow.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldUpdatedAt)
				fieldSeen[hpfollow.FieldUpdatedAt] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[hpfollow.FieldType]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldType)
				fieldSeen[hpfollow.FieldType] = struct{}{}
			}
		case "elineupmallOther":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallOther]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallOther)
				fieldSeen[hpfollow.FieldElineupmallOther] = struct{}{}
			}
		case "elineupmallPhotoDaily":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhotoDaily]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhotoDaily)
				fieldSeen[hpfollow.FieldElineupmallPhotoDaily] = struct{}{}
			}
		case "elineupmallPhotoA4":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhotoA4]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhotoA4)
				fieldSeen[hpfollow.FieldElineupmallPhotoA4] = struct{}{}
			}
		case "elineupmallPhotoA5":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhotoA5]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhotoA5)
				fieldSeen[hpfollow.FieldElineupmallPhotoA5] = struct{}{}
			}
		case "elineupmallPhoto2l":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhoto2l]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhoto2l)
				fieldSeen[hpfollow.FieldElineupmallPhoto2l] = struct{}{}
			}
		case "elineupmallPhotoOther":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhotoOther]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhotoOther)
				fieldSeen[hpfollow.FieldElineupmallPhotoOther] = struct{}{}
			}
		case "elineupmallPhotoAlbum":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhotoAlbum]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhotoAlbum)
				fieldSeen[hpfollow.FieldElineupmallPhotoAlbum] = struct{}{}
			}
		case "elineupmallPhotoAlbumOther":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhotoAlbumOther]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhotoAlbumOther)
				fieldSeen[hpfollow.FieldElineupmallPhotoAlbumOther] = struct{}{}
			}
		case "elineupmallPhotoBook":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhotoBook]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhotoBook)
				fieldSeen[hpfollow.FieldElineupmallPhotoBook] = struct{}{}
			}
		case "elineupmallPhotoBookOther":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPhotoBookOther]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPhotoBookOther)
				fieldSeen[hpfollow.FieldElineupmallPhotoBookOther] = struct{}{}
			}
		case "elineupmallDvd":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallDvd]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallDvd)
				fieldSeen[hpfollow.FieldElineupmallDvd] = struct{}{}
			}
		case "elineupmallDvdMagazine":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallDvdMagazine]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallDvdMagazine)
				fieldSeen[hpfollow.FieldElineupmallDvdMagazine] = struct{}{}
			}
		case "elineupmallDvdMagazineOther":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallDvdMagazineOther]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallDvdMagazineOther)
				fieldSeen[hpfollow.FieldElineupmallDvdMagazineOther] = struct{}{}
			}
		case "elineupmallBlueray":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallBlueray]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallBlueray)
				fieldSeen[hpfollow.FieldElineupmallBlueray] = struct{}{}
			}
		case "elineupmallPenlight":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallPenlight]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallPenlight)
				fieldSeen[hpfollow.FieldElineupmallPenlight] = struct{}{}
			}
		case "elineupmallCollectionPinnapPoster":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallCollectionPinnapPoster]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallCollectionPinnapPoster)
				fieldSeen[hpfollow.FieldElineupmallCollectionPinnapPoster] = struct{}{}
			}
		case "elineupmallCollectionPhoto":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallCollectionPhoto]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallCollectionPhoto)
				fieldSeen[hpfollow.FieldElineupmallCollectionPhoto] = struct{}{}
			}
		case "elineupmallCollectionOther":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallCollectionOther]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallCollectionOther)
				fieldSeen[hpfollow.FieldElineupmallCollectionOther] = struct{}{}
			}
		case "elineupmallTshirt":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallTshirt]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallTshirt)
				fieldSeen[hpfollow.FieldElineupmallTshirt] = struct{}{}
			}
		case "elineupmallMicrofiberTowel":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallMicrofiberTowel]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallMicrofiberTowel)
				fieldSeen[hpfollow.FieldElineupmallMicrofiberTowel] = struct{}{}
			}
		case "elineupmallMufflerTowel":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallMufflerTowel]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallMufflerTowel)
				fieldSeen[hpfollow.FieldElineupmallMufflerTowel] = struct{}{}
			}
		case "elineupmallFsk":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallFsk]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallFsk)
				fieldSeen[hpfollow.FieldElineupmallFsk] = struct{}{}
			}
		case "elineupmallKeyringOther":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallKeyringOther]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallKeyringOther)
				fieldSeen[hpfollow.FieldElineupmallKeyringOther] = struct{}{}
			}
		case "elineupmallClearFile":
			if _, ok := fieldSeen[hpfollow.FieldElineupmallClearFile]; !ok {
				selectedFields = append(selectedFields, hpfollow.FieldElineupmallClearFile)
				fieldSeen[hpfollow.FieldElineupmallClearFile] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hf.Select(selectedFields...)
	}
	return nil
}

type hpfollowPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPFollowPaginateOption
}

func newHPFollowPaginateArgs(rv map[string]interface{}) *hpfollowPaginateArgs {
	args := &hpfollowPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPFollowOrder{Field: &HPFollowOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPFollowOrder(order))
			}
		case *HPFollowOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPFollowOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hip *HPIgPostQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPIgPostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hip, nil
	}
	if err := hip.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hip, nil
}

func (hip *HPIgPostQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpigpost.Columns))
		selectedFields = []string{hpigpost.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "ownerArtist":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hip.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hip.withOwnerArtist = query
			if _, ok := fieldSeen[hpigpost.FieldOwnerArtistID]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldOwnerArtistID)
				fieldSeen[hpigpost.FieldOwnerArtistID] = struct{}{}
			}
		case "ownerMember":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hip.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hip.withOwnerMember = query
			if _, ok := fieldSeen[hpigpost.FieldOwnerMemberID]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldOwnerMemberID)
				fieldSeen[hpigpost.FieldOwnerMemberID] = struct{}{}
			}
		case "taggedArtists":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hip.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hip.WithNamedTaggedArtists(alias, func(wq *HPArtistQuery) {
				*wq = *query
			})
		case "taggedMembers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPMemberClient{config: hip.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hip.WithNamedTaggedMembers(alias, func(wq *HPMemberQuery) {
				*wq = *query
			})
		case "blobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPBlobClient{config: hip.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hip.WithNamedBlobs(alias, func(wq *HPBlobQuery) {
				*wq = *query
			})
		case "crawledAt":
			if _, ok := fieldSeen[hpigpost.FieldCrawledAt]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldCrawledAt)
				fieldSeen[hpigpost.FieldCrawledAt] = struct{}{}
			}
		case "errorCount":
			if _, ok := fieldSeen[hpigpost.FieldErrorCount]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldErrorCount)
				fieldSeen[hpigpost.FieldErrorCount] = struct{}{}
			}
		case "lastErrorMessage":
			if _, ok := fieldSeen[hpigpost.FieldLastErrorMessage]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldLastErrorMessage)
				fieldSeen[hpigpost.FieldLastErrorMessage] = struct{}{}
			}
		case "recrawlRequired":
			if _, ok := fieldSeen[hpigpost.FieldRecrawlRequired]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldRecrawlRequired)
				fieldSeen[hpigpost.FieldRecrawlRequired] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hpigpost.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldCreatedAt)
				fieldSeen[hpigpost.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpigpost.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldUpdatedAt)
				fieldSeen[hpigpost.FieldUpdatedAt] = struct{}{}
			}
		case "shortcode":
			if _, ok := fieldSeen[hpigpost.FieldShortcode]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldShortcode)
				fieldSeen[hpigpost.FieldShortcode] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[hpigpost.FieldDescription]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldDescription)
				fieldSeen[hpigpost.FieldDescription] = struct{}{}
			}
		case "postAt":
			if _, ok := fieldSeen[hpigpost.FieldPostAt]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldPostAt)
				fieldSeen[hpigpost.FieldPostAt] = struct{}{}
			}
		case "media":
			if _, ok := fieldSeen[hpigpost.FieldMedia]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldMedia)
				fieldSeen[hpigpost.FieldMedia] = struct{}{}
			}
		case "likes":
			if _, ok := fieldSeen[hpigpost.FieldLikes]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldLikes)
				fieldSeen[hpigpost.FieldLikes] = struct{}{}
			}
		case "comments":
			if _, ok := fieldSeen[hpigpost.FieldComments]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldComments)
				fieldSeen[hpigpost.FieldComments] = struct{}{}
			}
		case "recrawlArgs":
			if _, ok := fieldSeen[hpigpost.FieldRecrawlArgs]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldRecrawlArgs)
				fieldSeen[hpigpost.FieldRecrawlArgs] = struct{}{}
			}
		case "ownerArtistID":
			if _, ok := fieldSeen[hpigpost.FieldOwnerArtistID]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldOwnerArtistID)
				fieldSeen[hpigpost.FieldOwnerArtistID] = struct{}{}
			}
		case "ownerMemberID":
			if _, ok := fieldSeen[hpigpost.FieldOwnerMemberID]; !ok {
				selectedFields = append(selectedFields, hpigpost.FieldOwnerMemberID)
				fieldSeen[hpigpost.FieldOwnerMemberID] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hip.Select(selectedFields...)
	}
	return nil
}

type hpigpostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPIgPostPaginateOption
}

func newHPIgPostPaginateArgs(rv map[string]interface{}) *hpigpostPaginateArgs {
	args := &hpigpostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPIgPostOrder{Field: &HPIgPostOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPIgPostOrder(order))
			}
		case *HPIgPostOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPIgPostOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hm *HPMemberQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPMemberQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hm, nil
	}
	if err := hm.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hm, nil
}

func (hm *HPMemberQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpmember.Columns))
		selectedFields = []string{hpmember.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artist":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPArtistClient{config: hm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hm.withArtist = query
			if _, ok := fieldSeen[hpmember.FieldArtistID]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldArtistID)
				fieldSeen[hpmember.FieldArtistID] = struct{}{}
			}
		case "crawledAt":
			if _, ok := fieldSeen[hpmember.FieldCrawledAt]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldCrawledAt)
				fieldSeen[hpmember.FieldCrawledAt] = struct{}{}
			}
		case "errorCount":
			if _, ok := fieldSeen[hpmember.FieldErrorCount]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldErrorCount)
				fieldSeen[hpmember.FieldErrorCount] = struct{}{}
			}
		case "lastErrorMessage":
			if _, ok := fieldSeen[hpmember.FieldLastErrorMessage]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldLastErrorMessage)
				fieldSeen[hpmember.FieldLastErrorMessage] = struct{}{}
			}
		case "recrawlRequired":
			if _, ok := fieldSeen[hpmember.FieldRecrawlRequired]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldRecrawlRequired)
				fieldSeen[hpmember.FieldRecrawlRequired] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hpmember.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldCreatedAt)
				fieldSeen[hpmember.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpmember.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldUpdatedAt)
				fieldSeen[hpmember.FieldUpdatedAt] = struct{}{}
			}
		case "key":
			if _, ok := fieldSeen[hpmember.FieldKey]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldKey)
				fieldSeen[hpmember.FieldKey] = struct{}{}
			}
		case "artistKey":
			if _, ok := fieldSeen[hpmember.FieldArtistKey]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldArtistKey)
				fieldSeen[hpmember.FieldArtistKey] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hpmember.FieldName]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldName)
				fieldSeen[hpmember.FieldName] = struct{}{}
			}
		case "nameKana":
			if _, ok := fieldSeen[hpmember.FieldNameKana]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldNameKana)
				fieldSeen[hpmember.FieldNameKana] = struct{}{}
			}
		case "thumbnailURL":
			if _, ok := fieldSeen[hpmember.FieldThumbnailURL]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldThumbnailURL)
				fieldSeen[hpmember.FieldThumbnailURL] = struct{}{}
			}
		case "dateOfBirth":
			if _, ok := fieldSeen[hpmember.FieldDateOfBirth]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldDateOfBirth)
				fieldSeen[hpmember.FieldDateOfBirth] = struct{}{}
			}
		case "bloodType":
			if _, ok := fieldSeen[hpmember.FieldBloodType]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldBloodType)
				fieldSeen[hpmember.FieldBloodType] = struct{}{}
			}
		case "hometown":
			if _, ok := fieldSeen[hpmember.FieldHometown]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldHometown)
				fieldSeen[hpmember.FieldHometown] = struct{}{}
			}
		case "joinAt":
			if _, ok := fieldSeen[hpmember.FieldJoinAt]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldJoinAt)
				fieldSeen[hpmember.FieldJoinAt] = struct{}{}
			}
		case "graduateAt":
			if _, ok := fieldSeen[hpmember.FieldGraduateAt]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldGraduateAt)
				fieldSeen[hpmember.FieldGraduateAt] = struct{}{}
			}
		case "artistID":
			if _, ok := fieldSeen[hpmember.FieldArtistID]; !ok {
				selectedFields = append(selectedFields, hpmember.FieldArtistID)
				fieldSeen[hpmember.FieldArtistID] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hm.Select(selectedFields...)
	}
	return nil
}

type hpmemberPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPMemberPaginateOption
}

func newHPMemberPaginateArgs(rv map[string]interface{}) *hpmemberPaginateArgs {
	args := &hpmemberPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPMemberOrder{Field: &HPMemberOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPMemberOrder(order))
			}
		case *HPMemberOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPMemberOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hsh *HPSortHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPSortHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hsh, nil
	}
	if err := hsh.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hsh, nil
}

func (hsh *HPSortHistoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpsorthistory.Columns))
		selectedFields = []string{hpsorthistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: hsh.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hsh.withOwner = query
			if _, ok := fieldSeen[hpsorthistory.FieldOwnerUserID]; !ok {
				selectedFields = append(selectedFields, hpsorthistory.FieldOwnerUserID)
				fieldSeen[hpsorthistory.FieldOwnerUserID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hpsorthistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpsorthistory.FieldCreatedAt)
				fieldSeen[hpsorthistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpsorthistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpsorthistory.FieldUpdatedAt)
				fieldSeen[hpsorthistory.FieldUpdatedAt] = struct{}{}
			}
		case "sortResult":
			if _, ok := fieldSeen[hpsorthistory.FieldSortResult]; !ok {
				selectedFields = append(selectedFields, hpsorthistory.FieldSortResult)
				fieldSeen[hpsorthistory.FieldSortResult] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hsh.Select(selectedFields...)
	}
	return nil
}

type hpsorthistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPSortHistoryPaginateOption
}

func newHPSortHistoryPaginateArgs(rv map[string]interface{}) *hpsorthistoryPaginateArgs {
	args := &hpsorthistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPSortHistoryOrder{Field: &HPSortHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPSortHistoryOrder(order))
			}
		case *HPSortHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPSortHistoryOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hvh *HPViewHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*HPViewHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hvh, nil
	}
	if err := hvh.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hvh, nil
}

func (hvh *HPViewHistoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hpviewhistory.Columns))
		selectedFields = []string{hpviewhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "feed":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPFeedItemClient{config: hvh.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hvh.withFeed = query
		case "createdAt":
			if _, ok := fieldSeen[hpviewhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hpviewhistory.FieldCreatedAt)
				fieldSeen[hpviewhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hpviewhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hpviewhistory.FieldUpdatedAt)
				fieldSeen[hpviewhistory.FieldUpdatedAt] = struct{}{}
			}
		case "contentID":
			if _, ok := fieldSeen[hpviewhistory.FieldContentID]; !ok {
				selectedFields = append(selectedFields, hpviewhistory.FieldContentID)
				fieldSeen[hpviewhistory.FieldContentID] = struct{}{}
			}
		case "contentPostAt":
			if _, ok := fieldSeen[hpviewhistory.FieldContentPostAt]; !ok {
				selectedFields = append(selectedFields, hpviewhistory.FieldContentPostAt)
				fieldSeen[hpviewhistory.FieldContentPostAt] = struct{}{}
			}
		case "assetType":
			if _, ok := fieldSeen[hpviewhistory.FieldAssetType]; !ok {
				selectedFields = append(selectedFields, hpviewhistory.FieldAssetType)
				fieldSeen[hpviewhistory.FieldAssetType] = struct{}{}
			}
		case "isFavorite":
			if _, ok := fieldSeen[hpviewhistory.FieldIsFavorite]; !ok {
				selectedFields = append(selectedFields, hpviewhistory.FieldIsFavorite)
				fieldSeen[hpviewhistory.FieldIsFavorite] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hvh.Select(selectedFields...)
	}
	return nil
}

type hpviewhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HPViewHistoryPaginateOption
}

func newHPViewHistoryPaginateArgs(rv map[string]interface{}) *hpviewhistoryPaginateArgs {
	args := &hpviewhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HPViewHistoryOrder{Field: &HPViewHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHPViewHistoryOrder(order))
			}
		case *HPViewHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithHPViewHistoryOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "auth":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AuthClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedAuth(alias, func(wq *AuthQuery) {
				*wq = *query
			})
		case "notificationSettings":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserNotificationSettingClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedNotificationSettings(alias, func(wq *UserNotificationSettingQuery) {
				*wq = *query
			})
		case "hpviewHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPViewHistoryClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedHpviewHistory(alias, func(wq *HPViewHistoryQuery) {
				*wq = *query
			})
		case "hpmemberFollowing":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPFollowClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedHpmemberFollowing(alias, func(wq *HPFollowQuery) {
				*wq = *query
			})
		case "hpsortHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPSortHistoryClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedHpsortHistory(alias, func(wq *HPSortHistoryQuery) {
				*wq = *query
			})
		case "hpfcEventTickets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPFCEventTicketClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedHpfcEventTickets(alias, func(wq *HPFCEventTicketQuery) {
				*wq = *query
			})
		case "elineupMallPurchaseHistories":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HPElineupMallItemPurchaseHistoryClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedElineupMallPurchaseHistories(alias, func(wq *HPElineupMallItemPurchaseHistoryQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "username":
			if _, ok := fieldSeen[user.FieldUsername]; !ok {
				selectedFields = append(selectedFields, user.FieldUsername)
				fieldSeen[user.FieldUsername] = struct{}{}
			}
		case "accessToken":
			if _, ok := fieldSeen[user.FieldAccessToken]; !ok {
				selectedFields = append(selectedFields, user.FieldAccessToken)
				fieldSeen[user.FieldAccessToken] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]interface{}) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &UserOrder{Field: &UserOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserOrder(order))
			}
		case *UserOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (uns *UserNotificationSettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserNotificationSettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return uns, nil
	}
	if err := uns.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return uns, nil
}

func (uns *UserNotificationSettingQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(usernotificationsetting.Columns))
		selectedFields = []string{usernotificationsetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: uns.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			uns.withUser = query
			if _, ok := fieldSeen[usernotificationsetting.FieldOwnerUserID]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldOwnerUserID)
				fieldSeen[usernotificationsetting.FieldOwnerUserID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[usernotificationsetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldCreatedAt)
				fieldSeen[usernotificationsetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[usernotificationsetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldUpdatedAt)
				fieldSeen[usernotificationsetting.FieldUpdatedAt] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[usernotificationsetting.FieldToken]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldToken)
				fieldSeen[usernotificationsetting.FieldToken] = struct{}{}
			}
		case "slug":
			if _, ok := fieldSeen[usernotificationsetting.FieldSlug]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldSlug)
				fieldSeen[usernotificationsetting.FieldSlug] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[usernotificationsetting.FieldName]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldName)
				fieldSeen[usernotificationsetting.FieldName] = struct{}{}
			}
		case "enableNewPosts":
			if _, ok := fieldSeen[usernotificationsetting.FieldEnableNewPosts]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldEnableNewPosts)
				fieldSeen[usernotificationsetting.FieldEnableNewPosts] = struct{}{}
			}
		case "enablePaymentStart":
			if _, ok := fieldSeen[usernotificationsetting.FieldEnablePaymentStart]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldEnablePaymentStart)
				fieldSeen[usernotificationsetting.FieldEnablePaymentStart] = struct{}{}
			}
		case "enablePaymentDue":
			if _, ok := fieldSeen[usernotificationsetting.FieldEnablePaymentDue]; !ok {
				selectedFields = append(selectedFields, usernotificationsetting.FieldEnablePaymentDue)
				fieldSeen[usernotificationsetting.FieldEnablePaymentDue] = struct{}{}
			}
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		uns.Select(selectedFields...)
	}
	return nil
}

type usernotificationsettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserNotificationSettingPaginateOption
}

func newUserNotificationSettingPaginateArgs(rv map[string]interface{}) *usernotificationsettingPaginateArgs {
	args := &usernotificationsettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &UserNotificationSettingOrder{Field: &UserNotificationSettingOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserNotificationSettingOrder(order))
			}
		case *UserNotificationSettingOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserNotificationSettingOrder(v))
			}
		}
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput interface{}, path ...string) map[string]interface{} {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	for _, name := range path {
		var field *graphql.CollectedField
		for _, f := range graphql.CollectFields(oc, fc.Field.Selections, nil) {
			if f.Alias == name {
				field = &f
				break
			}
		}
		if field == nil {
			return nil
		}
		cf, err := fc.Child(ctx, *field)
		if err != nil {
			args := field.ArgumentMap(oc.Variables)
			return unmarshalArgs(ctx, whereInput, args)
		}
		fc = cf
	}
	return fc.Args
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput interface{}, args map[string]interface{}) map[string]interface{} {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}
