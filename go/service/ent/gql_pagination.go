// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/yssk22/hpapp/go/service/ent/auth"
	"github.com/yssk22/hpapp/go/service/ent/hpameblopost"
	"github.com/yssk22/hpapp/go/service/ent/hpartist"
	"github.com/yssk22/hpapp/go/service/ent/hpblob"
	"github.com/yssk22/hpapp/go/service/ent/hpelineupmallitem"
	"github.com/yssk22/hpapp/go/service/ent/hpelineupmallitempurchasehistory"
	"github.com/yssk22/hpapp/go/service/ent/hpevent"
	"github.com/yssk22/hpapp/go/service/ent/hpfceventticket"
	"github.com/yssk22/hpapp/go/service/ent/hpfeeditem"
	"github.com/yssk22/hpapp/go/service/ent/hpfollow"
	"github.com/yssk22/hpapp/go/service/ent/hpigpost"
	"github.com/yssk22/hpapp/go/service/ent/hpmember"
	"github.com/yssk22/hpapp/go/service/ent/hpsorthistory"
	"github.com/yssk22/hpapp/go/service/ent/hpviewhistory"
	"github.com/yssk22/hpapp/go/service/ent/user"
	"github.com/yssk22/hpapp/go/service/ent/usernotificationsetting"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AuthEdge is the edge representation of Auth.
type AuthEdge struct {
	Node   *Auth  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AuthConnection is the connection containing edges to Auth.
type AuthConnection struct {
	Edges      []*AuthEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *AuthConnection) build(nodes []*Auth, pager *authPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Auth
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Auth {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Auth {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuthEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuthEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuthPaginateOption enables pagination customization.
type AuthPaginateOption func(*authPager) error

// WithAuthOrder configures pagination ordering.
func WithAuthOrder(order *AuthOrder) AuthPaginateOption {
	if order == nil {
		order = DefaultAuthOrder
	}
	o := *order
	return func(pager *authPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuthOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuthFilter configures pagination filter.
func WithAuthFilter(filter func(*AuthQuery) (*AuthQuery, error)) AuthPaginateOption {
	return func(pager *authPager) error {
		if filter == nil {
			return errors.New("AuthQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type authPager struct {
	reverse bool
	order   *AuthOrder
	filter  func(*AuthQuery) (*AuthQuery, error)
}

func newAuthPager(opts []AuthPaginateOption, reverse bool) (*authPager, error) {
	pager := &authPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuthOrder
	}
	return pager, nil
}

func (p *authPager) applyFilter(query *AuthQuery) (*AuthQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *authPager) toCursor(a *Auth) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *authPager) applyCursors(query *AuthQuery, after, before *Cursor) (*AuthQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAuthOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *authPager) applyOrder(query *AuthQuery) *AuthQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultAuthOrder.Field {
		query = query.Order(orderFunc(direction, DefaultAuthOrder.Field.field))
	}
	return query
}

func (p *authPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAuthOrder.Field {
			b.Comma().Ident(DefaultAuthOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Auth.
func (a *AuthQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuthPaginateOption,
) (*AuthConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuthPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AuthConnection{Edges: []*AuthEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	a = pager.applyOrder(a)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuthOrderFieldCreatedAt orders Auth by created_at.
	AuthOrderFieldCreatedAt = &AuthOrderField{
		field: auth.FieldCreatedAt,
		toCursor: func(a *Auth) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// AuthOrderFieldUpdatedAt orders Auth by updated_at.
	AuthOrderFieldUpdatedAt = &AuthOrderField{
		field: auth.FieldUpdatedAt,
		toCursor: func(a *Auth) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuthOrderField) String() string {
	var str string
	switch f.field {
	case auth.FieldCreatedAt:
		str = "createdAt"
	case auth.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuthOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuthOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuthOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *AuthOrderFieldCreatedAt
	case "updatedAt":
		*f = *AuthOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid AuthOrderField", str)
	}
	return nil
}

// AuthOrderField defines the ordering field of Auth.
type AuthOrderField struct {
	field    string
	toCursor func(*Auth) Cursor
}

// AuthOrder defines the ordering of Auth.
type AuthOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *AuthOrderField `json:"field"`
}

// DefaultAuthOrder is the default ordering of Auth.
var DefaultAuthOrder = &AuthOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AuthOrderField{
		field: auth.FieldID,
		toCursor: func(a *Auth) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Auth into AuthEdge.
func (a *Auth) ToEdge(order *AuthOrder) *AuthEdge {
	if order == nil {
		order = DefaultAuthOrder
	}
	return &AuthEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// HPAmebloPostEdge is the edge representation of HPAmebloPost.
type HPAmebloPostEdge struct {
	Node   *HPAmebloPost `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// HPAmebloPostConnection is the connection containing edges to HPAmebloPost.
type HPAmebloPostConnection struct {
	Edges      []*HPAmebloPostEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *HPAmebloPostConnection) build(nodes []*HPAmebloPost, pager *hpameblopostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPAmebloPost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPAmebloPost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPAmebloPost {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPAmebloPostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPAmebloPostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPAmebloPostPaginateOption enables pagination customization.
type HPAmebloPostPaginateOption func(*hpameblopostPager) error

// WithHPAmebloPostOrder configures pagination ordering.
func WithHPAmebloPostOrder(order *HPAmebloPostOrder) HPAmebloPostPaginateOption {
	if order == nil {
		order = DefaultHPAmebloPostOrder
	}
	o := *order
	return func(pager *hpameblopostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPAmebloPostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPAmebloPostFilter configures pagination filter.
func WithHPAmebloPostFilter(filter func(*HPAmebloPostQuery) (*HPAmebloPostQuery, error)) HPAmebloPostPaginateOption {
	return func(pager *hpameblopostPager) error {
		if filter == nil {
			return errors.New("HPAmebloPostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpameblopostPager struct {
	reverse bool
	order   *HPAmebloPostOrder
	filter  func(*HPAmebloPostQuery) (*HPAmebloPostQuery, error)
}

func newHPAmebloPostPager(opts []HPAmebloPostPaginateOption, reverse bool) (*hpameblopostPager, error) {
	pager := &hpameblopostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPAmebloPostOrder
	}
	return pager, nil
}

func (p *hpameblopostPager) applyFilter(query *HPAmebloPostQuery) (*HPAmebloPostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpameblopostPager) toCursor(hap *HPAmebloPost) Cursor {
	return p.order.Field.toCursor(hap)
}

func (p *hpameblopostPager) applyCursors(query *HPAmebloPostQuery, after, before *Cursor) (*HPAmebloPostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPAmebloPostOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpameblopostPager) applyOrder(query *HPAmebloPostQuery) *HPAmebloPostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPAmebloPostOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPAmebloPostOrder.Field.field))
	}
	return query
}

func (p *hpameblopostPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPAmebloPostOrder.Field {
			b.Comma().Ident(DefaultHPAmebloPostOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPAmebloPost.
func (hap *HPAmebloPostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPAmebloPostPaginateOption,
) (*HPAmebloPostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPAmebloPostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hap, err = pager.applyFilter(hap); err != nil {
		return nil, err
	}
	conn := &HPAmebloPostConnection{Edges: []*HPAmebloPostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hap.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hap, err = pager.applyCursors(hap, after, before); err != nil {
		return nil, err
	}
	hap = pager.applyOrder(hap)
	if limit := paginateLimit(first, last); limit != 0 {
		hap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hap.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPAmebloPostOrderFieldCreatedAt orders HPAmebloPost by created_at.
	HPAmebloPostOrderFieldCreatedAt = &HPAmebloPostOrderField{
		field: hpameblopost.FieldCreatedAt,
		toCursor: func(hap *HPAmebloPost) Cursor {
			return Cursor{
				ID:    hap.ID,
				Value: hap.CreatedAt,
			}
		},
	}
	// HPAmebloPostOrderFieldUpdatedAt orders HPAmebloPost by updated_at.
	HPAmebloPostOrderFieldUpdatedAt = &HPAmebloPostOrderField{
		field: hpameblopost.FieldUpdatedAt,
		toCursor: func(hap *HPAmebloPost) Cursor {
			return Cursor{
				ID:    hap.ID,
				Value: hap.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPAmebloPostOrderField) String() string {
	var str string
	switch f.field {
	case hpameblopost.FieldCreatedAt:
		str = "createdAt"
	case hpameblopost.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPAmebloPostOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPAmebloPostOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPAmebloPostOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPAmebloPostOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPAmebloPostOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPAmebloPostOrderField", str)
	}
	return nil
}

// HPAmebloPostOrderField defines the ordering field of HPAmebloPost.
type HPAmebloPostOrderField struct {
	field    string
	toCursor func(*HPAmebloPost) Cursor
}

// HPAmebloPostOrder defines the ordering of HPAmebloPost.
type HPAmebloPostOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *HPAmebloPostOrderField `json:"field"`
}

// DefaultHPAmebloPostOrder is the default ordering of HPAmebloPost.
var DefaultHPAmebloPostOrder = &HPAmebloPostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPAmebloPostOrderField{
		field: hpameblopost.FieldID,
		toCursor: func(hap *HPAmebloPost) Cursor {
			return Cursor{ID: hap.ID}
		},
	},
}

// ToEdge converts HPAmebloPost into HPAmebloPostEdge.
func (hap *HPAmebloPost) ToEdge(order *HPAmebloPostOrder) *HPAmebloPostEdge {
	if order == nil {
		order = DefaultHPAmebloPostOrder
	}
	return &HPAmebloPostEdge{
		Node:   hap,
		Cursor: order.Field.toCursor(hap),
	}
}

// HPArtistEdge is the edge representation of HPArtist.
type HPArtistEdge struct {
	Node   *HPArtist `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// HPArtistConnection is the connection containing edges to HPArtist.
type HPArtistConnection struct {
	Edges      []*HPArtistEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *HPArtistConnection) build(nodes []*HPArtist, pager *hpartistPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPArtist
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPArtist {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPArtist {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPArtistEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPArtistEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPArtistPaginateOption enables pagination customization.
type HPArtistPaginateOption func(*hpartistPager) error

// WithHPArtistOrder configures pagination ordering.
func WithHPArtistOrder(order *HPArtistOrder) HPArtistPaginateOption {
	if order == nil {
		order = DefaultHPArtistOrder
	}
	o := *order
	return func(pager *hpartistPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPArtistOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPArtistFilter configures pagination filter.
func WithHPArtistFilter(filter func(*HPArtistQuery) (*HPArtistQuery, error)) HPArtistPaginateOption {
	return func(pager *hpartistPager) error {
		if filter == nil {
			return errors.New("HPArtistQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpartistPager struct {
	reverse bool
	order   *HPArtistOrder
	filter  func(*HPArtistQuery) (*HPArtistQuery, error)
}

func newHPArtistPager(opts []HPArtistPaginateOption, reverse bool) (*hpartistPager, error) {
	pager := &hpartistPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPArtistOrder
	}
	return pager, nil
}

func (p *hpartistPager) applyFilter(query *HPArtistQuery) (*HPArtistQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpartistPager) toCursor(ha *HPArtist) Cursor {
	return p.order.Field.toCursor(ha)
}

func (p *hpartistPager) applyCursors(query *HPArtistQuery, after, before *Cursor) (*HPArtistQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPArtistOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpartistPager) applyOrder(query *HPArtistQuery) *HPArtistQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPArtistOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPArtistOrder.Field.field))
	}
	return query
}

func (p *hpartistPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPArtistOrder.Field {
			b.Comma().Ident(DefaultHPArtistOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPArtist.
func (ha *HPArtistQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPArtistPaginateOption,
) (*HPArtistConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPArtistPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ha, err = pager.applyFilter(ha); err != nil {
		return nil, err
	}
	conn := &HPArtistConnection{Edges: []*HPArtistEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ha.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if ha, err = pager.applyCursors(ha, after, before); err != nil {
		return nil, err
	}
	ha = pager.applyOrder(ha)
	if limit := paginateLimit(first, last); limit != 0 {
		ha.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ha.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ha.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPArtistOrderFieldCreatedAt orders HPArtist by created_at.
	HPArtistOrderFieldCreatedAt = &HPArtistOrderField{
		field: hpartist.FieldCreatedAt,
		toCursor: func(ha *HPArtist) Cursor {
			return Cursor{
				ID:    ha.ID,
				Value: ha.CreatedAt,
			}
		},
	}
	// HPArtistOrderFieldUpdatedAt orders HPArtist by updated_at.
	HPArtistOrderFieldUpdatedAt = &HPArtistOrderField{
		field: hpartist.FieldUpdatedAt,
		toCursor: func(ha *HPArtist) Cursor {
			return Cursor{
				ID:    ha.ID,
				Value: ha.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPArtistOrderField) String() string {
	var str string
	switch f.field {
	case hpartist.FieldCreatedAt:
		str = "createdAt"
	case hpartist.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPArtistOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPArtistOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPArtistOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPArtistOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPArtistOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPArtistOrderField", str)
	}
	return nil
}

// HPArtistOrderField defines the ordering field of HPArtist.
type HPArtistOrderField struct {
	field    string
	toCursor func(*HPArtist) Cursor
}

// HPArtistOrder defines the ordering of HPArtist.
type HPArtistOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *HPArtistOrderField `json:"field"`
}

// DefaultHPArtistOrder is the default ordering of HPArtist.
var DefaultHPArtistOrder = &HPArtistOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPArtistOrderField{
		field: hpartist.FieldID,
		toCursor: func(ha *HPArtist) Cursor {
			return Cursor{ID: ha.ID}
		},
	},
}

// ToEdge converts HPArtist into HPArtistEdge.
func (ha *HPArtist) ToEdge(order *HPArtistOrder) *HPArtistEdge {
	if order == nil {
		order = DefaultHPArtistOrder
	}
	return &HPArtistEdge{
		Node:   ha,
		Cursor: order.Field.toCursor(ha),
	}
}

// HPBlobEdge is the edge representation of HPBlob.
type HPBlobEdge struct {
	Node   *HPBlob `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// HPBlobConnection is the connection containing edges to HPBlob.
type HPBlobConnection struct {
	Edges      []*HPBlobEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *HPBlobConnection) build(nodes []*HPBlob, pager *hpblobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPBlob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPBlob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPBlob {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPBlobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPBlobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPBlobPaginateOption enables pagination customization.
type HPBlobPaginateOption func(*hpblobPager) error

// WithHPBlobOrder configures pagination ordering.
func WithHPBlobOrder(order *HPBlobOrder) HPBlobPaginateOption {
	if order == nil {
		order = DefaultHPBlobOrder
	}
	o := *order
	return func(pager *hpblobPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPBlobOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPBlobFilter configures pagination filter.
func WithHPBlobFilter(filter func(*HPBlobQuery) (*HPBlobQuery, error)) HPBlobPaginateOption {
	return func(pager *hpblobPager) error {
		if filter == nil {
			return errors.New("HPBlobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpblobPager struct {
	reverse bool
	order   *HPBlobOrder
	filter  func(*HPBlobQuery) (*HPBlobQuery, error)
}

func newHPBlobPager(opts []HPBlobPaginateOption, reverse bool) (*hpblobPager, error) {
	pager := &hpblobPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPBlobOrder
	}
	return pager, nil
}

func (p *hpblobPager) applyFilter(query *HPBlobQuery) (*HPBlobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpblobPager) toCursor(hb *HPBlob) Cursor {
	return p.order.Field.toCursor(hb)
}

func (p *hpblobPager) applyCursors(query *HPBlobQuery, after, before *Cursor) (*HPBlobQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPBlobOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpblobPager) applyOrder(query *HPBlobQuery) *HPBlobQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPBlobOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPBlobOrder.Field.field))
	}
	return query
}

func (p *hpblobPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPBlobOrder.Field {
			b.Comma().Ident(DefaultHPBlobOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPBlob.
func (hb *HPBlobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPBlobPaginateOption,
) (*HPBlobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPBlobPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hb, err = pager.applyFilter(hb); err != nil {
		return nil, err
	}
	conn := &HPBlobConnection{Edges: []*HPBlobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hb.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hb, err = pager.applyCursors(hb, after, before); err != nil {
		return nil, err
	}
	hb = pager.applyOrder(hb)
	if limit := paginateLimit(first, last); limit != 0 {
		hb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hb.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPBlobOrderFieldCreatedAt orders HPBlob by created_at.
	HPBlobOrderFieldCreatedAt = &HPBlobOrderField{
		field: hpblob.FieldCreatedAt,
		toCursor: func(hb *HPBlob) Cursor {
			return Cursor{
				ID:    hb.ID,
				Value: hb.CreatedAt,
			}
		},
	}
	// HPBlobOrderFieldUpdatedAt orders HPBlob by updated_at.
	HPBlobOrderFieldUpdatedAt = &HPBlobOrderField{
		field: hpblob.FieldUpdatedAt,
		toCursor: func(hb *HPBlob) Cursor {
			return Cursor{
				ID:    hb.ID,
				Value: hb.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPBlobOrderField) String() string {
	var str string
	switch f.field {
	case hpblob.FieldCreatedAt:
		str = "createdAt"
	case hpblob.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPBlobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPBlobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPBlobOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPBlobOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPBlobOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPBlobOrderField", str)
	}
	return nil
}

// HPBlobOrderField defines the ordering field of HPBlob.
type HPBlobOrderField struct {
	field    string
	toCursor func(*HPBlob) Cursor
}

// HPBlobOrder defines the ordering of HPBlob.
type HPBlobOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *HPBlobOrderField `json:"field"`
}

// DefaultHPBlobOrder is the default ordering of HPBlob.
var DefaultHPBlobOrder = &HPBlobOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPBlobOrderField{
		field: hpblob.FieldID,
		toCursor: func(hb *HPBlob) Cursor {
			return Cursor{ID: hb.ID}
		},
	},
}

// ToEdge converts HPBlob into HPBlobEdge.
func (hb *HPBlob) ToEdge(order *HPBlobOrder) *HPBlobEdge {
	if order == nil {
		order = DefaultHPBlobOrder
	}
	return &HPBlobEdge{
		Node:   hb,
		Cursor: order.Field.toCursor(hb),
	}
}

// HPElineupMallItemEdge is the edge representation of HPElineupMallItem.
type HPElineupMallItemEdge struct {
	Node   *HPElineupMallItem `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// HPElineupMallItemConnection is the connection containing edges to HPElineupMallItem.
type HPElineupMallItemConnection struct {
	Edges      []*HPElineupMallItemEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *HPElineupMallItemConnection) build(nodes []*HPElineupMallItem, pager *hpelineupmallitemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPElineupMallItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPElineupMallItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPElineupMallItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPElineupMallItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPElineupMallItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPElineupMallItemPaginateOption enables pagination customization.
type HPElineupMallItemPaginateOption func(*hpelineupmallitemPager) error

// WithHPElineupMallItemOrder configures pagination ordering.
func WithHPElineupMallItemOrder(order *HPElineupMallItemOrder) HPElineupMallItemPaginateOption {
	if order == nil {
		order = DefaultHPElineupMallItemOrder
	}
	o := *order
	return func(pager *hpelineupmallitemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPElineupMallItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPElineupMallItemFilter configures pagination filter.
func WithHPElineupMallItemFilter(filter func(*HPElineupMallItemQuery) (*HPElineupMallItemQuery, error)) HPElineupMallItemPaginateOption {
	return func(pager *hpelineupmallitemPager) error {
		if filter == nil {
			return errors.New("HPElineupMallItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpelineupmallitemPager struct {
	reverse bool
	order   *HPElineupMallItemOrder
	filter  func(*HPElineupMallItemQuery) (*HPElineupMallItemQuery, error)
}

func newHPElineupMallItemPager(opts []HPElineupMallItemPaginateOption, reverse bool) (*hpelineupmallitemPager, error) {
	pager := &hpelineupmallitemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPElineupMallItemOrder
	}
	return pager, nil
}

func (p *hpelineupmallitemPager) applyFilter(query *HPElineupMallItemQuery) (*HPElineupMallItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpelineupmallitemPager) toCursor(hemi *HPElineupMallItem) Cursor {
	return p.order.Field.toCursor(hemi)
}

func (p *hpelineupmallitemPager) applyCursors(query *HPElineupMallItemQuery, after, before *Cursor) (*HPElineupMallItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPElineupMallItemOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpelineupmallitemPager) applyOrder(query *HPElineupMallItemQuery) *HPElineupMallItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPElineupMallItemOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPElineupMallItemOrder.Field.field))
	}
	return query
}

func (p *hpelineupmallitemPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPElineupMallItemOrder.Field {
			b.Comma().Ident(DefaultHPElineupMallItemOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPElineupMallItem.
func (hemi *HPElineupMallItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPElineupMallItemPaginateOption,
) (*HPElineupMallItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPElineupMallItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hemi, err = pager.applyFilter(hemi); err != nil {
		return nil, err
	}
	conn := &HPElineupMallItemConnection{Edges: []*HPElineupMallItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hemi.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hemi, err = pager.applyCursors(hemi, after, before); err != nil {
		return nil, err
	}
	hemi = pager.applyOrder(hemi)
	if limit := paginateLimit(first, last); limit != 0 {
		hemi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hemi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hemi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPElineupMallItemOrderFieldCreatedAt orders HPElineupMallItem by created_at.
	HPElineupMallItemOrderFieldCreatedAt = &HPElineupMallItemOrderField{
		field: hpelineupmallitem.FieldCreatedAt,
		toCursor: func(hemi *HPElineupMallItem) Cursor {
			return Cursor{
				ID:    hemi.ID,
				Value: hemi.CreatedAt,
			}
		},
	}
	// HPElineupMallItemOrderFieldUpdatedAt orders HPElineupMallItem by updated_at.
	HPElineupMallItemOrderFieldUpdatedAt = &HPElineupMallItemOrderField{
		field: hpelineupmallitem.FieldUpdatedAt,
		toCursor: func(hemi *HPElineupMallItem) Cursor {
			return Cursor{
				ID:    hemi.ID,
				Value: hemi.UpdatedAt,
			}
		},
	}
	// HPElineupMallItemOrderFieldOrderStartAt orders HPElineupMallItem by order_start_at.
	HPElineupMallItemOrderFieldOrderStartAt = &HPElineupMallItemOrderField{
		field: hpelineupmallitem.FieldOrderStartAt,
		toCursor: func(hemi *HPElineupMallItem) Cursor {
			return Cursor{
				ID:    hemi.ID,
				Value: hemi.OrderStartAt,
			}
		},
	}
	// HPElineupMallItemOrderFieldOrderEndAt orders HPElineupMallItem by order_end_at.
	HPElineupMallItemOrderFieldOrderEndAt = &HPElineupMallItemOrderField{
		field: hpelineupmallitem.FieldOrderEndAt,
		toCursor: func(hemi *HPElineupMallItem) Cursor {
			return Cursor{
				ID:    hemi.ID,
				Value: hemi.OrderEndAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPElineupMallItemOrderField) String() string {
	var str string
	switch f.field {
	case hpelineupmallitem.FieldCreatedAt:
		str = "createdAt"
	case hpelineupmallitem.FieldUpdatedAt:
		str = "updatedAt"
	case hpelineupmallitem.FieldOrderStartAt:
		str = "orderStartAt"
	case hpelineupmallitem.FieldOrderEndAt:
		str = "orderEndAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPElineupMallItemOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPElineupMallItemOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPElineupMallItemOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPElineupMallItemOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPElineupMallItemOrderFieldUpdatedAt
	case "orderStartAt":
		*f = *HPElineupMallItemOrderFieldOrderStartAt
	case "orderEndAt":
		*f = *HPElineupMallItemOrderFieldOrderEndAt
	default:
		return fmt.Errorf("%s is not a valid HPElineupMallItemOrderField", str)
	}
	return nil
}

// HPElineupMallItemOrderField defines the ordering field of HPElineupMallItem.
type HPElineupMallItemOrderField struct {
	field    string
	toCursor func(*HPElineupMallItem) Cursor
}

// HPElineupMallItemOrder defines the ordering of HPElineupMallItem.
type HPElineupMallItemOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *HPElineupMallItemOrderField `json:"field"`
}

// DefaultHPElineupMallItemOrder is the default ordering of HPElineupMallItem.
var DefaultHPElineupMallItemOrder = &HPElineupMallItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPElineupMallItemOrderField{
		field: hpelineupmallitem.FieldID,
		toCursor: func(hemi *HPElineupMallItem) Cursor {
			return Cursor{ID: hemi.ID}
		},
	},
}

// ToEdge converts HPElineupMallItem into HPElineupMallItemEdge.
func (hemi *HPElineupMallItem) ToEdge(order *HPElineupMallItemOrder) *HPElineupMallItemEdge {
	if order == nil {
		order = DefaultHPElineupMallItemOrder
	}
	return &HPElineupMallItemEdge{
		Node:   hemi,
		Cursor: order.Field.toCursor(hemi),
	}
}

// HPElineupMallItemPurchaseHistoryEdge is the edge representation of HPElineupMallItemPurchaseHistory.
type HPElineupMallItemPurchaseHistoryEdge struct {
	Node   *HPElineupMallItemPurchaseHistory `json:"node"`
	Cursor Cursor                            `json:"cursor"`
}

// HPElineupMallItemPurchaseHistoryConnection is the connection containing edges to HPElineupMallItemPurchaseHistory.
type HPElineupMallItemPurchaseHistoryConnection struct {
	Edges      []*HPElineupMallItemPurchaseHistoryEdge `json:"edges"`
	PageInfo   PageInfo                                `json:"pageInfo"`
	TotalCount int                                     `json:"totalCount"`
}

func (c *HPElineupMallItemPurchaseHistoryConnection) build(nodes []*HPElineupMallItemPurchaseHistory, pager *hpelineupmallitempurchasehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPElineupMallItemPurchaseHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPElineupMallItemPurchaseHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPElineupMallItemPurchaseHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPElineupMallItemPurchaseHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPElineupMallItemPurchaseHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPElineupMallItemPurchaseHistoryPaginateOption enables pagination customization.
type HPElineupMallItemPurchaseHistoryPaginateOption func(*hpelineupmallitempurchasehistoryPager) error

// WithHPElineupMallItemPurchaseHistoryOrder configures pagination ordering.
func WithHPElineupMallItemPurchaseHistoryOrder(order *HPElineupMallItemPurchaseHistoryOrder) HPElineupMallItemPurchaseHistoryPaginateOption {
	if order == nil {
		order = DefaultHPElineupMallItemPurchaseHistoryOrder
	}
	o := *order
	return func(pager *hpelineupmallitempurchasehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPElineupMallItemPurchaseHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPElineupMallItemPurchaseHistoryFilter configures pagination filter.
func WithHPElineupMallItemPurchaseHistoryFilter(filter func(*HPElineupMallItemPurchaseHistoryQuery) (*HPElineupMallItemPurchaseHistoryQuery, error)) HPElineupMallItemPurchaseHistoryPaginateOption {
	return func(pager *hpelineupmallitempurchasehistoryPager) error {
		if filter == nil {
			return errors.New("HPElineupMallItemPurchaseHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpelineupmallitempurchasehistoryPager struct {
	reverse bool
	order   *HPElineupMallItemPurchaseHistoryOrder
	filter  func(*HPElineupMallItemPurchaseHistoryQuery) (*HPElineupMallItemPurchaseHistoryQuery, error)
}

func newHPElineupMallItemPurchaseHistoryPager(opts []HPElineupMallItemPurchaseHistoryPaginateOption, reverse bool) (*hpelineupmallitempurchasehistoryPager, error) {
	pager := &hpelineupmallitempurchasehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPElineupMallItemPurchaseHistoryOrder
	}
	return pager, nil
}

func (p *hpelineupmallitempurchasehistoryPager) applyFilter(query *HPElineupMallItemPurchaseHistoryQuery) (*HPElineupMallItemPurchaseHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpelineupmallitempurchasehistoryPager) toCursor(hemiph *HPElineupMallItemPurchaseHistory) Cursor {
	return p.order.Field.toCursor(hemiph)
}

func (p *hpelineupmallitempurchasehistoryPager) applyCursors(query *HPElineupMallItemPurchaseHistoryQuery, after, before *Cursor) (*HPElineupMallItemPurchaseHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPElineupMallItemPurchaseHistoryOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpelineupmallitempurchasehistoryPager) applyOrder(query *HPElineupMallItemPurchaseHistoryQuery) *HPElineupMallItemPurchaseHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPElineupMallItemPurchaseHistoryOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPElineupMallItemPurchaseHistoryOrder.Field.field))
	}
	return query
}

func (p *hpelineupmallitempurchasehistoryPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPElineupMallItemPurchaseHistoryOrder.Field {
			b.Comma().Ident(DefaultHPElineupMallItemPurchaseHistoryOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPElineupMallItemPurchaseHistory.
func (hemiph *HPElineupMallItemPurchaseHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPElineupMallItemPurchaseHistoryPaginateOption,
) (*HPElineupMallItemPurchaseHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPElineupMallItemPurchaseHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hemiph, err = pager.applyFilter(hemiph); err != nil {
		return nil, err
	}
	conn := &HPElineupMallItemPurchaseHistoryConnection{Edges: []*HPElineupMallItemPurchaseHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hemiph.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hemiph, err = pager.applyCursors(hemiph, after, before); err != nil {
		return nil, err
	}
	hemiph = pager.applyOrder(hemiph)
	if limit := paginateLimit(first, last); limit != 0 {
		hemiph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hemiph.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hemiph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPElineupMallItemPurchaseHistoryOrderFieldCreatedAt orders HPElineupMallItemPurchaseHistory by created_at.
	HPElineupMallItemPurchaseHistoryOrderFieldCreatedAt = &HPElineupMallItemPurchaseHistoryOrderField{
		field: hpelineupmallitempurchasehistory.FieldCreatedAt,
		toCursor: func(hemiph *HPElineupMallItemPurchaseHistory) Cursor {
			return Cursor{
				ID:    hemiph.ID,
				Value: hemiph.CreatedAt,
			}
		},
	}
	// HPElineupMallItemPurchaseHistoryOrderFieldUpdatedAt orders HPElineupMallItemPurchaseHistory by updated_at.
	HPElineupMallItemPurchaseHistoryOrderFieldUpdatedAt = &HPElineupMallItemPurchaseHistoryOrderField{
		field: hpelineupmallitempurchasehistory.FieldUpdatedAt,
		toCursor: func(hemiph *HPElineupMallItemPurchaseHistory) Cursor {
			return Cursor{
				ID:    hemiph.ID,
				Value: hemiph.UpdatedAt,
			}
		},
	}
	// HPElineupMallItemPurchaseHistoryOrderFieldOrderedAt orders HPElineupMallItemPurchaseHistory by ordered_at.
	HPElineupMallItemPurchaseHistoryOrderFieldOrderedAt = &HPElineupMallItemPurchaseHistoryOrderField{
		field: hpelineupmallitempurchasehistory.FieldOrderedAt,
		toCursor: func(hemiph *HPElineupMallItemPurchaseHistory) Cursor {
			return Cursor{
				ID:    hemiph.ID,
				Value: hemiph.OrderedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPElineupMallItemPurchaseHistoryOrderField) String() string {
	var str string
	switch f.field {
	case hpelineupmallitempurchasehistory.FieldCreatedAt:
		str = "createdAt"
	case hpelineupmallitempurchasehistory.FieldUpdatedAt:
		str = "updatedAt"
	case hpelineupmallitempurchasehistory.FieldOrderedAt:
		str = "orderedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPElineupMallItemPurchaseHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPElineupMallItemPurchaseHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPElineupMallItemPurchaseHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPElineupMallItemPurchaseHistoryOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPElineupMallItemPurchaseHistoryOrderFieldUpdatedAt
	case "orderedAt":
		*f = *HPElineupMallItemPurchaseHistoryOrderFieldOrderedAt
	default:
		return fmt.Errorf("%s is not a valid HPElineupMallItemPurchaseHistoryOrderField", str)
	}
	return nil
}

// HPElineupMallItemPurchaseHistoryOrderField defines the ordering field of HPElineupMallItemPurchaseHistory.
type HPElineupMallItemPurchaseHistoryOrderField struct {
	field    string
	toCursor func(*HPElineupMallItemPurchaseHistory) Cursor
}

// HPElineupMallItemPurchaseHistoryOrder defines the ordering of HPElineupMallItemPurchaseHistory.
type HPElineupMallItemPurchaseHistoryOrder struct {
	Direction OrderDirection                              `json:"direction"`
	Field     *HPElineupMallItemPurchaseHistoryOrderField `json:"field"`
}

// DefaultHPElineupMallItemPurchaseHistoryOrder is the default ordering of HPElineupMallItemPurchaseHistory.
var DefaultHPElineupMallItemPurchaseHistoryOrder = &HPElineupMallItemPurchaseHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPElineupMallItemPurchaseHistoryOrderField{
		field: hpelineupmallitempurchasehistory.FieldID,
		toCursor: func(hemiph *HPElineupMallItemPurchaseHistory) Cursor {
			return Cursor{ID: hemiph.ID}
		},
	},
}

// ToEdge converts HPElineupMallItemPurchaseHistory into HPElineupMallItemPurchaseHistoryEdge.
func (hemiph *HPElineupMallItemPurchaseHistory) ToEdge(order *HPElineupMallItemPurchaseHistoryOrder) *HPElineupMallItemPurchaseHistoryEdge {
	if order == nil {
		order = DefaultHPElineupMallItemPurchaseHistoryOrder
	}
	return &HPElineupMallItemPurchaseHistoryEdge{
		Node:   hemiph,
		Cursor: order.Field.toCursor(hemiph),
	}
}

// HPEventEdge is the edge representation of HPEvent.
type HPEventEdge struct {
	Node   *HPEvent `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// HPEventConnection is the connection containing edges to HPEvent.
type HPEventConnection struct {
	Edges      []*HPEventEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *HPEventConnection) build(nodes []*HPEvent, pager *hpeventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPEvent
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPEvent {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPEvent {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPEventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPEventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPEventPaginateOption enables pagination customization.
type HPEventPaginateOption func(*hpeventPager) error

// WithHPEventOrder configures pagination ordering.
func WithHPEventOrder(order *HPEventOrder) HPEventPaginateOption {
	if order == nil {
		order = DefaultHPEventOrder
	}
	o := *order
	return func(pager *hpeventPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPEventOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPEventFilter configures pagination filter.
func WithHPEventFilter(filter func(*HPEventQuery) (*HPEventQuery, error)) HPEventPaginateOption {
	return func(pager *hpeventPager) error {
		if filter == nil {
			return errors.New("HPEventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpeventPager struct {
	reverse bool
	order   *HPEventOrder
	filter  func(*HPEventQuery) (*HPEventQuery, error)
}

func newHPEventPager(opts []HPEventPaginateOption, reverse bool) (*hpeventPager, error) {
	pager := &hpeventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPEventOrder
	}
	return pager, nil
}

func (p *hpeventPager) applyFilter(query *HPEventQuery) (*HPEventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpeventPager) toCursor(he *HPEvent) Cursor {
	return p.order.Field.toCursor(he)
}

func (p *hpeventPager) applyCursors(query *HPEventQuery, after, before *Cursor) (*HPEventQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPEventOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpeventPager) applyOrder(query *HPEventQuery) *HPEventQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPEventOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPEventOrder.Field.field))
	}
	return query
}

func (p *hpeventPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPEventOrder.Field {
			b.Comma().Ident(DefaultHPEventOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPEvent.
func (he *HPEventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPEventPaginateOption,
) (*HPEventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if he, err = pager.applyFilter(he); err != nil {
		return nil, err
	}
	conn := &HPEventConnection{Edges: []*HPEventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = he.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if he, err = pager.applyCursors(he, after, before); err != nil {
		return nil, err
	}
	he = pager.applyOrder(he)
	if limit := paginateLimit(first, last); limit != 0 {
		he.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := he.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := he.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPEventOrderFieldCreatedAt orders HPEvent by created_at.
	HPEventOrderFieldCreatedAt = &HPEventOrderField{
		field: hpevent.FieldCreatedAt,
		toCursor: func(he *HPEvent) Cursor {
			return Cursor{
				ID:    he.ID,
				Value: he.CreatedAt,
			}
		},
	}
	// HPEventOrderFieldUpdatedAt orders HPEvent by updated_at.
	HPEventOrderFieldUpdatedAt = &HPEventOrderField{
		field: hpevent.FieldUpdatedAt,
		toCursor: func(he *HPEvent) Cursor {
			return Cursor{
				ID:    he.ID,
				Value: he.UpdatedAt,
			}
		},
	}
	// HPEventOrderFieldStartAt orders HPEvent by start_at.
	HPEventOrderFieldStartAt = &HPEventOrderField{
		field: hpevent.FieldStartAt,
		toCursor: func(he *HPEvent) Cursor {
			return Cursor{
				ID:    he.ID,
				Value: he.StartAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPEventOrderField) String() string {
	var str string
	switch f.field {
	case hpevent.FieldCreatedAt:
		str = "createdAt"
	case hpevent.FieldUpdatedAt:
		str = "updatedAt"
	case hpevent.FieldStartAt:
		str = "startAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPEventOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPEventOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPEventOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPEventOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPEventOrderFieldUpdatedAt
	case "startAt":
		*f = *HPEventOrderFieldStartAt
	default:
		return fmt.Errorf("%s is not a valid HPEventOrderField", str)
	}
	return nil
}

// HPEventOrderField defines the ordering field of HPEvent.
type HPEventOrderField struct {
	field    string
	toCursor func(*HPEvent) Cursor
}

// HPEventOrder defines the ordering of HPEvent.
type HPEventOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *HPEventOrderField `json:"field"`
}

// DefaultHPEventOrder is the default ordering of HPEvent.
var DefaultHPEventOrder = &HPEventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPEventOrderField{
		field: hpevent.FieldID,
		toCursor: func(he *HPEvent) Cursor {
			return Cursor{ID: he.ID}
		},
	},
}

// ToEdge converts HPEvent into HPEventEdge.
func (he *HPEvent) ToEdge(order *HPEventOrder) *HPEventEdge {
	if order == nil {
		order = DefaultHPEventOrder
	}
	return &HPEventEdge{
		Node:   he,
		Cursor: order.Field.toCursor(he),
	}
}

// HPFCEventTicketEdge is the edge representation of HPFCEventTicket.
type HPFCEventTicketEdge struct {
	Node   *HPFCEventTicket `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// HPFCEventTicketConnection is the connection containing edges to HPFCEventTicket.
type HPFCEventTicketConnection struct {
	Edges      []*HPFCEventTicketEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *HPFCEventTicketConnection) build(nodes []*HPFCEventTicket, pager *hpfceventticketPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPFCEventTicket
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPFCEventTicket {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPFCEventTicket {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPFCEventTicketEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPFCEventTicketEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPFCEventTicketPaginateOption enables pagination customization.
type HPFCEventTicketPaginateOption func(*hpfceventticketPager) error

// WithHPFCEventTicketOrder configures pagination ordering.
func WithHPFCEventTicketOrder(order *HPFCEventTicketOrder) HPFCEventTicketPaginateOption {
	if order == nil {
		order = DefaultHPFCEventTicketOrder
	}
	o := *order
	return func(pager *hpfceventticketPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPFCEventTicketOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPFCEventTicketFilter configures pagination filter.
func WithHPFCEventTicketFilter(filter func(*HPFCEventTicketQuery) (*HPFCEventTicketQuery, error)) HPFCEventTicketPaginateOption {
	return func(pager *hpfceventticketPager) error {
		if filter == nil {
			return errors.New("HPFCEventTicketQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpfceventticketPager struct {
	reverse bool
	order   *HPFCEventTicketOrder
	filter  func(*HPFCEventTicketQuery) (*HPFCEventTicketQuery, error)
}

func newHPFCEventTicketPager(opts []HPFCEventTicketPaginateOption, reverse bool) (*hpfceventticketPager, error) {
	pager := &hpfceventticketPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPFCEventTicketOrder
	}
	return pager, nil
}

func (p *hpfceventticketPager) applyFilter(query *HPFCEventTicketQuery) (*HPFCEventTicketQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpfceventticketPager) toCursor(het *HPFCEventTicket) Cursor {
	return p.order.Field.toCursor(het)
}

func (p *hpfceventticketPager) applyCursors(query *HPFCEventTicketQuery, after, before *Cursor) (*HPFCEventTicketQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPFCEventTicketOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpfceventticketPager) applyOrder(query *HPFCEventTicketQuery) *HPFCEventTicketQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPFCEventTicketOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPFCEventTicketOrder.Field.field))
	}
	return query
}

func (p *hpfceventticketPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPFCEventTicketOrder.Field {
			b.Comma().Ident(DefaultHPFCEventTicketOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPFCEventTicket.
func (het *HPFCEventTicketQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPFCEventTicketPaginateOption,
) (*HPFCEventTicketConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPFCEventTicketPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if het, err = pager.applyFilter(het); err != nil {
		return nil, err
	}
	conn := &HPFCEventTicketConnection{Edges: []*HPFCEventTicketEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = het.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if het, err = pager.applyCursors(het, after, before); err != nil {
		return nil, err
	}
	het = pager.applyOrder(het)
	if limit := paginateLimit(first, last); limit != 0 {
		het.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := het.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := het.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPFCEventTicketOrderFieldCreatedAt orders HPFCEventTicket by created_at.
	HPFCEventTicketOrderFieldCreatedAt = &HPFCEventTicketOrderField{
		field: hpfceventticket.FieldCreatedAt,
		toCursor: func(het *HPFCEventTicket) Cursor {
			return Cursor{
				ID:    het.ID,
				Value: het.CreatedAt,
			}
		},
	}
	// HPFCEventTicketOrderFieldUpdatedAt orders HPFCEventTicket by updated_at.
	HPFCEventTicketOrderFieldUpdatedAt = &HPFCEventTicketOrderField{
		field: hpfceventticket.FieldUpdatedAt,
		toCursor: func(het *HPFCEventTicket) Cursor {
			return Cursor{
				ID:    het.ID,
				Value: het.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPFCEventTicketOrderField) String() string {
	var str string
	switch f.field {
	case hpfceventticket.FieldCreatedAt:
		str = "createdAt"
	case hpfceventticket.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPFCEventTicketOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPFCEventTicketOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPFCEventTicketOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPFCEventTicketOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPFCEventTicketOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPFCEventTicketOrderField", str)
	}
	return nil
}

// HPFCEventTicketOrderField defines the ordering field of HPFCEventTicket.
type HPFCEventTicketOrderField struct {
	field    string
	toCursor func(*HPFCEventTicket) Cursor
}

// HPFCEventTicketOrder defines the ordering of HPFCEventTicket.
type HPFCEventTicketOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *HPFCEventTicketOrderField `json:"field"`
}

// DefaultHPFCEventTicketOrder is the default ordering of HPFCEventTicket.
var DefaultHPFCEventTicketOrder = &HPFCEventTicketOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPFCEventTicketOrderField{
		field: hpfceventticket.FieldID,
		toCursor: func(het *HPFCEventTicket) Cursor {
			return Cursor{ID: het.ID}
		},
	},
}

// ToEdge converts HPFCEventTicket into HPFCEventTicketEdge.
func (het *HPFCEventTicket) ToEdge(order *HPFCEventTicketOrder) *HPFCEventTicketEdge {
	if order == nil {
		order = DefaultHPFCEventTicketOrder
	}
	return &HPFCEventTicketEdge{
		Node:   het,
		Cursor: order.Field.toCursor(het),
	}
}

// HPFeedItemEdge is the edge representation of HPFeedItem.
type HPFeedItemEdge struct {
	Node   *HPFeedItem `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// HPFeedItemConnection is the connection containing edges to HPFeedItem.
type HPFeedItemConnection struct {
	Edges      []*HPFeedItemEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *HPFeedItemConnection) build(nodes []*HPFeedItem, pager *hpfeeditemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPFeedItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPFeedItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPFeedItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPFeedItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPFeedItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPFeedItemPaginateOption enables pagination customization.
type HPFeedItemPaginateOption func(*hpfeeditemPager) error

// WithHPFeedItemOrder configures pagination ordering.
func WithHPFeedItemOrder(order *HPFeedItemOrder) HPFeedItemPaginateOption {
	if order == nil {
		order = DefaultHPFeedItemOrder
	}
	o := *order
	return func(pager *hpfeeditemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPFeedItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPFeedItemFilter configures pagination filter.
func WithHPFeedItemFilter(filter func(*HPFeedItemQuery) (*HPFeedItemQuery, error)) HPFeedItemPaginateOption {
	return func(pager *hpfeeditemPager) error {
		if filter == nil {
			return errors.New("HPFeedItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpfeeditemPager struct {
	reverse bool
	order   *HPFeedItemOrder
	filter  func(*HPFeedItemQuery) (*HPFeedItemQuery, error)
}

func newHPFeedItemPager(opts []HPFeedItemPaginateOption, reverse bool) (*hpfeeditemPager, error) {
	pager := &hpfeeditemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPFeedItemOrder
	}
	return pager, nil
}

func (p *hpfeeditemPager) applyFilter(query *HPFeedItemQuery) (*HPFeedItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpfeeditemPager) toCursor(hfi *HPFeedItem) Cursor {
	return p.order.Field.toCursor(hfi)
}

func (p *hpfeeditemPager) applyCursors(query *HPFeedItemQuery, after, before *Cursor) (*HPFeedItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPFeedItemOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpfeeditemPager) applyOrder(query *HPFeedItemQuery) *HPFeedItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPFeedItemOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPFeedItemOrder.Field.field))
	}
	return query
}

func (p *hpfeeditemPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPFeedItemOrder.Field {
			b.Comma().Ident(DefaultHPFeedItemOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPFeedItem.
func (hfi *HPFeedItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPFeedItemPaginateOption,
) (*HPFeedItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPFeedItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hfi, err = pager.applyFilter(hfi); err != nil {
		return nil, err
	}
	conn := &HPFeedItemConnection{Edges: []*HPFeedItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hfi.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hfi, err = pager.applyCursors(hfi, after, before); err != nil {
		return nil, err
	}
	hfi = pager.applyOrder(hfi)
	if limit := paginateLimit(first, last); limit != 0 {
		hfi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hfi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hfi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPFeedItemOrderFieldCreatedAt orders HPFeedItem by created_at.
	HPFeedItemOrderFieldCreatedAt = &HPFeedItemOrderField{
		field: hpfeeditem.FieldCreatedAt,
		toCursor: func(hfi *HPFeedItem) Cursor {
			return Cursor{
				ID:    hfi.ID,
				Value: hfi.CreatedAt,
			}
		},
	}
	// HPFeedItemOrderFieldUpdatedAt orders HPFeedItem by updated_at.
	HPFeedItemOrderFieldUpdatedAt = &HPFeedItemOrderField{
		field: hpfeeditem.FieldUpdatedAt,
		toCursor: func(hfi *HPFeedItem) Cursor {
			return Cursor{
				ID:    hfi.ID,
				Value: hfi.UpdatedAt,
			}
		},
	}
	// HPFeedItemOrderFieldPostAt orders HPFeedItem by post_at.
	HPFeedItemOrderFieldPostAt = &HPFeedItemOrderField{
		field: hpfeeditem.FieldPostAt,
		toCursor: func(hfi *HPFeedItem) Cursor {
			return Cursor{
				ID:    hfi.ID,
				Value: hfi.PostAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPFeedItemOrderField) String() string {
	var str string
	switch f.field {
	case hpfeeditem.FieldCreatedAt:
		str = "createdAt"
	case hpfeeditem.FieldUpdatedAt:
		str = "updatedAt"
	case hpfeeditem.FieldPostAt:
		str = "postAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPFeedItemOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPFeedItemOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPFeedItemOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPFeedItemOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPFeedItemOrderFieldUpdatedAt
	case "postAt":
		*f = *HPFeedItemOrderFieldPostAt
	default:
		return fmt.Errorf("%s is not a valid HPFeedItemOrderField", str)
	}
	return nil
}

// HPFeedItemOrderField defines the ordering field of HPFeedItem.
type HPFeedItemOrderField struct {
	field    string
	toCursor func(*HPFeedItem) Cursor
}

// HPFeedItemOrder defines the ordering of HPFeedItem.
type HPFeedItemOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *HPFeedItemOrderField `json:"field"`
}

// DefaultHPFeedItemOrder is the default ordering of HPFeedItem.
var DefaultHPFeedItemOrder = &HPFeedItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPFeedItemOrderField{
		field: hpfeeditem.FieldID,
		toCursor: func(hfi *HPFeedItem) Cursor {
			return Cursor{ID: hfi.ID}
		},
	},
}

// ToEdge converts HPFeedItem into HPFeedItemEdge.
func (hfi *HPFeedItem) ToEdge(order *HPFeedItemOrder) *HPFeedItemEdge {
	if order == nil {
		order = DefaultHPFeedItemOrder
	}
	return &HPFeedItemEdge{
		Node:   hfi,
		Cursor: order.Field.toCursor(hfi),
	}
}

// HPFollowEdge is the edge representation of HPFollow.
type HPFollowEdge struct {
	Node   *HPFollow `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// HPFollowConnection is the connection containing edges to HPFollow.
type HPFollowConnection struct {
	Edges      []*HPFollowEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *HPFollowConnection) build(nodes []*HPFollow, pager *hpfollowPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPFollow
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPFollow {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPFollow {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPFollowEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPFollowEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPFollowPaginateOption enables pagination customization.
type HPFollowPaginateOption func(*hpfollowPager) error

// WithHPFollowOrder configures pagination ordering.
func WithHPFollowOrder(order *HPFollowOrder) HPFollowPaginateOption {
	if order == nil {
		order = DefaultHPFollowOrder
	}
	o := *order
	return func(pager *hpfollowPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPFollowOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPFollowFilter configures pagination filter.
func WithHPFollowFilter(filter func(*HPFollowQuery) (*HPFollowQuery, error)) HPFollowPaginateOption {
	return func(pager *hpfollowPager) error {
		if filter == nil {
			return errors.New("HPFollowQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpfollowPager struct {
	reverse bool
	order   *HPFollowOrder
	filter  func(*HPFollowQuery) (*HPFollowQuery, error)
}

func newHPFollowPager(opts []HPFollowPaginateOption, reverse bool) (*hpfollowPager, error) {
	pager := &hpfollowPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPFollowOrder
	}
	return pager, nil
}

func (p *hpfollowPager) applyFilter(query *HPFollowQuery) (*HPFollowQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpfollowPager) toCursor(hf *HPFollow) Cursor {
	return p.order.Field.toCursor(hf)
}

func (p *hpfollowPager) applyCursors(query *HPFollowQuery, after, before *Cursor) (*HPFollowQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPFollowOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpfollowPager) applyOrder(query *HPFollowQuery) *HPFollowQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPFollowOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPFollowOrder.Field.field))
	}
	return query
}

func (p *hpfollowPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPFollowOrder.Field {
			b.Comma().Ident(DefaultHPFollowOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPFollow.
func (hf *HPFollowQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPFollowPaginateOption,
) (*HPFollowConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPFollowPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hf, err = pager.applyFilter(hf); err != nil {
		return nil, err
	}
	conn := &HPFollowConnection{Edges: []*HPFollowEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hf.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hf, err = pager.applyCursors(hf, after, before); err != nil {
		return nil, err
	}
	hf = pager.applyOrder(hf)
	if limit := paginateLimit(first, last); limit != 0 {
		hf.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hf.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hf.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPFollowOrderFieldCreatedAt orders HPFollow by created_at.
	HPFollowOrderFieldCreatedAt = &HPFollowOrderField{
		field: hpfollow.FieldCreatedAt,
		toCursor: func(hf *HPFollow) Cursor {
			return Cursor{
				ID:    hf.ID,
				Value: hf.CreatedAt,
			}
		},
	}
	// HPFollowOrderFieldUpdatedAt orders HPFollow by updated_at.
	HPFollowOrderFieldUpdatedAt = &HPFollowOrderField{
		field: hpfollow.FieldUpdatedAt,
		toCursor: func(hf *HPFollow) Cursor {
			return Cursor{
				ID:    hf.ID,
				Value: hf.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPFollowOrderField) String() string {
	var str string
	switch f.field {
	case hpfollow.FieldCreatedAt:
		str = "createdAt"
	case hpfollow.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPFollowOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPFollowOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPFollowOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPFollowOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPFollowOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPFollowOrderField", str)
	}
	return nil
}

// HPFollowOrderField defines the ordering field of HPFollow.
type HPFollowOrderField struct {
	field    string
	toCursor func(*HPFollow) Cursor
}

// HPFollowOrder defines the ordering of HPFollow.
type HPFollowOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *HPFollowOrderField `json:"field"`
}

// DefaultHPFollowOrder is the default ordering of HPFollow.
var DefaultHPFollowOrder = &HPFollowOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPFollowOrderField{
		field: hpfollow.FieldID,
		toCursor: func(hf *HPFollow) Cursor {
			return Cursor{ID: hf.ID}
		},
	},
}

// ToEdge converts HPFollow into HPFollowEdge.
func (hf *HPFollow) ToEdge(order *HPFollowOrder) *HPFollowEdge {
	if order == nil {
		order = DefaultHPFollowOrder
	}
	return &HPFollowEdge{
		Node:   hf,
		Cursor: order.Field.toCursor(hf),
	}
}

// HPIgPostEdge is the edge representation of HPIgPost.
type HPIgPostEdge struct {
	Node   *HPIgPost `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// HPIgPostConnection is the connection containing edges to HPIgPost.
type HPIgPostConnection struct {
	Edges      []*HPIgPostEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *HPIgPostConnection) build(nodes []*HPIgPost, pager *hpigpostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPIgPost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPIgPost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPIgPost {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPIgPostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPIgPostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPIgPostPaginateOption enables pagination customization.
type HPIgPostPaginateOption func(*hpigpostPager) error

// WithHPIgPostOrder configures pagination ordering.
func WithHPIgPostOrder(order *HPIgPostOrder) HPIgPostPaginateOption {
	if order == nil {
		order = DefaultHPIgPostOrder
	}
	o := *order
	return func(pager *hpigpostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPIgPostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPIgPostFilter configures pagination filter.
func WithHPIgPostFilter(filter func(*HPIgPostQuery) (*HPIgPostQuery, error)) HPIgPostPaginateOption {
	return func(pager *hpigpostPager) error {
		if filter == nil {
			return errors.New("HPIgPostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpigpostPager struct {
	reverse bool
	order   *HPIgPostOrder
	filter  func(*HPIgPostQuery) (*HPIgPostQuery, error)
}

func newHPIgPostPager(opts []HPIgPostPaginateOption, reverse bool) (*hpigpostPager, error) {
	pager := &hpigpostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPIgPostOrder
	}
	return pager, nil
}

func (p *hpigpostPager) applyFilter(query *HPIgPostQuery) (*HPIgPostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpigpostPager) toCursor(hip *HPIgPost) Cursor {
	return p.order.Field.toCursor(hip)
}

func (p *hpigpostPager) applyCursors(query *HPIgPostQuery, after, before *Cursor) (*HPIgPostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPIgPostOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpigpostPager) applyOrder(query *HPIgPostQuery) *HPIgPostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPIgPostOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPIgPostOrder.Field.field))
	}
	return query
}

func (p *hpigpostPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPIgPostOrder.Field {
			b.Comma().Ident(DefaultHPIgPostOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPIgPost.
func (hip *HPIgPostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPIgPostPaginateOption,
) (*HPIgPostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPIgPostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hip, err = pager.applyFilter(hip); err != nil {
		return nil, err
	}
	conn := &HPIgPostConnection{Edges: []*HPIgPostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hip.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hip, err = pager.applyCursors(hip, after, before); err != nil {
		return nil, err
	}
	hip = pager.applyOrder(hip)
	if limit := paginateLimit(first, last); limit != 0 {
		hip.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hip.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hip.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPIgPostOrderFieldCreatedAt orders HPIgPost by created_at.
	HPIgPostOrderFieldCreatedAt = &HPIgPostOrderField{
		field: hpigpost.FieldCreatedAt,
		toCursor: func(hip *HPIgPost) Cursor {
			return Cursor{
				ID:    hip.ID,
				Value: hip.CreatedAt,
			}
		},
	}
	// HPIgPostOrderFieldUpdatedAt orders HPIgPost by updated_at.
	HPIgPostOrderFieldUpdatedAt = &HPIgPostOrderField{
		field: hpigpost.FieldUpdatedAt,
		toCursor: func(hip *HPIgPost) Cursor {
			return Cursor{
				ID:    hip.ID,
				Value: hip.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPIgPostOrderField) String() string {
	var str string
	switch f.field {
	case hpigpost.FieldCreatedAt:
		str = "createdAt"
	case hpigpost.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPIgPostOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPIgPostOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPIgPostOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPIgPostOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPIgPostOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPIgPostOrderField", str)
	}
	return nil
}

// HPIgPostOrderField defines the ordering field of HPIgPost.
type HPIgPostOrderField struct {
	field    string
	toCursor func(*HPIgPost) Cursor
}

// HPIgPostOrder defines the ordering of HPIgPost.
type HPIgPostOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *HPIgPostOrderField `json:"field"`
}

// DefaultHPIgPostOrder is the default ordering of HPIgPost.
var DefaultHPIgPostOrder = &HPIgPostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPIgPostOrderField{
		field: hpigpost.FieldID,
		toCursor: func(hip *HPIgPost) Cursor {
			return Cursor{ID: hip.ID}
		},
	},
}

// ToEdge converts HPIgPost into HPIgPostEdge.
func (hip *HPIgPost) ToEdge(order *HPIgPostOrder) *HPIgPostEdge {
	if order == nil {
		order = DefaultHPIgPostOrder
	}
	return &HPIgPostEdge{
		Node:   hip,
		Cursor: order.Field.toCursor(hip),
	}
}

// HPMemberEdge is the edge representation of HPMember.
type HPMemberEdge struct {
	Node   *HPMember `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// HPMemberConnection is the connection containing edges to HPMember.
type HPMemberConnection struct {
	Edges      []*HPMemberEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *HPMemberConnection) build(nodes []*HPMember, pager *hpmemberPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPMember
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPMember {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPMember {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPMemberEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPMemberEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPMemberPaginateOption enables pagination customization.
type HPMemberPaginateOption func(*hpmemberPager) error

// WithHPMemberOrder configures pagination ordering.
func WithHPMemberOrder(order *HPMemberOrder) HPMemberPaginateOption {
	if order == nil {
		order = DefaultHPMemberOrder
	}
	o := *order
	return func(pager *hpmemberPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPMemberOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPMemberFilter configures pagination filter.
func WithHPMemberFilter(filter func(*HPMemberQuery) (*HPMemberQuery, error)) HPMemberPaginateOption {
	return func(pager *hpmemberPager) error {
		if filter == nil {
			return errors.New("HPMemberQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpmemberPager struct {
	reverse bool
	order   *HPMemberOrder
	filter  func(*HPMemberQuery) (*HPMemberQuery, error)
}

func newHPMemberPager(opts []HPMemberPaginateOption, reverse bool) (*hpmemberPager, error) {
	pager := &hpmemberPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPMemberOrder
	}
	return pager, nil
}

func (p *hpmemberPager) applyFilter(query *HPMemberQuery) (*HPMemberQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpmemberPager) toCursor(hm *HPMember) Cursor {
	return p.order.Field.toCursor(hm)
}

func (p *hpmemberPager) applyCursors(query *HPMemberQuery, after, before *Cursor) (*HPMemberQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPMemberOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpmemberPager) applyOrder(query *HPMemberQuery) *HPMemberQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPMemberOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPMemberOrder.Field.field))
	}
	return query
}

func (p *hpmemberPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPMemberOrder.Field {
			b.Comma().Ident(DefaultHPMemberOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPMember.
func (hm *HPMemberQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPMemberPaginateOption,
) (*HPMemberConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPMemberPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hm, err = pager.applyFilter(hm); err != nil {
		return nil, err
	}
	conn := &HPMemberConnection{Edges: []*HPMemberEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hm.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hm, err = pager.applyCursors(hm, after, before); err != nil {
		return nil, err
	}
	hm = pager.applyOrder(hm)
	if limit := paginateLimit(first, last); limit != 0 {
		hm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPMemberOrderFieldCreatedAt orders HPMember by created_at.
	HPMemberOrderFieldCreatedAt = &HPMemberOrderField{
		field: hpmember.FieldCreatedAt,
		toCursor: func(hm *HPMember) Cursor {
			return Cursor{
				ID:    hm.ID,
				Value: hm.CreatedAt,
			}
		},
	}
	// HPMemberOrderFieldUpdatedAt orders HPMember by updated_at.
	HPMemberOrderFieldUpdatedAt = &HPMemberOrderField{
		field: hpmember.FieldUpdatedAt,
		toCursor: func(hm *HPMember) Cursor {
			return Cursor{
				ID:    hm.ID,
				Value: hm.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPMemberOrderField) String() string {
	var str string
	switch f.field {
	case hpmember.FieldCreatedAt:
		str = "createdAt"
	case hpmember.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPMemberOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPMemberOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPMemberOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPMemberOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPMemberOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPMemberOrderField", str)
	}
	return nil
}

// HPMemberOrderField defines the ordering field of HPMember.
type HPMemberOrderField struct {
	field    string
	toCursor func(*HPMember) Cursor
}

// HPMemberOrder defines the ordering of HPMember.
type HPMemberOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *HPMemberOrderField `json:"field"`
}

// DefaultHPMemberOrder is the default ordering of HPMember.
var DefaultHPMemberOrder = &HPMemberOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPMemberOrderField{
		field: hpmember.FieldID,
		toCursor: func(hm *HPMember) Cursor {
			return Cursor{ID: hm.ID}
		},
	},
}

// ToEdge converts HPMember into HPMemberEdge.
func (hm *HPMember) ToEdge(order *HPMemberOrder) *HPMemberEdge {
	if order == nil {
		order = DefaultHPMemberOrder
	}
	return &HPMemberEdge{
		Node:   hm,
		Cursor: order.Field.toCursor(hm),
	}
}

// HPSortHistoryEdge is the edge representation of HPSortHistory.
type HPSortHistoryEdge struct {
	Node   *HPSortHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// HPSortHistoryConnection is the connection containing edges to HPSortHistory.
type HPSortHistoryConnection struct {
	Edges      []*HPSortHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *HPSortHistoryConnection) build(nodes []*HPSortHistory, pager *hpsorthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPSortHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPSortHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPSortHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPSortHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPSortHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPSortHistoryPaginateOption enables pagination customization.
type HPSortHistoryPaginateOption func(*hpsorthistoryPager) error

// WithHPSortHistoryOrder configures pagination ordering.
func WithHPSortHistoryOrder(order *HPSortHistoryOrder) HPSortHistoryPaginateOption {
	if order == nil {
		order = DefaultHPSortHistoryOrder
	}
	o := *order
	return func(pager *hpsorthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPSortHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPSortHistoryFilter configures pagination filter.
func WithHPSortHistoryFilter(filter func(*HPSortHistoryQuery) (*HPSortHistoryQuery, error)) HPSortHistoryPaginateOption {
	return func(pager *hpsorthistoryPager) error {
		if filter == nil {
			return errors.New("HPSortHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpsorthistoryPager struct {
	reverse bool
	order   *HPSortHistoryOrder
	filter  func(*HPSortHistoryQuery) (*HPSortHistoryQuery, error)
}

func newHPSortHistoryPager(opts []HPSortHistoryPaginateOption, reverse bool) (*hpsorthistoryPager, error) {
	pager := &hpsorthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPSortHistoryOrder
	}
	return pager, nil
}

func (p *hpsorthistoryPager) applyFilter(query *HPSortHistoryQuery) (*HPSortHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpsorthistoryPager) toCursor(hsh *HPSortHistory) Cursor {
	return p.order.Field.toCursor(hsh)
}

func (p *hpsorthistoryPager) applyCursors(query *HPSortHistoryQuery, after, before *Cursor) (*HPSortHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPSortHistoryOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpsorthistoryPager) applyOrder(query *HPSortHistoryQuery) *HPSortHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPSortHistoryOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPSortHistoryOrder.Field.field))
	}
	return query
}

func (p *hpsorthistoryPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPSortHistoryOrder.Field {
			b.Comma().Ident(DefaultHPSortHistoryOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPSortHistory.
func (hsh *HPSortHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPSortHistoryPaginateOption,
) (*HPSortHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPSortHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hsh, err = pager.applyFilter(hsh); err != nil {
		return nil, err
	}
	conn := &HPSortHistoryConnection{Edges: []*HPSortHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hsh.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hsh, err = pager.applyCursors(hsh, after, before); err != nil {
		return nil, err
	}
	hsh = pager.applyOrder(hsh)
	if limit := paginateLimit(first, last); limit != 0 {
		hsh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hsh.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hsh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPSortHistoryOrderFieldCreatedAt orders HPSortHistory by created_at.
	HPSortHistoryOrderFieldCreatedAt = &HPSortHistoryOrderField{
		field: hpsorthistory.FieldCreatedAt,
		toCursor: func(hsh *HPSortHistory) Cursor {
			return Cursor{
				ID:    hsh.ID,
				Value: hsh.CreatedAt,
			}
		},
	}
	// HPSortHistoryOrderFieldUpdatedAt orders HPSortHistory by updated_at.
	HPSortHistoryOrderFieldUpdatedAt = &HPSortHistoryOrderField{
		field: hpsorthistory.FieldUpdatedAt,
		toCursor: func(hsh *HPSortHistory) Cursor {
			return Cursor{
				ID:    hsh.ID,
				Value: hsh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPSortHistoryOrderField) String() string {
	var str string
	switch f.field {
	case hpsorthistory.FieldCreatedAt:
		str = "createdAt"
	case hpsorthistory.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPSortHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPSortHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPSortHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPSortHistoryOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPSortHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPSortHistoryOrderField", str)
	}
	return nil
}

// HPSortHistoryOrderField defines the ordering field of HPSortHistory.
type HPSortHistoryOrderField struct {
	field    string
	toCursor func(*HPSortHistory) Cursor
}

// HPSortHistoryOrder defines the ordering of HPSortHistory.
type HPSortHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *HPSortHistoryOrderField `json:"field"`
}

// DefaultHPSortHistoryOrder is the default ordering of HPSortHistory.
var DefaultHPSortHistoryOrder = &HPSortHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPSortHistoryOrderField{
		field: hpsorthistory.FieldID,
		toCursor: func(hsh *HPSortHistory) Cursor {
			return Cursor{ID: hsh.ID}
		},
	},
}

// ToEdge converts HPSortHistory into HPSortHistoryEdge.
func (hsh *HPSortHistory) ToEdge(order *HPSortHistoryOrder) *HPSortHistoryEdge {
	if order == nil {
		order = DefaultHPSortHistoryOrder
	}
	return &HPSortHistoryEdge{
		Node:   hsh,
		Cursor: order.Field.toCursor(hsh),
	}
}

// HPViewHistoryEdge is the edge representation of HPViewHistory.
type HPViewHistoryEdge struct {
	Node   *HPViewHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// HPViewHistoryConnection is the connection containing edges to HPViewHistory.
type HPViewHistoryConnection struct {
	Edges      []*HPViewHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *HPViewHistoryConnection) build(nodes []*HPViewHistory, pager *hpviewhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HPViewHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HPViewHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HPViewHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*HPViewHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HPViewHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HPViewHistoryPaginateOption enables pagination customization.
type HPViewHistoryPaginateOption func(*hpviewhistoryPager) error

// WithHPViewHistoryOrder configures pagination ordering.
func WithHPViewHistoryOrder(order *HPViewHistoryOrder) HPViewHistoryPaginateOption {
	if order == nil {
		order = DefaultHPViewHistoryOrder
	}
	o := *order
	return func(pager *hpviewhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHPViewHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHPViewHistoryFilter configures pagination filter.
func WithHPViewHistoryFilter(filter func(*HPViewHistoryQuery) (*HPViewHistoryQuery, error)) HPViewHistoryPaginateOption {
	return func(pager *hpviewhistoryPager) error {
		if filter == nil {
			return errors.New("HPViewHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hpviewhistoryPager struct {
	reverse bool
	order   *HPViewHistoryOrder
	filter  func(*HPViewHistoryQuery) (*HPViewHistoryQuery, error)
}

func newHPViewHistoryPager(opts []HPViewHistoryPaginateOption, reverse bool) (*hpviewhistoryPager, error) {
	pager := &hpviewhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHPViewHistoryOrder
	}
	return pager, nil
}

func (p *hpviewhistoryPager) applyFilter(query *HPViewHistoryQuery) (*HPViewHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hpviewhistoryPager) toCursor(hvh *HPViewHistory) Cursor {
	return p.order.Field.toCursor(hvh)
}

func (p *hpviewhistoryPager) applyCursors(query *HPViewHistoryQuery, after, before *Cursor) (*HPViewHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHPViewHistoryOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hpviewhistoryPager) applyOrder(query *HPViewHistoryQuery) *HPViewHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultHPViewHistoryOrder.Field {
		query = query.Order(orderFunc(direction, DefaultHPViewHistoryOrder.Field.field))
	}
	return query
}

func (p *hpviewhistoryPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHPViewHistoryOrder.Field {
			b.Comma().Ident(DefaultHPViewHistoryOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HPViewHistory.
func (hvh *HPViewHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HPViewHistoryPaginateOption,
) (*HPViewHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHPViewHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hvh, err = pager.applyFilter(hvh); err != nil {
		return nil, err
	}
	conn := &HPViewHistoryConnection{Edges: []*HPViewHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hvh.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if hvh, err = pager.applyCursors(hvh, after, before); err != nil {
		return nil, err
	}
	hvh = pager.applyOrder(hvh)
	if limit := paginateLimit(first, last); limit != 0 {
		hvh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hvh.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hvh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HPViewHistoryOrderFieldCreatedAt orders HPViewHistory by created_at.
	HPViewHistoryOrderFieldCreatedAt = &HPViewHistoryOrderField{
		field: hpviewhistory.FieldCreatedAt,
		toCursor: func(hvh *HPViewHistory) Cursor {
			return Cursor{
				ID:    hvh.ID,
				Value: hvh.CreatedAt,
			}
		},
	}
	// HPViewHistoryOrderFieldUpdatedAt orders HPViewHistory by updated_at.
	HPViewHistoryOrderFieldUpdatedAt = &HPViewHistoryOrderField{
		field: hpviewhistory.FieldUpdatedAt,
		toCursor: func(hvh *HPViewHistory) Cursor {
			return Cursor{
				ID:    hvh.ID,
				Value: hvh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HPViewHistoryOrderField) String() string {
	var str string
	switch f.field {
	case hpviewhistory.FieldCreatedAt:
		str = "createdAt"
	case hpviewhistory.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HPViewHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HPViewHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HPViewHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *HPViewHistoryOrderFieldCreatedAt
	case "updatedAt":
		*f = *HPViewHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HPViewHistoryOrderField", str)
	}
	return nil
}

// HPViewHistoryOrderField defines the ordering field of HPViewHistory.
type HPViewHistoryOrderField struct {
	field    string
	toCursor func(*HPViewHistory) Cursor
}

// HPViewHistoryOrder defines the ordering of HPViewHistory.
type HPViewHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *HPViewHistoryOrderField `json:"field"`
}

// DefaultHPViewHistoryOrder is the default ordering of HPViewHistory.
var DefaultHPViewHistoryOrder = &HPViewHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HPViewHistoryOrderField{
		field: hpviewhistory.FieldID,
		toCursor: func(hvh *HPViewHistory) Cursor {
			return Cursor{ID: hvh.ID}
		},
	},
}

// ToEdge converts HPViewHistory into HPViewHistoryEdge.
func (hvh *HPViewHistory) ToEdge(order *HPViewHistoryOrder) *HPViewHistoryEdge {
	if order == nil {
		order = DefaultHPViewHistoryOrder
	}
	return &HPViewHistoryEdge{
		Node:   hvh,
		Cursor: order.Field.toCursor(hvh),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(orderFunc(direction, DefaultUserOrder.Field.field))
	}
	return query
}

func (p *userPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	u = pager.applyOrder(u)
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		field: user.FieldCreatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		field: user.FieldUpdatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.field {
	case user.FieldCreatedAt:
		str = "createdAt"
	case user.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *UserOrderFieldCreatedAt
	case "updatedAt":
		*f = *UserOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserNotificationSettingEdge is the edge representation of UserNotificationSetting.
type UserNotificationSettingEdge struct {
	Node   *UserNotificationSetting `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// UserNotificationSettingConnection is the connection containing edges to UserNotificationSetting.
type UserNotificationSettingConnection struct {
	Edges      []*UserNotificationSettingEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *UserNotificationSettingConnection) build(nodes []*UserNotificationSetting, pager *usernotificationsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserNotificationSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserNotificationSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserNotificationSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserNotificationSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserNotificationSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserNotificationSettingPaginateOption enables pagination customization.
type UserNotificationSettingPaginateOption func(*usernotificationsettingPager) error

// WithUserNotificationSettingOrder configures pagination ordering.
func WithUserNotificationSettingOrder(order *UserNotificationSettingOrder) UserNotificationSettingPaginateOption {
	if order == nil {
		order = DefaultUserNotificationSettingOrder
	}
	o := *order
	return func(pager *usernotificationsettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserNotificationSettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserNotificationSettingFilter configures pagination filter.
func WithUserNotificationSettingFilter(filter func(*UserNotificationSettingQuery) (*UserNotificationSettingQuery, error)) UserNotificationSettingPaginateOption {
	return func(pager *usernotificationsettingPager) error {
		if filter == nil {
			return errors.New("UserNotificationSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usernotificationsettingPager struct {
	reverse bool
	order   *UserNotificationSettingOrder
	filter  func(*UserNotificationSettingQuery) (*UserNotificationSettingQuery, error)
}

func newUserNotificationSettingPager(opts []UserNotificationSettingPaginateOption, reverse bool) (*usernotificationsettingPager, error) {
	pager := &usernotificationsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserNotificationSettingOrder
	}
	return pager, nil
}

func (p *usernotificationsettingPager) applyFilter(query *UserNotificationSettingQuery) (*UserNotificationSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usernotificationsettingPager) toCursor(uns *UserNotificationSetting) Cursor {
	return p.order.Field.toCursor(uns)
}

func (p *usernotificationsettingPager) applyCursors(query *UserNotificationSettingQuery, after, before *Cursor) (*UserNotificationSettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserNotificationSettingOrder.Field.field, p.order.Field.field, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usernotificationsettingPager) applyOrder(query *UserNotificationSettingQuery) *UserNotificationSettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(orderFunc(direction, p.order.Field.field))
	if p.order.Field != DefaultUserNotificationSettingOrder.Field {
		query = query.Order(orderFunc(direction, DefaultUserNotificationSettingOrder.Field.field))
	}
	return query
}

func (p *usernotificationsettingPager) orderExpr() sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserNotificationSettingOrder.Field {
			b.Comma().Ident(DefaultUserNotificationSettingOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserNotificationSetting.
func (uns *UserNotificationSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserNotificationSettingPaginateOption,
) (*UserNotificationSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserNotificationSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if uns, err = pager.applyFilter(uns); err != nil {
		return nil, err
	}
	conn := &UserNotificationSettingConnection{Edges: []*UserNotificationSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = uns.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if uns, err = pager.applyCursors(uns, after, before); err != nil {
		return nil, err
	}
	uns = pager.applyOrder(uns)
	if limit := paginateLimit(first, last); limit != 0 {
		uns.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := uns.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := uns.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserNotificationSettingOrderFieldCreatedAt orders UserNotificationSetting by created_at.
	UserNotificationSettingOrderFieldCreatedAt = &UserNotificationSettingOrderField{
		field: usernotificationsetting.FieldCreatedAt,
		toCursor: func(uns *UserNotificationSetting) Cursor {
			return Cursor{
				ID:    uns.ID,
				Value: uns.CreatedAt,
			}
		},
	}
	// UserNotificationSettingOrderFieldUpdatedAt orders UserNotificationSetting by updated_at.
	UserNotificationSettingOrderFieldUpdatedAt = &UserNotificationSettingOrderField{
		field: usernotificationsetting.FieldUpdatedAt,
		toCursor: func(uns *UserNotificationSetting) Cursor {
			return Cursor{
				ID:    uns.ID,
				Value: uns.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserNotificationSettingOrderField) String() string {
	var str string
	switch f.field {
	case usernotificationsetting.FieldCreatedAt:
		str = "createdAt"
	case usernotificationsetting.FieldUpdatedAt:
		str = "updatedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserNotificationSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserNotificationSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserNotificationSettingOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *UserNotificationSettingOrderFieldCreatedAt
	case "updatedAt":
		*f = *UserNotificationSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserNotificationSettingOrderField", str)
	}
	return nil
}

// UserNotificationSettingOrderField defines the ordering field of UserNotificationSetting.
type UserNotificationSettingOrderField struct {
	field    string
	toCursor func(*UserNotificationSetting) Cursor
}

// UserNotificationSettingOrder defines the ordering of UserNotificationSetting.
type UserNotificationSettingOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *UserNotificationSettingOrderField `json:"field"`
}

// DefaultUserNotificationSettingOrder is the default ordering of UserNotificationSetting.
var DefaultUserNotificationSettingOrder = &UserNotificationSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserNotificationSettingOrderField{
		field: usernotificationsetting.FieldID,
		toCursor: func(uns *UserNotificationSetting) Cursor {
			return Cursor{ID: uns.ID}
		},
	},
}

// ToEdge converts UserNotificationSetting into UserNotificationSettingEdge.
func (uns *UserNotificationSetting) ToEdge(order *UserNotificationSettingOrder) *UserNotificationSettingEdge {
	if order == nil {
		order = DefaultUserNotificationSettingOrder
	}
	return &UserNotificationSettingEdge{
		Node:   uns,
		Cursor: order.Field.toCursor(uns),
	}
}
