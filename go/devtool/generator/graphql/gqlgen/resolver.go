package gqlgen

import (
	"html/template"
	"os"
	"path/filepath"

	"hpapp.yssk22.dev/go/devtool/generator"
)

func NewResolverGenerator(path string, modelPackage string, options ...ResolverGeneratorOption) generator.Generator {
	r := &resolverGenerator{
		path:         path,
		modelPackage: modelPackage,
		withMutation: true,
		withQuery:    true,
	}
	for _, opt := range options {
		opt(r)
	}
	return r
}

type ResolverGeneratorOption func(g *resolverGenerator)

func WithMutation(with bool) ResolverGeneratorOption {
	return func(g *resolverGenerator) {
		g.withMutation = with
	}
}

func WithQuery(with bool) ResolverGeneratorOption {
	return func(g *resolverGenerator) {
		g.withQuery = with
	}
}

type resolverGenerator struct {
	path         string
	modelPackage string
	withMutation bool
	withQuery    bool
}

func (r *resolverGenerator) Name() string {
	return "gqlgen Resolver Generator"
}

func (r *resolverGenerator) Generate() error {
	err := os.MkdirAll(filepath.Dir(r.path), 0755)
	if err != nil {
		return err
	}
	f, err := os.OpenFile(r.path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()
	targetFullPath, err := filepath.Abs(r.path)
	if err != nil {
		return err
	}
	vars := map[string]interface{}{
		"TargetPackage":   filepath.Base(filepath.Dir(targetFullPath)),
		"ModelPackage":    r.modelPackage,
		"ModelPackageRef": filepath.Base(r.modelPackage),
		"WithMutation":    r.withMutation,
		"WithQuery":       r.withQuery,
	}
	return resolverTemplate.Execute(f, vars)
}

var resolverTemplate = template.Must(
	template.New("gqlGenResolverTemplate").Parse(`// GENERATED BY gqlgen Resolver Generator; DO NOT EDIT
package {{.TargetPackage}}

import "{{.ModelPackage}}"

type Resolver struct{}

{{if .WithQuery }}
var query = &{{.ModelPackageRef}}.Query{}

func (r *Resolver) Query() QueryResolver { return query }
{{end}}

{{if .WithQuery }}
var mutation = &{{.ModelPackageRef}}.Mutation{}

func (r *Resolver) Mutation() MutationResolver { return mutation }
{{end}}
`))
